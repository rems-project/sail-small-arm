(*Generated by Sail from armV8.*)
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import armV8_types.
Require Import armV8_extras.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition b1 := B1.
#[export] Hint Unfold b1 : sail.
Definition b0 := B0.
#[export] Hint Unfold b0 : sail.


Definition neq_int (x : Z) (y : Z) : bool := negb ((Z.eqb (x) (y))).

Definition neq_bool (x : bool) (y : bool) : bool := negb ((Bool.eqb (x) (y))).





Definition neq_vec' {n : Z} (x : mword n) (y : mword n) : bool := negb ((eq_vec (x) (y))).

Definition __id (x : Z) : Z := x.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shl_int (m) (n) else shr_int (m) ((Z.opp (n))).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shr_int (m) (n) else shl_int (m) ((Z.opp (n))).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb ((Z.ltb (n) (0))) ((Z.gtb (m) (0))) then Z.sub ((Z.quot ((Z.add (n) (1))) (m))) (1)
   else if andb ((Z.gtb (n) (0))) ((Z.ltb (m) (0))) then Z.sub ((Z.quot ((Z.sub (n) (1))) (m))) (1)
   else Z.quot (n) (m).

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub (n) ((Z.mul (m) ((fdiv_int (n) (m))))).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb (len) v0 then vector_truncate (v) (len) else zero_extend (v) (len).

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec ((zeros (n))).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb (l) (n) then shiftl ((sail_ones (n))) (i)
   else
     let one : bits n := sail_mask (n) ((('b"1")  : bits 1)) in
     shiftl ((sub_vec ((shiftl (one) (l))) (one))) (i).

Definition to_bytes_le (n : Z) (b : mword (8 * n)) (*n >? 0*) : vec (mword 8) n :=
   let res := vector_init (n) ((zeros (8))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       vec_update_dec (res) (i)
         ((autocast (T := mword) (subrange_vec_dec (b) ((Z.add ((Z.mul (8) (i))) (7)))
                                    ((Z.mul (8) (i)))))))).

Definition from_bytes_le (n : Z) (v : vec (mword 8) n) (*n >? 0*) : mword (8 * n) :=
   let res := zeros ((Z.mul (8) (n))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       update_subrange_vec_dec (res) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))
         ((autocast (T := mword) (vec_access_dec (v) (i)))))).

Definition reverse_endianness {n : Z} (xs : mword n) (*member_Z_list n [8; 16; 32; 64; 128]*)
: mword n :=
   let len := length_mword (xs) in
   if Z.eqb n (8) then xs
   else if Z.eqb n (16) then
     autocast (T := mword) (concat_vec ((subrange_vec_dec (xs) (7) (0)))
                              ((subrange_vec_dec (xs) (15) (8))))
   else if Z.eqb n (32) then
     autocast (T := mword) (concat_vec ((subrange_vec_dec (xs) (7) (0)))
                              ((concat_vec ((subrange_vec_dec (xs) (15) (8)))
                                  ((concat_vec ((subrange_vec_dec (xs) (23) (16)))
                                      ((subrange_vec_dec (xs) (31) (24))))))))
   else if Z.eqb n (64) then
     autocast (T := mword) (concat_vec ((subrange_vec_dec (xs) (7) (0)))
                              ((concat_vec ((subrange_vec_dec (xs) (15) (8)))
                                  ((concat_vec ((subrange_vec_dec (xs) (23) (16)))
                                      ((concat_vec ((subrange_vec_dec (xs) (31) (24)))
                                          ((concat_vec ((subrange_vec_dec (xs) (39) (32)))
                                              ((concat_vec ((subrange_vec_dec (xs) (47) (40)))
                                                  ((concat_vec ((subrange_vec_dec (xs) (55) (48)))
                                                      ((subrange_vec_dec (xs) (63) (56))))))))))))))))
   else
     autocast (T := mword) (concat_vec ((subrange_vec_dec (xs) (7) (0)))
                              ((concat_vec ((subrange_vec_dec (xs) (15) (8)))
                                  ((concat_vec ((subrange_vec_dec (xs) (23) (16)))
                                      ((concat_vec ((subrange_vec_dec (xs) (31) (24)))
                                          ((concat_vec ((subrange_vec_dec (xs) (39) (32)))
                                              ((concat_vec ((subrange_vec_dec (xs) (47) (40)))
                                                  ((concat_vec ((subrange_vec_dec (xs) (55) (48)))
                                                      ((concat_vec
                                                          ((subrange_vec_dec (xs) (63) (56)))
                                                          ((concat_vec
                                                              ((subrange_vec_dec (xs) (71) (64)))
                                                              ((concat_vec
                                                                  ((subrange_vec_dec (xs) (79) (72)))
                                                                  ((concat_vec
                                                                      ((subrange_vec_dec (xs) (87)
                                                                          (80)))
                                                                      ((concat_vec
                                                                          ((subrange_vec_dec (xs)
                                                                              (95) (88)))
                                                                          ((concat_vec
                                                                              ((subrange_vec_dec
                                                                                  (xs) (103) (96)))
                                                                              ((concat_vec
                                                                                  ((subrange_vec_dec
                                                                                      (xs) (111)
                                                                                      (104)))
                                                                                  ((concat_vec
                                                                                      ((subrange_vec_dec
                                                                                          (xs) (119)
                                                                                          (112)))
                                                                                      ((subrange_vec_dec
                                                                                          (xs) (127)
                                                                                          (120)))))))))))))))))))))))))))))))).

Definition undefined_read_kind '(tt : unit) : read_kind := Read_plain.

Definition undefined_write_kind '(tt : unit) : write_kind := Write_plain.

Definition undefined_a64_barrier_domain '(tt : unit) : a64_barrier_domain := A64_FullShare.

Definition undefined_a64_barrier_type '(tt : unit) : a64_barrier_type := A64_barrier_all.

Definition undefined_trans_kind '(tt : unit) : trans_kind := Transaction_start.

Definition undefined_cache_op_kind '(tt : unit) : cache_op_kind := Cache_op_D_IVAC.

Definition zopz0zI_s {n : Z} (x : mword n) (y : mword n) (*n >? 0*) : bool :=
   Z.ltb ((sint (x))) ((sint (y))).

Definition zopz0zKzJ_s {n : Z} (x : mword n) (y : mword n) (*n >? 0*) : bool :=
   Z.geb ((sint (x))) ((sint (y))).

Definition zopz0zI_u {n : Z} (x : mword n) (y : mword n) : bool := Z.ltb ((uint (x))) ((uint (y))).

Definition zopz0zKzJ_u {n : Z} (x : mword n) (y : mword n) : bool :=
   Z.geb ((uint (x))) ((uint (y))).

Definition zopz0zIzJ_u {n : Z} (x : mword n) (y : mword n) : bool :=
   Z.leb ((uint (x))) ((uint (y))).

Definition cast_bool_bit (b : bool) : bitU := match b with | true => b1 | false => b0 end.

Definition cast_bit_bool (b : bitU) : M (bool) :=
   (match b with
    | B0 => returnM (false)
    | B1 => returnM (true)
    | _ =>
       assert_exp' false "Pattern match failure at prelude.sail:108.2-111.3" >>= fun _ => exit tt
    end)
    : M (bool).

Definition __GetSlice_int (n : Z) (m : Z) (o : Z) (*n >=? 0*) : mword n :=
   get_slice_int (n) (m) (o).

Definition to_bits (l : Z) (n : Z) (*l >=? 0*) : mword l := get_slice_int (l) (n) (0).

Definition mask {m : Z} (len : Z) (bv : mword m) (*(len >=? 0) && (m >=? 0)*) : mword len :=
   sail_mask (len) (bv).

Definition error {a : Type} (message : string) : M (a) :=
   assert_exp' false message >>= fun _ => exit tt.

Definition undefined_TMSTATUS_type '(tt : unit) : M (mword 64) :=
   (undefined_bitvector (64))  : M (mword 64).

Definition Mk_TMSTATUS_type (v : mword 64) : mword 64 := v.

Definition _get_TMSTATUS_type_bits (v : mword 64) : mword 64 :=
   subrange_vec_dec (v) ((Z.sub (64) (1))) (0).

Definition _update_TMSTATUS_type_bits (v : mword 64) (x : mword 64) : mword 64 :=
   update_subrange_vec_dec (v) ((Z.sub (64) (1))) (0) (x).

Definition _update_CurrentEL_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_DAIF_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_DBGOSDLR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_DBGPRCR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_EDSCR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_HCR_type_bits (v : mword 64) (x : mword 64) : mword 64 :=
   update_subrange_vec_dec (v) ((Z.sub (64) (1))) (0) (x).

Definition _update_ID_AA64MMFR0_type_bits (v : mword 64) (x : mword 64) : mword 64 :=
   update_subrange_vec_dec (v) ((Z.sub (64) (1))) (0) (x).

Definition _update_NZCV_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_OSDLR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_SCRType_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_SCTLR_EL1_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_SCTLR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_SPSR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_SPSel_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_TCR_EL1_type_bits (v : mword 64) (x : mword 64) : mword 64 :=
   update_subrange_vec_dec (v) ((Z.sub (64) (1))) (0) (x).

Definition _update_TCR_type_bits (v : mword 32) (x : mword 32) : mword 32 :=
   update_subrange_vec_dec (v) ((Z.sub (32) (1))) (0) (x).

Definition _update_TXIDR_EL0_type_bits (v : mword 64) (x : mword 64) : mword 64 :=
   update_subrange_vec_dec (v) ((Z.sub (64) (1))) (0) (x).

Definition _set_TMSTATUS_type_bits (r_ref : register_ref register (mword 64)) (v : mword 64)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_bits (r) (v))
    : M (unit).

Definition _get_CurrentEL_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_DAIF_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_DBGOSDLR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_DBGPRCR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_EDSCR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_HCR_type_bits (v : mword 64) : mword 64 :=
   subrange_vec_dec (v) ((Z.sub (64) (1))) (0).

Definition _get_ID_AA64MMFR0_type_bits (v : mword 64) : mword 64 :=
   subrange_vec_dec (v) ((Z.sub (64) (1))) (0).

Definition _get_NZCV_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_OSDLR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_SCRType_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_SCTLR_EL1_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_SCTLR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_SPSR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_SPSel_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_TCR_EL1_type_bits (v : mword 64) : mword 64 :=
   subrange_vec_dec (v) ((Z.sub (64) (1))) (0).

Definition _get_TCR_type_bits (v : mword 32) : mword 32 :=
   subrange_vec_dec (v) ((Z.sub (32) (1))) (0).

Definition _get_TXIDR_EL0_type_bits (v : mword 64) : mword 64 :=
   subrange_vec_dec (v) ((Z.sub (64) (1))) (0).

Definition _set_CurrentEL_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_CurrentEL_type_bits (r) (v))
    : M (unit).

Definition _set_DAIF_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_DAIF_type_bits (r) (v))  : M (unit).

Definition _set_DBGOSDLR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_DBGOSDLR_type_bits (r) (v))
    : M (unit).

Definition _set_DBGPRCR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_DBGPRCR_type_bits (r) (v))
    : M (unit).

Definition _set_EDSCR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_EDSCR_type_bits (r) (v))
    : M (unit).

Definition _set_HCR_type_bits (r_ref : register_ref register (mword 64)) (v : mword 64) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_bits (r) (v))  : M (unit).

Definition _set_ID_AA64MMFR0_type_bits (r_ref : register_ref register (mword 64)) (v : mword 64)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_bits (r) (v))
    : M (unit).

Definition _set_NZCV_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_NZCV_type_bits (r) (v))  : M (unit).

Definition _set_OSDLR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_OSDLR_type_bits (r) (v))
    : M (unit).

Definition _set_SCRType_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_bits (r) (v))  : M (unit).

Definition _set_SCTLR_EL1_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_bits (r) (v))
    : M (unit).

Definition _set_SCTLR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_type_bits (r) (v))
    : M (unit).

Definition _set_SPSR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_bits (r) (v))  : M (unit).

Definition _set_SPSel_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SPSel_type_bits (r) (v))
    : M (unit).

Definition _set_TCR_EL1_type_bits (r_ref : register_ref register (mword 64)) (v : mword 64)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_bits (r) (v))
    : M (unit).

Definition _set_TCR_type_bits (r_ref : register_ref register (mword 32)) (v : mword 32) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_bits (r) (v))  : M (unit).

Definition _set_TXIDR_EL0_type_bits (r_ref : register_ref register (mword 64)) (v : mword 64)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TXIDR_EL0_type_bits (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_ABRT (v : mword 64) : mword 1 := subrange_vec_dec (v) (9) (9).

Definition _update_TMSTATUS_type_ABRT (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (9) (9) (x).

Definition _set_TMSTATUS_type_ABRT (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_ABRT (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_DBG (v : mword 64) : mword 1 := subrange_vec_dec (v) (15) (15).

Definition _update_TMSTATUS_type_DBG (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (15) (15) (x).

Definition _set_TMSTATUS_type_DBG (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_DBG (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_ERR (v : mword 64) : mword 1 := subrange_vec_dec (v) (13) (13).

Definition _update_TMSTATUS_type_ERR (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (13) (13) (x).

Definition _update_EDSCR_type_ERR (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (6) (6) (x).

Definition _set_TMSTATUS_type_ERR (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_ERR (r) (v))
    : M (unit).

Definition _get_EDSCR_type_ERR (v : mword 32) : mword 1 := subrange_vec_dec (v) (6) (6).

Definition _set_EDSCR_type_ERR (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_ERR (r) (v))  : M (unit).

Definition _get_TMSTATUS_type_IMP (v : mword 64) : mword 1 := subrange_vec_dec (v) (16) (16).

Definition _update_TMSTATUS_type_IMP (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (16) (16) (x).

Definition _set_TMSTATUS_type_IMP (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_IMP (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_INV (v : mword 64) : mword 1 := subrange_vec_dec (v) (12) (12).

Definition _update_TMSTATUS_type_INV (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (12) (12) (x).

Definition _set_TMSTATUS_type_INV (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_INV (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_MEM (v : mword 64) : mword 1 := subrange_vec_dec (v) (14) (14).

Definition _update_TMSTATUS_type_MEM (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (14) (14) (x).

Definition _set_TMSTATUS_type_MEM (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_MEM (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_NEST (v : mword 64) : mword 1 := subrange_vec_dec (v) (10) (10).

Definition _update_TMSTATUS_type_NEST (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (10) (10) (x).

Definition _set_TMSTATUS_type_NEST (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_NEST (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_REASON (v : mword 64) : mword 5 := subrange_vec_dec (v) (4) (0).

Definition _update_TMSTATUS_type_REASON (v : mword 64) (x : mword 5) : mword 64 :=
   update_subrange_vec_dec (v) (4) (0) (x).

Definition _set_TMSTATUS_type_REASON (r_ref : register_ref register (mword 64)) (v : mword 5)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_REASON (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_RTRY (v : mword 64) : mword 1 := subrange_vec_dec (v) (8) (8).

Definition _update_TMSTATUS_type_RTRY (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (8) (8) (x).

Definition _set_TMSTATUS_type_RTRY (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_RTRY (r) (v))
    : M (unit).

Definition _get_TMSTATUS_type_SIZE (v : mword 64) : mword 1 := subrange_vec_dec (v) (11) (11).

Definition _update_TMSTATUS_type_SIZE (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (11) (11) (x).

Definition _set_TMSTATUS_type_SIZE (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TMSTATUS_type_SIZE (r) (v))
    : M (unit).

Definition _R : vec (register_ref register (bits 64)) 31 :=
vec_of_list_len [R30_ref;R29_ref;R28_ref;R27_ref;R26_ref;R25_ref;R24_ref;R23_ref;R22_ref;R21_ref;
                 R20_ref;R19_ref;R18_ref;R17_ref;R16_ref;R15_ref;R14_ref;R13_ref;R12_ref;R11_ref;
                 R10_ref;R9_ref;R8_ref;R7_ref;R6_ref;R5_ref;R4_ref;R3_ref;R2_ref;R1_ref;R0_ref].
#[export] Hint Unfold _R : sail.
Definition UInt_reg (x : mword 5) : Z := uint (x).

Definition _V : vec (register_ref register (bits 128)) 32 :=
vec_of_list_len [V31_ref;V30_ref;V29_ref;V28_ref;V27_ref;V26_ref;V25_ref;V24_ref;V23_ref;V22_ref;
                 V21_ref;V20_ref;V19_ref;V18_ref;V17_ref;V16_ref;V15_ref;V14_ref;V13_ref;V12_ref;
                 V11_ref;V10_ref;V9_ref;V8_ref;V7_ref;V6_ref;V5_ref;V4_ref;V3_ref;V2_ref;V1_ref;
                 V0_ref].
#[export] Hint Unfold _V : sail.
Definition lsl' (n : Z) (m : Z) (*(m >=? 0) && (n >=? 0)*) : Z := Z.mul (n) ((pow2 (m))).

Definition not_implemented {a : Type} (message : string) : M (a) :=
   let '(_) := (print_endline (message))  : unit in
   exit tt
    : M (a).

Definition not_implemented_extern {a : Type} (message : string) : M (a) :=
   let '(_) := (print_endline (message))  : unit in
   exit tt
    : M (a).

Definition info (message : string) : unit := print_endline (message).

Definition undefined_IMPLEMENTATION_DEFINED_type '(tt : unit) : M (IMPLEMENTATION_DEFINED_type) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   returnM (({| IMPLEMENTATION_DEFINED_type_HaveCRCExt := w__0;
                IMPLEMENTATION_DEFINED_type_HaveAArch32EL := w__1;
                IMPLEMENTATION_DEFINED_type_HaveAnyAArch32 := w__2;
                IMPLEMENTATION_DEFINED_type_HaveEL2 := w__3;
                IMPLEMENTATION_DEFINED_type_HaveEL3 := w__4;
                IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32 := w__5;
                IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3 := w__6 |})).

Definition IMPLEMENTATION_DEFINED : IMPLEMENTATION_DEFINED_type :=
{| IMPLEMENTATION_DEFINED_type_HaveCRCExt := true;
   IMPLEMENTATION_DEFINED_type_HaveAArch32EL := false;
   IMPLEMENTATION_DEFINED_type_HaveAnyAArch32 := false;
   IMPLEMENTATION_DEFINED_type_HaveEL2 := false;
   IMPLEMENTATION_DEFINED_type_HaveEL3 := false;
   IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32 := false;
   IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3 := false |}.
#[export] Hint Unfold IMPLEMENTATION_DEFINED : sail.
Definition UNKNOWN := 0.
#[export] Hint Unfold UNKNOWN : sail.
Definition UNKNOWN_BITS (N : Z) (*N >=? 0*) : mword N :=
   (autocast (T := mword) (replicate_bits ((('b"0")  : mword 1)) ((__id (N)))))  : bits N.

Definition UNKNOWN_BIT := b0.
#[export] Hint Unfold UNKNOWN_BIT : sail.
Definition speculate_exclusive_success '(tt : unit) : M (bool) := (excl_result (tt))  : M (bool).

Definition undefined_HCR_type '(tt : unit) : M (mword 64) :=
   (undefined_bitvector (64))  : M (mword 64).

Definition Mk_HCR_type (v : mword 64) : mword 64 := v.

Definition _get_HCR_type_AMO (v : mword 64) : mword 1 := subrange_vec_dec (v) (5) (5).

Definition _update_HCR_type_AMO (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (5) (5) (x).

Definition _set_HCR_type_AMO (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_AMO (r) (v))  : M (unit).

Definition _get_HCR_type_BSU (v : mword 64) : mword 2 := subrange_vec_dec (v) (11) (10).

Definition _update_HCR_type_BSU (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (11) (10) (x).

Definition _set_HCR_type_BSU (r_ref : register_ref register (mword 64)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_BSU (r) (v))  : M (unit).

Definition _get_HCR_type_CD (v : mword 64) : mword 1 := subrange_vec_dec (v) (32) (32).

Definition _update_HCR_type_CD (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (32) (32) (x).

Definition _set_HCR_type_CD (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_CD (r) (v))  : M (unit).

Definition _get_HCR_type_DC (v : mword 64) : mword 1 := subrange_vec_dec (v) (12) (12).

Definition _update_HCR_type_DC (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (12) (12) (x).

Definition _set_HCR_type_DC (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_DC (r) (v))  : M (unit).

Definition _get_HCR_type_FB (v : mword 64) : mword 1 := subrange_vec_dec (v) (9) (9).

Definition _update_HCR_type_FB (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (9) (9) (x).

Definition _set_HCR_type_FB (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_FB (r) (v))  : M (unit).

Definition _get_HCR_type_FMO (v : mword 64) : mword 1 := subrange_vec_dec (v) (3) (3).

Definition _update_HCR_type_FMO (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (3) (3) (x).

Definition _set_HCR_type_FMO (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_FMO (r) (v))  : M (unit).

Definition _get_HCR_type_HCD (v : mword 64) : mword 1 := subrange_vec_dec (v) (29) (29).

Definition _update_HCR_type_HCD (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (29) (29) (x).

Definition _set_HCR_type_HCD (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_HCD (r) (v))  : M (unit).

Definition _get_HCR_type_ID (v : mword 64) : mword 1 := subrange_vec_dec (v) (33) (33).

Definition _update_HCR_type_ID (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (33) (33) (x).

Definition _set_HCR_type_ID (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_ID (r) (v))  : M (unit).

Definition _get_HCR_type_IMO (v : mword 64) : mword 1 := subrange_vec_dec (v) (4) (4).

Definition _update_HCR_type_IMO (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (4) (4) (x).

Definition _set_HCR_type_IMO (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_IMO (r) (v))  : M (unit).

Definition _get_HCR_type_PTW (v : mword 64) : mword 1 := subrange_vec_dec (v) (2) (2).

Definition _update_HCR_type_PTW (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (2) (2) (x).

Definition _set_HCR_type_PTW (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_PTW (r) (v))  : M (unit).

Definition _get_HCR_type_RW (v : mword 64) : mword 1 := subrange_vec_dec (v) (31) (31).

Definition _update_HCR_type_RW (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (31) (31) (x).

Definition _update_EDSCR_type_RW (v : mword 32) (x : mword 4) : mword 32 :=
   update_subrange_vec_dec (v) (13) (10) (x).

Definition _update_SCRType_RW (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (10) (10) (x).

Definition _set_HCR_type_RW (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_RW (r) (v))  : M (unit).

Definition _get_EDSCR_type_RW (v : mword 32) : mword 4 := subrange_vec_dec (v) (13) (10).

Definition _get_SCRType_RW (v : mword 32) : mword 1 := subrange_vec_dec (v) (10) (10).

Definition _set_EDSCR_type_RW (r_ref : register_ref register (mword 32)) (v : mword 4) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_RW (r) (v))  : M (unit).

Definition _set_SCRType_RW (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_RW (r) (v))  : M (unit).

Definition _get_HCR_type_SWIO (v : mword 64) : mword 1 := subrange_vec_dec (v) (1) (1).

Definition _update_HCR_type_SWIO (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (1) (1) (x).

Definition _set_HCR_type_SWIO (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_SWIO (r) (v))  : M (unit).

Definition _get_HCR_type_TACR (v : mword 64) : mword 1 := subrange_vec_dec (v) (21) (21).

Definition _update_HCR_type_TACR (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (21) (21) (x).

Definition _set_HCR_type_TACR (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TACR (r) (v))  : M (unit).

Definition _get_HCR_type_TDZ (v : mword 64) : mword 1 := subrange_vec_dec (v) (28) (28).

Definition _update_HCR_type_TDZ (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (28) (28) (x).

Definition _set_HCR_type_TDZ (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TDZ (r) (v))  : M (unit).

Definition _get_HCR_type_TGE (v : mword 64) : mword 1 := subrange_vec_dec (v) (27) (27).

Definition _update_HCR_type_TGE (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (27) (27) (x).

Definition _set_HCR_type_TGE (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TGE (r) (v))  : M (unit).

Definition _get_HCR_type_TID0 (v : mword 64) : mword 1 := subrange_vec_dec (v) (15) (15).

Definition _update_HCR_type_TID0 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (15) (15) (x).

Definition _set_HCR_type_TID0 (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TID0 (r) (v))  : M (unit).

Definition _get_HCR_type_TID1 (v : mword 64) : mword 1 := subrange_vec_dec (v) (16) (16).

Definition _update_HCR_type_TID1 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (16) (16) (x).

Definition _set_HCR_type_TID1 (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TID1 (r) (v))  : M (unit).

Definition _get_HCR_type_TID2 (v : mword 64) : mword 1 := subrange_vec_dec (v) (17) (17).

Definition _update_HCR_type_TID2 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (17) (17) (x).

Definition _set_HCR_type_TID2 (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TID2 (r) (v))  : M (unit).

Definition _get_HCR_type_TID3 (v : mword 64) : mword 1 := subrange_vec_dec (v) (18) (18).

Definition _update_HCR_type_TID3 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (18) (18) (x).

Definition _set_HCR_type_TID3 (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TID3 (r) (v))  : M (unit).

Definition _get_HCR_type_TIDCP (v : mword 64) : mword 1 := subrange_vec_dec (v) (20) (20).

Definition _update_HCR_type_TIDCP (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (20) (20) (x).

Definition _set_HCR_type_TIDCP (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TIDCP (r) (v))  : M (unit).

Definition _get_HCR_type_TPC (v : mword 64) : mword 1 := subrange_vec_dec (v) (23) (23).

Definition _update_HCR_type_TPC (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (23) (23) (x).

Definition _set_HCR_type_TPC (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TPC (r) (v))  : M (unit).

Definition _get_HCR_type_TPU (v : mword 64) : mword 1 := subrange_vec_dec (v) (24) (24).

Definition _update_HCR_type_TPU (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (24) (24) (x).

Definition _set_HCR_type_TPU (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TPU (r) (v))  : M (unit).

Definition _get_HCR_type_TRVM (v : mword 64) : mword 1 := subrange_vec_dec (v) (30) (30).

Definition _update_HCR_type_TRVM (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (30) (30) (x).

Definition _set_HCR_type_TRVM (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TRVM (r) (v))  : M (unit).

Definition _get_HCR_type_TSC (v : mword 64) : mword 1 := subrange_vec_dec (v) (19) (19).

Definition _update_HCR_type_TSC (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (19) (19) (x).

Definition _set_HCR_type_TSC (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TSC (r) (v))  : M (unit).

Definition _get_HCR_type_TSW (v : mword 64) : mword 1 := subrange_vec_dec (v) (22) (22).

Definition _update_HCR_type_TSW (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (22) (22) (x).

Definition _set_HCR_type_TSW (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TSW (r) (v))  : M (unit).

Definition _get_HCR_type_TTLB (v : mword 64) : mword 1 := subrange_vec_dec (v) (25) (25).

Definition _update_HCR_type_TTLB (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (25) (25) (x).

Definition _set_HCR_type_TTLB (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TTLB (r) (v))  : M (unit).

Definition _get_HCR_type_TVM (v : mword 64) : mword 1 := subrange_vec_dec (v) (26) (26).

Definition _update_HCR_type_TVM (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (26) (26) (x).

Definition _set_HCR_type_TVM (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TVM (r) (v))  : M (unit).

Definition _get_HCR_type_TWE (v : mword 64) : mword 1 := subrange_vec_dec (v) (14) (14).

Definition _update_HCR_type_TWE (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (14) (14) (x).

Definition _update_SCRType_TWE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (13) (13) (x).

Definition _set_HCR_type_TWE (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TWE (r) (v))  : M (unit).

Definition _get_SCRType_TWE (v : mword 32) : mword 1 := subrange_vec_dec (v) (13) (13).

Definition _set_SCRType_TWE (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_TWE (r) (v))  : M (unit).

Definition _get_HCR_type_TWI (v : mword 64) : mword 1 := subrange_vec_dec (v) (13) (13).

Definition _update_HCR_type_TWI (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (13) (13) (x).

Definition _update_SCRType_TWI (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (12) (12) (x).

Definition _set_HCR_type_TWI (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_TWI (r) (v))  : M (unit).

Definition _get_SCRType_TWI (v : mword 32) : mword 1 := subrange_vec_dec (v) (12) (12).

Definition _set_SCRType_TWI (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_TWI (r) (v))  : M (unit).

Definition _get_HCR_type_VF (v : mword 64) : mword 1 := subrange_vec_dec (v) (6) (6).

Definition _update_HCR_type_VF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (6) (6) (x).

Definition _set_HCR_type_VF (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_VF (r) (v))  : M (unit).

Definition _get_HCR_type_VI (v : mword 64) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _update_HCR_type_VI (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _set_HCR_type_VI (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_VI (r) (v))  : M (unit).

Definition _get_HCR_type_VM (v : mword 64) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_HCR_type_VM (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_HCR_type_VM (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_VM (r) (v))  : M (unit).

Definition _get_HCR_type_VSE (v : mword 64) : mword 1 := subrange_vec_dec (v) (8) (8).

Definition _update_HCR_type_VSE (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (8) (8) (x).

Definition _set_HCR_type_VSE (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_HCR_type_VSE (r) (v))  : M (unit).

Definition undefined_ID_AA64MMFR0_type '(tt : unit) : M (mword 64) :=
   (undefined_bitvector (64))  : M (mword 64).

Definition Mk_ID_AA64MMFR0_type (v : mword 64) : mword 64 := v.

Definition _get_ID_AA64MMFR0_type_ASIDBits (v : mword 64) : mword 4 := subrange_vec_dec (v) (7) (4).

Definition _update_ID_AA64MMFR0_type_ASIDBits (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (7) (4) (x).

Definition _set_ID_AA64MMFR0_type_ASIDBits (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_ASIDBits (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_BigEnd (v : mword 64) : mword 4 := subrange_vec_dec (v) (11) (8).

Definition _update_ID_AA64MMFR0_type_BigEnd (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (11) (8) (x).

Definition _set_ID_AA64MMFR0_type_BigEnd (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_BigEnd (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_BigEndEL0 (v : mword 64) : mword 4 :=
   subrange_vec_dec (v) (19) (16).

Definition _update_ID_AA64MMFR0_type_BigEndEL0 (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (19) (16) (x).

Definition _set_ID_AA64MMFR0_type_BigEndEL0 (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_BigEndEL0 (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_PARange (v : mword 64) : mword 4 := subrange_vec_dec (v) (3) (0).

Definition _update_ID_AA64MMFR0_type_PARange (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (3) (0) (x).

Definition _set_ID_AA64MMFR0_type_PARange (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_PARange (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_SNSMem (v : mword 64) : mword 4 := subrange_vec_dec (v) (15) (12).

Definition _update_ID_AA64MMFR0_type_SNSMem (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (15) (12) (x).

Definition _set_ID_AA64MMFR0_type_SNSMem (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_SNSMem (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_TGran16 (v : mword 64) : mword 4 :=
   subrange_vec_dec (v) (23) (20).

Definition _update_ID_AA64MMFR0_type_TGran16 (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (23) (20) (x).

Definition _set_ID_AA64MMFR0_type_TGran16 (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_TGran16 (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_TGran4 (v : mword 64) : mword 4 := subrange_vec_dec (v) (31) (28).

Definition _update_ID_AA64MMFR0_type_TGran4 (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (31) (28) (x).

Definition _set_ID_AA64MMFR0_type_TGran4 (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_TGran4 (r) (v))
    : M (unit).

Definition _get_ID_AA64MMFR0_type_TGran64 (v : mword 64) : mword 4 :=
   subrange_vec_dec (v) (27) (24).

Definition _update_ID_AA64MMFR0_type_TGran64 (v : mword 64) (x : mword 4) : mword 64 :=
   update_subrange_vec_dec (v) (27) (24) (x).

Definition _set_ID_AA64MMFR0_type_TGran64 (r_ref : register_ref register (mword 64)) (v : mword 4)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_ID_AA64MMFR0_type_TGran64 (r) (v))
    : M (unit).

Definition undefined_SCRType '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_SCRType (v : mword 32) : mword 32 := v.

Definition _get_SCRType_EA (v : mword 32) : mword 1 := subrange_vec_dec (v) (3) (3).

Definition _update_SCRType_EA (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (3) (3) (x).

Definition _set_SCRType_EA (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_EA (r) (v))  : M (unit).

Definition _get_SCRType_FIQ (v : mword 32) : mword 1 := subrange_vec_dec (v) (2) (2).

Definition _update_SCRType_FIQ (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (2) (2) (x).

Definition _set_SCRType_FIQ (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_FIQ (r) (v))  : M (unit).

Definition _get_SCRType_HCE (v : mword 32) : mword 1 := subrange_vec_dec (v) (8) (8).

Definition _update_SCRType_HCE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (8) (8) (x).

Definition _set_SCRType_HCE (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_HCE (r) (v))  : M (unit).

Definition _get_SCRType_IRQ (v : mword 32) : mword 1 := subrange_vec_dec (v) (1) (1).

Definition _update_SCRType_IRQ (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (1) (1) (x).

Definition _set_SCRType_IRQ (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_IRQ (r) (v))  : M (unit).

Definition _get_SCRType_NS (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_SCRType_NS (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _update_EDSCR_type_NS (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (18) (18) (x).

Definition _set_SCRType_NS (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_NS (r) (v))  : M (unit).

Definition _get_EDSCR_type_NS (v : mword 32) : mword 1 := subrange_vec_dec (v) (18) (18).

Definition _set_EDSCR_type_NS (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_NS (r) (v))  : M (unit).

Definition _get_SCRType_SIF (v : mword 32) : mword 1 := subrange_vec_dec (v) (9) (9).

Definition _update_SCRType_SIF (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (9) (9) (x).

Definition _set_SCRType_SIF (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_SIF (r) (v))  : M (unit).

Definition _get_SCRType_SMD (v : mword 32) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _update_SCRType_SMD (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _set_SCRType_SMD (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_SMD (r) (v))  : M (unit).

Definition _get_SCRType_ST (v : mword 32) : mword 1 := subrange_vec_dec (v) (11) (11).

Definition _update_SCRType_ST (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (11) (11) (x).

Definition _set_SCRType_ST (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCRType_ST (r) (v))  : M (unit).

Definition undefined_SCTLR_EL1_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_SCTLR_EL1_type (v : mword 32) : mword 32 := v.

Definition _get_SCTLR_EL1_type_A (v : mword 32) : mword 1 := subrange_vec_dec (v) (1) (1).

Definition _update_SCTLR_EL1_type_A (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (1) (1) (x).

Definition _update_DAIF_type_A (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (8) (8) (x).

Definition _update_EDSCR_type_A (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _update_SCTLR_type_A (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (1) (1) (x).

Definition _update_SPSR_type_A (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (8) (8) (x).

Definition _set_SCTLR_EL1_type_A (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_A (r) (v))
    : M (unit).

Definition _get_DAIF_type_A (v : mword 32) : mword 1 := subrange_vec_dec (v) (8) (8).

Definition _get_EDSCR_type_A (v : mword 32) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _get_SCTLR_type_A (v : mword 32) : mword 1 := subrange_vec_dec (v) (1) (1).

Definition _get_SPSR_type_A (v : mword 32) : mword 1 := subrange_vec_dec (v) (8) (8).

Definition _set_DAIF_type_A (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_DAIF_type_A (r) (v))  : M (unit).

Definition _set_EDSCR_type_A (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_A (r) (v))  : M (unit).

Definition _set_SCTLR_type_A (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_A (r) (v))  : M (unit).

Definition _set_SPSR_type_A (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_A (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_C (v : mword 32) : mword 1 := subrange_vec_dec (v) (2) (2).

Definition _update_SCTLR_EL1_type_C (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (2) (2) (x).

Definition _update_NZCV_type_C (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (29) (29) (x).

Definition _update_SCTLR_type_C (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (2) (2) (x).

Definition _update_SPSR_type_C (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (29) (29) (x).

Definition _set_SCTLR_EL1_type_C (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_C (r) (v))
    : M (unit).

Definition _get_NZCV_type_C (v : mword 32) : mword 1 := subrange_vec_dec (v) (29) (29).

Definition _get_SCTLR_type_C (v : mword 32) : mword 1 := subrange_vec_dec (v) (2) (2).

Definition _get_SPSR_type_C (v : mword 32) : mword 1 := subrange_vec_dec (v) (29) (29).

Definition _set_NZCV_type_C (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_NZCV_type_C (r) (v))  : M (unit).

Definition _set_SCTLR_type_C (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_C (r) (v))  : M (unit).

Definition _set_SPSR_type_C (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_C (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_CP15BEN (v : mword 32) : mword 1 := subrange_vec_dec (v) (5) (5).

Definition _update_SCTLR_EL1_type_CP15BEN (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (5) (5) (x).

Definition _set_SCTLR_EL1_type_CP15BEN (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_CP15BEN (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_DZE (v : mword 32) : mword 1 := subrange_vec_dec (v) (14) (14).

Definition _update_SCTLR_EL1_type_DZE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (14) (14) (x).

Definition _set_SCTLR_EL1_type_DZE (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_DZE (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_E0E (v : mword 32) : mword 1 := subrange_vec_dec (v) (24) (24).

Definition _update_SCTLR_EL1_type_E0E (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (24) (24) (x).

Definition _set_SCTLR_EL1_type_E0E (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_E0E (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_EE (v : mword 32) : mword 1 := subrange_vec_dec (v) (25) (25).

Definition _update_SCTLR_EL1_type_EE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (25) (25) (x).

Definition _update_SCTLR_type_EE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (25) (25) (x).

Definition _set_SCTLR_EL1_type_EE (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_EE (r) (v))
    : M (unit).

Definition _get_SCTLR_type_EE (v : mword 32) : mword 1 := subrange_vec_dec (v) (25) (25).

Definition _set_SCTLR_type_EE (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_EE (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_I (v : mword 32) : mword 1 := subrange_vec_dec (v) (12) (12).

Definition _update_SCTLR_EL1_type_I (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (12) (12) (x).

Definition _update_DAIF_type_I (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _update_SCTLR_type_I (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (12) (12) (x).

Definition _update_SPSR_type_I (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _set_SCTLR_EL1_type_I (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_I (r) (v))
    : M (unit).

Definition _get_DAIF_type_I (v : mword 32) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _get_SCTLR_type_I (v : mword 32) : mword 1 := subrange_vec_dec (v) (12) (12).

Definition _get_SPSR_type_I (v : mword 32) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _set_DAIF_type_I (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_DAIF_type_I (r) (v))  : M (unit).

Definition _set_SCTLR_type_I (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_I (r) (v))  : M (unit).

Definition _set_SPSR_type_I (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_I (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_ITD (v : mword 32) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _update_SCTLR_EL1_type_ITD (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _set_SCTLR_EL1_type_ITD (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_ITD (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_M (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_SCTLR_EL1_type_M (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _update_SCTLR_type_M (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_SCTLR_EL1_type_M (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_M (r) (v))
    : M (unit).

Definition _get_SCTLR_type_M (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _set_SCTLR_type_M (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_M (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_SA (v : mword 32) : mword 1 := subrange_vec_dec (v) (3) (3).

Definition _update_SCTLR_EL1_type_SA (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (3) (3) (x).

Definition _update_SCTLR_type_SA (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (3) (3) (x).

Definition _set_SCTLR_EL1_type_SA (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_SA (r) (v))
    : M (unit).

Definition _get_SCTLR_type_SA (v : mword 32) : mword 1 := subrange_vec_dec (v) (3) (3).

Definition _set_SCTLR_type_SA (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_SA (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_SA0 (v : mword 32) : mword 1 := subrange_vec_dec (v) (4) (4).

Definition _update_SCTLR_EL1_type_SA0 (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (4) (4) (x).

Definition _set_SCTLR_EL1_type_SA0 (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_SA0 (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_SED (v : mword 32) : mword 1 := subrange_vec_dec (v) (8) (8).

Definition _update_SCTLR_EL1_type_SED (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (8) (8) (x).

Definition _set_SCTLR_EL1_type_SED (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_SED (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_UCI (v : mword 32) : mword 1 := subrange_vec_dec (v) (26) (26).

Definition _update_SCTLR_EL1_type_UCI (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (26) (26) (x).

Definition _set_SCTLR_EL1_type_UCI (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_UCI (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_UCT (v : mword 32) : mword 1 := subrange_vec_dec (v) (15) (15).

Definition _update_SCTLR_EL1_type_UCT (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (15) (15) (x).

Definition _set_SCTLR_EL1_type_UCT (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_UCT (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_UMA (v : mword 32) : mword 1 := subrange_vec_dec (v) (9) (9).

Definition _update_SCTLR_EL1_type_UMA (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (9) (9) (x).

Definition _set_SCTLR_EL1_type_UMA (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_UMA (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_WXN (v : mword 32) : mword 1 := subrange_vec_dec (v) (19) (19).

Definition _update_SCTLR_EL1_type_WXN (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (19) (19) (x).

Definition _update_SCTLR_type_WXN (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (19) (19) (x).

Definition _set_SCTLR_EL1_type_WXN (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_WXN (r) (v))
    : M (unit).

Definition _get_SCTLR_type_WXN (v : mword 32) : mword 1 := subrange_vec_dec (v) (19) (19).

Definition _set_SCTLR_type_WXN (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SCTLR_type_WXN (r) (v))  : M (unit).

Definition _get_SCTLR_EL1_type_nTWE (v : mword 32) : mword 1 := subrange_vec_dec (v) (18) (18).

Definition _update_SCTLR_EL1_type_nTWE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (18) (18) (x).

Definition _set_SCTLR_EL1_type_nTWE (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_nTWE (r) (v))
    : M (unit).

Definition _get_SCTLR_EL1_type_nTWI (v : mword 32) : mword 1 := subrange_vec_dec (v) (16) (16).

Definition _update_SCTLR_EL1_type_nTWI (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (16) (16) (x).

Definition _set_SCTLR_EL1_type_nTWI (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_SCTLR_EL1_type_nTWI (r) (v))
    : M (unit).

Definition undefined_SCTLR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_SCTLR_type (v : mword 32) : mword 32 := v.

Definition undefined_TCR_EL1_type '(tt : unit) : M (mword 64) :=
   (undefined_bitvector (64))  : M (mword 64).

Definition Mk_TCR_EL1_type (v : mword 64) : mword 64 := v.

Definition _get_TCR_EL1_type_A1 (v : mword 64) : mword 1 := subrange_vec_dec (v) (22) (22).

Definition _update_TCR_EL1_type_A1 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (22) (22) (x).

Definition _set_TCR_EL1_type_A1 (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_A1 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_AS (v : mword 64) : mword 1 := subrange_vec_dec (v) (36) (36).

Definition _update_TCR_EL1_type_AS (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (36) (36) (x).

Definition _set_TCR_EL1_type_AS (r_ref : register_ref register (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_AS (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_EPD0 (v : mword 64) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _update_TCR_EL1_type_EPD0 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _set_TCR_EL1_type_EPD0 (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_EPD0 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_EPD1 (v : mword 64) : mword 1 := subrange_vec_dec (v) (23) (23).

Definition _update_TCR_EL1_type_EPD1 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (23) (23) (x).

Definition _set_TCR_EL1_type_EPD1 (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_EPD1 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_IPS (v : mword 64) : mword 3 := subrange_vec_dec (v) (34) (32).

Definition _update_TCR_EL1_type_IPS (v : mword 64) (x : mword 3) : mword 64 :=
   update_subrange_vec_dec (v) (34) (32) (x).

Definition _set_TCR_EL1_type_IPS (r_ref : register_ref register (mword 64)) (v : mword 3) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_IPS (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_IRGN0 (v : mword 64) : mword 2 := subrange_vec_dec (v) (9) (8).

Definition _update_TCR_EL1_type_IRGN0 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (9) (8) (x).

Definition _update_TCR_type_IRGN0 (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (9) (8) (x).

Definition _set_TCR_EL1_type_IRGN0 (r_ref : register_ref register (mword 64)) (v : mword 2)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_IRGN0 (r) (v))
    : M (unit).

Definition _get_TCR_type_IRGN0 (v : mword 32) : mword 2 := subrange_vec_dec (v) (9) (8).

Definition _set_TCR_type_IRGN0 (r_ref : register_ref register (mword 32)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_IRGN0 (r) (v))  : M (unit).

Definition _get_TCR_EL1_type_IRGN1 (v : mword 64) : mword 2 := subrange_vec_dec (v) (25) (24).

Definition _update_TCR_EL1_type_IRGN1 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (25) (24) (x).

Definition _set_TCR_EL1_type_IRGN1 (r_ref : register_ref register (mword 64)) (v : mword 2)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_IRGN1 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_ORGN0 (v : mword 64) : mword 2 := subrange_vec_dec (v) (11) (10).

Definition _update_TCR_EL1_type_ORGN0 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (11) (10) (x).

Definition _update_TCR_type_ORGN0 (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (11) (10) (x).

Definition _set_TCR_EL1_type_ORGN0 (r_ref : register_ref register (mword 64)) (v : mword 2)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_ORGN0 (r) (v))
    : M (unit).

Definition _get_TCR_type_ORGN0 (v : mword 32) : mword 2 := subrange_vec_dec (v) (11) (10).

Definition _set_TCR_type_ORGN0 (r_ref : register_ref register (mword 32)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_ORGN0 (r) (v))  : M (unit).

Definition _get_TCR_EL1_type_ORGN1 (v : mword 64) : mword 2 := subrange_vec_dec (v) (27) (26).

Definition _update_TCR_EL1_type_ORGN1 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (27) (26) (x).

Definition _set_TCR_EL1_type_ORGN1 (r_ref : register_ref register (mword 64)) (v : mword 2)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_ORGN1 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_SH0 (v : mword 64) : mword 2 := subrange_vec_dec (v) (13) (12).

Definition _update_TCR_EL1_type_SH0 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (13) (12) (x).

Definition _update_TCR_type_SH0 (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (13) (12) (x).

Definition _set_TCR_EL1_type_SH0 (r_ref : register_ref register (mword 64)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_SH0 (r) (v))
    : M (unit).

Definition _get_TCR_type_SH0 (v : mword 32) : mword 2 := subrange_vec_dec (v) (13) (12).

Definition _set_TCR_type_SH0 (r_ref : register_ref register (mword 32)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_SH0 (r) (v))  : M (unit).

Definition _get_TCR_EL1_type_SH1 (v : mword 64) : mword 2 := subrange_vec_dec (v) (29) (28).

Definition _update_TCR_EL1_type_SH1 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (29) (28) (x).

Definition _set_TCR_EL1_type_SH1 (r_ref : register_ref register (mword 64)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_SH1 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_T0SZ (v : mword 64) : mword 6 := subrange_vec_dec (v) (5) (0).

Definition _update_TCR_EL1_type_T0SZ (v : mword 64) (x : mword 6) : mword 64 :=
   update_subrange_vec_dec (v) (5) (0) (x).

Definition _update_TCR_type_T0SZ (v : mword 32) (x : mword 6) : mword 32 :=
   update_subrange_vec_dec (v) (5) (0) (x).

Definition _set_TCR_EL1_type_T0SZ (r_ref : register_ref register (mword 64)) (v : mword 6)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_T0SZ (r) (v))
    : M (unit).

Definition _get_TCR_type_T0SZ (v : mword 32) : mword 6 := subrange_vec_dec (v) (5) (0).

Definition _set_TCR_type_T0SZ (r_ref : register_ref register (mword 32)) (v : mword 6) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_T0SZ (r) (v))  : M (unit).

Definition _get_TCR_EL1_type_T1SZ (v : mword 64) : mword 6 := subrange_vec_dec (v) (21) (16).

Definition _update_TCR_EL1_type_T1SZ (v : mword 64) (x : mword 6) : mword 64 :=
   update_subrange_vec_dec (v) (21) (16) (x).

Definition _set_TCR_EL1_type_T1SZ (r_ref : register_ref register (mword 64)) (v : mword 6)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_T1SZ (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_TBI0 (v : mword 64) : mword 1 := subrange_vec_dec (v) (37) (37).

Definition _update_TCR_EL1_type_TBI0 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (37) (37) (x).

Definition _set_TCR_EL1_type_TBI0 (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_TBI0 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_TBI1 (v : mword 64) : mword 1 := subrange_vec_dec (v) (38) (38).

Definition _update_TCR_EL1_type_TBI1 (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (38) (38) (x).

Definition _set_TCR_EL1_type_TBI1 (r_ref : register_ref register (mword 64)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_TBI1 (r) (v))
    : M (unit).

Definition _get_TCR_EL1_type_TG0 (v : mword 64) : mword 2 := subrange_vec_dec (v) (15) (14).

Definition _update_TCR_EL1_type_TG0 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (15) (14) (x).

Definition _update_TCR_type_TG0 (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (15) (14) (x).

Definition _set_TCR_EL1_type_TG0 (r_ref : register_ref register (mword 64)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_TG0 (r) (v))
    : M (unit).

Definition _get_TCR_type_TG0 (v : mword 32) : mword 2 := subrange_vec_dec (v) (15) (14).

Definition _set_TCR_type_TG0 (r_ref : register_ref register (mword 32)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_TG0 (r) (v))  : M (unit).

Definition _get_TCR_EL1_type_TG1 (v : mword 64) : mword 2 := subrange_vec_dec (v) (31) (30).

Definition _update_TCR_EL1_type_TG1 (v : mword 64) (x : mword 2) : mword 64 :=
   update_subrange_vec_dec (v) (31) (30) (x).

Definition _set_TCR_EL1_type_TG1 (r_ref : register_ref register (mword 64)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TCR_EL1_type_TG1 (r) (v))
    : M (unit).

Definition undefined_TCR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_TCR_type (v : mword 32) : mword 32 := v.

Definition _get_TCR_type_PS (v : mword 32) : mword 3 := subrange_vec_dec (v) (18) (16).

Definition _update_TCR_type_PS (v : mword 32) (x : mword 3) : mword 32 :=
   update_subrange_vec_dec (v) (18) (16) (x).

Definition _set_TCR_type_PS (r_ref : register_ref register (mword 32)) (v : mword 3) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_PS (r) (v))  : M (unit).

Definition _get_TCR_type_TBI (v : mword 32) : mword 1 := subrange_vec_dec (v) (20) (20).

Definition _update_TCR_type_TBI (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (20) (20) (x).

Definition _set_TCR_type_TBI (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_TCR_type_TBI (r) (v))  : M (unit).

Definition undefined_DBGPRCR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_DBGPRCR_type (v : mword 32) : mword 32 := v.

Definition _get_DBGPRCR_type_CORENPDRQ (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_DBGPRCR_type_CORENPDRQ (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_DBGPRCR_type_CORENPDRQ (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_DBGPRCR_type_CORENPDRQ (r) (v))
    : M (unit).

Definition undefined_OSDLR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_OSDLR_type (v : mword 32) : mword 32 := v.

Definition _get_OSDLR_type_DLK (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_OSDLR_type_DLK (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _update_DBGOSDLR_type_DLK (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_OSDLR_type_DLK (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_OSDLR_type_DLK (r) (v))  : M (unit).

Definition _get_DBGOSDLR_type_DLK (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _set_DBGOSDLR_type_DLK (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_DBGOSDLR_type_DLK (r) (v))
    : M (unit).

Definition undefined_EDSCR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_EDSCR_type (v : mword 32) : mword 32 := v.

Definition _get_EDSCR_type_EL (v : mword 32) : mword 2 := subrange_vec_dec (v) (9) (8).

Definition _update_EDSCR_type_EL (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (9) (8) (x).

Definition _update_CurrentEL_type_EL (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (3) (2) (x).

Definition _set_EDSCR_type_EL (r_ref : register_ref register (mword 32)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_EL (r) (v))  : M (unit).

Definition _get_CurrentEL_type_EL (v : mword 32) : mword 2 := subrange_vec_dec (v) (3) (2).

Definition _set_CurrentEL_type_EL (r_ref : register_ref register (mword 32)) (v : mword 2)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_CurrentEL_type_EL (r) (v))
    : M (unit).

Definition _get_EDSCR_type_HDE (v : mword 32) : mword 1 := subrange_vec_dec (v) (14) (14).

Definition _update_EDSCR_type_HDE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (14) (14) (x).

Definition _set_EDSCR_type_HDE (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_HDE (r) (v))  : M (unit).

Definition _get_EDSCR_type_INTdis (v : mword 32) : mword 2 := subrange_vec_dec (v) (23) (22).

Definition _update_EDSCR_type_INTdis (v : mword 32) (x : mword 2) : mword 32 :=
   update_subrange_vec_dec (v) (23) (22) (x).

Definition _set_EDSCR_type_INTdis (r_ref : register_ref register (mword 32)) (v : mword 2)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_EDSCR_type_INTdis (r) (v))
    : M (unit).

Definition _get_EDSCR_type_ITE (v : mword 32) : mword 1 := subrange_vec_dec (v) (24) (24).

Definition _update_EDSCR_type_ITE (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (24) (24) (x).

Definition _set_EDSCR_type_ITE (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_ITE (r) (v))  : M (unit).

Definition _get_EDSCR_type_ITO (v : mword 32) : mword 1 := subrange_vec_dec (v) (28) (28).

Definition _update_EDSCR_type_ITO (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (28) (28) (x).

Definition _set_EDSCR_type_ITO (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_ITO (r) (v))  : M (unit).

Definition _get_EDSCR_type_MA (v : mword 32) : mword 1 := subrange_vec_dec (v) (20) (20).

Definition _update_EDSCR_type_MA (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (20) (20) (x).

Definition _set_EDSCR_type_MA (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_MA (r) (v))  : M (unit).

Definition _get_EDSCR_type_PipeAdv (v : mword 32) : mword 1 := subrange_vec_dec (v) (25) (25).

Definition _update_EDSCR_type_PipeAdv (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (25) (25) (x).

Definition _set_EDSCR_type_PipeAdv (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_EDSCR_type_PipeAdv (r) (v))
    : M (unit).

Definition _get_EDSCR_type_RXO (v : mword 32) : mword 1 := subrange_vec_dec (v) (27) (27).

Definition _update_EDSCR_type_RXO (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (27) (27) (x).

Definition _set_EDSCR_type_RXO (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_RXO (r) (v))  : M (unit).

Definition _get_EDSCR_type_RXfull (v : mword 32) : mword 1 := subrange_vec_dec (v) (30) (30).

Definition _update_EDSCR_type_RXfull (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (30) (30) (x).

Definition _set_EDSCR_type_RXfull (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_EDSCR_type_RXfull (r) (v))
    : M (unit).

Definition _get_EDSCR_type_SDD (v : mword 32) : mword 1 := subrange_vec_dec (v) (16) (16).

Definition _update_EDSCR_type_SDD (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (16) (16) (x).

Definition _set_EDSCR_type_SDD (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_SDD (r) (v))  : M (unit).

Definition _get_EDSCR_type_STATUS (v : mword 32) : mword 6 := subrange_vec_dec (v) (5) (0).

Definition _update_EDSCR_type_STATUS (v : mword 32) (x : mword 6) : mword 32 :=
   update_subrange_vec_dec (v) (5) (0) (x).

Definition _set_EDSCR_type_STATUS (r_ref : register_ref register (mword 32)) (v : mword 6)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_EDSCR_type_STATUS (r) (v))
    : M (unit).

Definition _get_EDSCR_type_TDA (v : mword 32) : mword 1 := subrange_vec_dec (v) (21) (21).

Definition _update_EDSCR_type_TDA (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (21) (21) (x).

Definition _set_EDSCR_type_TDA (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_TDA (r) (v))  : M (unit).

Definition _get_EDSCR_type_TXU (v : mword 32) : mword 1 := subrange_vec_dec (v) (26) (26).

Definition _update_EDSCR_type_TXU (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (26) (26) (x).

Definition _set_EDSCR_type_TXU (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_EDSCR_type_TXU (r) (v))  : M (unit).

Definition _get_EDSCR_type_TXfull (v : mword 32) : mword 1 := subrange_vec_dec (v) (29) (29).

Definition _update_EDSCR_type_TXfull (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (29) (29) (x).

Definition _set_EDSCR_type_TXfull (r_ref : register_ref register (mword 32)) (v : mword 1)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_EDSCR_type_TXfull (r) (v))
    : M (unit).

Definition undefined_TXIDR_EL0_type '(tt : unit) : M (mword 64) :=
   (undefined_bitvector (64))  : M (mword 64).

Definition Mk_TXIDR_EL0_type (v : mword 64) : mword 64 := v.

Definition _get_TXIDR_EL0_type_DEPTH (v : mword 64) : mword 8 := subrange_vec_dec (v) (7) (0).

Definition _update_TXIDR_EL0_type_DEPTH (v : mword 64) (x : mword 8) : mword 64 :=
   update_subrange_vec_dec (v) (7) (0) (x).

Definition _set_TXIDR_EL0_type_DEPTH (r_ref : register_ref register (mword 64)) (v : mword 8)
: M (unit) :=
   (reg_deref (r_ref)) >>= fun r =>
   write_reg_ref r_ref (_update_TXIDR_EL0_type_DEPTH (r) (v))
    : M (unit).

Definition AArch64_ResetControlRegisters (cold_reset : bool) : unit := tt.

Definition undefined_CurrentEL_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_CurrentEL_type (v : mword 32) : mword 32 := v.

Definition undefined_DAIF_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_DAIF_type (v : mword 32) : mword 32 := v.

Definition _get_DAIF_type_D (v : mword 32) : mword 1 := subrange_vec_dec (v) (9) (9).

Definition _update_DAIF_type_D (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (9) (9) (x).

Definition _set_DAIF_type_D (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_DAIF_type_D (r) (v))  : M (unit).

Definition _get_DAIF_type_F (v : mword 32) : mword 1 := subrange_vec_dec (v) (6) (6).

Definition _update_DAIF_type_F (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (6) (6) (x).

Definition _update_SPSR_type_F (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (6) (6) (x).

Definition _set_DAIF_type_F (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_DAIF_type_F (r) (v))  : M (unit).

Definition _get_SPSR_type_F (v : mword 32) : mword 1 := subrange_vec_dec (v) (6) (6).

Definition _set_SPSR_type_F (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_F (r) (v))  : M (unit).

Definition undefined_NZCV_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_NZCV_type (v : mword 32) : mword 32 := v.

Definition _get_NZCV_type_N (v : mword 32) : mword 1 := subrange_vec_dec (v) (31) (31).

Definition _update_NZCV_type_N (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (31) (31) (x).

Definition _update_SPSR_type_N (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (31) (31) (x).

Definition _set_NZCV_type_N (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_NZCV_type_N (r) (v))  : M (unit).

Definition _get_SPSR_type_N (v : mword 32) : mword 1 := subrange_vec_dec (v) (31) (31).

Definition _set_SPSR_type_N (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_N (r) (v))  : M (unit).

Definition _get_NZCV_type_V (v : mword 32) : mword 1 := subrange_vec_dec (v) (28) (28).

Definition _update_NZCV_type_V (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (28) (28) (x).

Definition _update_SPSR_type_V (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (28) (28) (x).

Definition _set_NZCV_type_V (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_NZCV_type_V (r) (v))  : M (unit).

Definition _get_SPSR_type_V (v : mword 32) : mword 1 := subrange_vec_dec (v) (28) (28).

Definition _set_SPSR_type_V (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_V (r) (v))  : M (unit).

Definition _get_NZCV_type_Z (v : mword 32) : mword 1 := subrange_vec_dec (v) (30) (30).

Definition _update_NZCV_type_Z (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (30) (30) (x).

Definition _update_SPSR_type_Z (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (30) (30) (x).

Definition _set_NZCV_type_Z (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_NZCV_type_Z (r) (v))  : M (unit).

Definition _get_SPSR_type_Z (v : mword 32) : mword 1 := subrange_vec_dec (v) (30) (30).

Definition _set_SPSR_type_Z (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_Z (r) (v))  : M (unit).

Definition undefined_SPSel_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_SPSel_type (v : mword 32) : mword 32 := v.

Definition _get_SPSel_type_SP (v : mword 32) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_SPSel_type_SP (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_SPSel_type_SP (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSel_type_SP (r) (v))  : M (unit).

Definition undefined_SPSR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_SPSR_type (v : mword 32) : mword 32 := v.

Definition _get_SPSR_type_E (v : mword 32) : mword 1 := subrange_vec_dec (v) (9) (9).

Definition _update_SPSR_type_E (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (9) (9) (x).

Definition _set_SPSR_type_E (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_E (r) (v))  : M (unit).

Definition _get_SPSR_type_IL (v : mword 32) : mword 1 := subrange_vec_dec (v) (20) (20).

Definition _update_SPSR_type_IL (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (20) (20) (x).

Definition _set_SPSR_type_IL (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_IL (r) (v))  : M (unit).

Definition _get_SPSR_type_M3_0 (v : mword 32) : mword 4 := subrange_vec_dec (v) (3) (0).

Definition _update_SPSR_type_M3_0 (v : mword 32) (x : mword 4) : mword 32 :=
   update_subrange_vec_dec (v) (3) (0) (x).

Definition _set_SPSR_type_M3_0 (r_ref : register_ref register (mword 32)) (v : mword 4) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_M3_0 (r) (v))  : M (unit).

Definition _get_SPSR_type_M4 (v : mword 32) : mword 1 := subrange_vec_dec (v) (4) (4).

Definition _update_SPSR_type_M4 (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (4) (4) (x).

Definition _set_SPSR_type_M4 (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_M4 (r) (v))  : M (unit).

Definition _get_SPSR_type_SS (v : mword 32) : mword 1 := subrange_vec_dec (v) (21) (21).

Definition _update_SPSR_type_SS (v : mword 32) (x : mword 1) : mword 32 :=
   update_subrange_vec_dec (v) (21) (21) (x).

Definition _set_SPSR_type_SS (r_ref : register_ref register (mword 32)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SPSR_type_SS (r) (v))  : M (unit).

Definition undefined_DBGOSDLR_type '(tt : unit) : M (mword 32) :=
   (undefined_bitvector (32))  : M (mword 32).

Definition Mk_DBGOSDLR_type (v : mword 32) : mword 32 := v.

Definition set_PSTATE_N (v : mword 1) : M (unit) := (_set_NZCV_type_N (NZCV_ref) (v))  : M (unit).

Definition get_PSTATE_N '(tt : unit) : M (mword 1) :=
   ((read_reg NZCV)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_NZCV_type_N (w__0))).

Definition set_PSTATE_Z (v : mword 1) : M (unit) := (_set_NZCV_type_Z (NZCV_ref) (v))  : M (unit).

Definition get_PSTATE_Z '(tt : unit) : M (mword 1) :=
   ((read_reg NZCV)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_NZCV_type_Z (w__0))).

Definition set_PSTATE_C (v : mword 1) : M (unit) := (_set_NZCV_type_C (NZCV_ref) (v))  : M (unit).

Definition get_PSTATE_C '(tt : unit) : M (mword 1) :=
   ((read_reg NZCV)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_NZCV_type_C (w__0))).

Definition set_PSTATE_V (v : mword 1) : M (unit) := (_set_NZCV_type_V (NZCV_ref) (v))  : M (unit).

Definition get_PSTATE_V '(tt : unit) : M (mword 1) :=
   ((read_reg NZCV)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_NZCV_type_V (w__0))).

Definition set_PSTATE_D (v : mword 1) : M (unit) := (_set_DAIF_type_D (DAIF_ref) (v))  : M (unit).

Definition get_PSTATE_D '(tt : unit) : M (mword 1) :=
   ((read_reg DAIF)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_DAIF_type_D (w__0))).

Definition set_PSTATE_A (v : mword 1) : M (unit) := (_set_DAIF_type_A (DAIF_ref) (v))  : M (unit).

Definition get_PSTATE_A '(tt : unit) : M (mword 1) :=
   ((read_reg DAIF)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_DAIF_type_A (w__0))).

Definition set_PSTATE_I (v : mword 1) : M (unit) := (_set_DAIF_type_I (DAIF_ref) (v))  : M (unit).

Definition get_PSTATE_I '(tt : unit) : M (mword 1) :=
   ((read_reg DAIF)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_DAIF_type_I (w__0))).

Definition set_PSTATE_F (v : mword 1) : M (unit) := (_set_DAIF_type_F (DAIF_ref) (v))  : M (unit).

Definition get_PSTATE_F '(tt : unit) : M (mword 1) :=
   ((read_reg DAIF)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_DAIF_type_F (w__0))).

Definition set_PSTATE_EL (v : mword 2) : M (unit) :=
   (_set_CurrentEL_type_EL (CurrentEL_ref) (v))  : M (unit).

Definition get_PSTATE_EL '(tt : unit) : M (mword 2) :=
   ((read_reg CurrentEL)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_CurrentEL_type_EL (w__0))).

Definition set_PSTATE_SP (v : mword 1) : M (unit) :=
   (_set_SPSel_type_SP (SPSel_ref) (v))  : M (unit).

Definition get_PSTATE_SP '(tt : unit) : M (mword 1) :=
   ((read_reg SPSel)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
   returnM ((_get_SPSel_type_SP (w__0))).

Definition wPSTATE_NZCV (b__0 : mword 4) : M (unit) :=
   let n := access_vec_dec (b__0) (3) in
   let z := access_vec_dec (b__0) (2) in
   let c := access_vec_dec (b__0) (1) in
   let v := access_vec_dec (b__0) (0) in
   (set_PSTATE_N ((vec_of_bits [n]  : mword 1))) >>
   (set_PSTATE_Z ((vec_of_bits [z]  : mword 1))) >>
   (set_PSTATE_C ((vec_of_bits [c]  : mword 1))) >>
   (set_PSTATE_V ((vec_of_bits [v]  : mword 1)))
    : M (unit).

Definition wPSTATE_DAIF (b__0 : mword 4) : M (unit) :=
   let d := access_vec_dec (b__0) (3) in
   let a := access_vec_dec (b__0) (2) in
   let i := access_vec_dec (b__0) (1) in
   let f := access_vec_dec (b__0) (0) in
   (set_PSTATE_D ((vec_of_bits [d]  : mword 1))) >>
   (set_PSTATE_A ((vec_of_bits [a]  : mword 1))) >>
   (set_PSTATE_I ((vec_of_bits [i]  : mword 1))) >>
   (set_PSTATE_F ((vec_of_bits [f]  : mword 1)))
    : M (unit).

Definition undefined_AccType '(tt : unit) : AccType := AccType_NORMAL.

Definition undefined_MBReqDomain '(tt : unit) : MBReqDomain := MBReqDomain_Nonshareable.

Definition undefined_MBReqTypes '(tt : unit) : MBReqTypes := MBReqTypes_Reads.

Definition undefined_BranchType '(tt : unit) : BranchType := BranchType_CALL.

Definition undefined_MoveWideOp '(tt : unit) : MoveWideOp := MoveWideOp_N.

Definition M32_User := ('b"10000")  : mword 5.
#[export] Hint Unfold M32_User : sail.
Definition M32_FIQ := ('b"10001")  : mword 5.
#[export] Hint Unfold M32_FIQ : sail.
Definition M32_IRQ := ('b"10010")  : mword 5.
#[export] Hint Unfold M32_IRQ : sail.
Definition M32_Svc := ('b"10011")  : mword 5.
#[export] Hint Unfold M32_Svc : sail.
Definition M32_Monitor := ('b"10110")  : mword 5.
#[export] Hint Unfold M32_Monitor : sail.
Definition M32_Abort := ('b"10111")  : mword 5.
#[export] Hint Unfold M32_Abort : sail.
Definition M32_Hyp := ('b"11010")  : mword 5.
#[export] Hint Unfold M32_Hyp : sail.
Definition M32_Undef := ('b"11011")  : mword 5.
#[export] Hint Unfold M32_Undef : sail.
Definition M32_System := ('b"11111")  : mword 5.
#[export] Hint Unfold M32_System : sail.
Definition EL3 := ('b"11")  : mword 2.
#[export] Hint Unfold EL3 : sail.
Definition EL2 := ('b"10")  : mword 2.
#[export] Hint Unfold EL2 : sail.
Definition EL1 := ('b"01")  : mword 2.
#[export] Hint Unfold EL1 : sail.
Definition EL0 := ('b"00")  : mword 2.
#[export] Hint Unfold EL0 : sail.
Definition undefined_DeviceType '(tt : unit) : DeviceType := DeviceType_GRE.

Definition undefined_Fault '(tt : unit) : Fault := Fault_None.

Definition undefined_FaultRecord '(tt : unit) : M (FaultRecord) :=
   (undefined_bitvector (48)) >>= fun (w__0 : mword 48) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   (undefined_nat (tt)) >>= fun (w__3 : Z) =>
   (undefined_bit (tt)) >>= fun (w__4 : bitU) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__6 : mword 4) =>
   (undefined_bitvector (4)) >>= fun (w__7 : mword 4) =>
   returnM (({| FaultRecord_faulttype := undefined_Fault (tt);
                FaultRecord_acctype := undefined_AccType (tt);
                FaultRecord_ipaddress := w__0;
                FaultRecord_s2fs1walk := w__1;
                FaultRecord_write := w__2;
                FaultRecord_level := w__3;
                FaultRecord_extflag := w__4;
                FaultRecord_secondstage := w__5;
                FaultRecord_domain := w__6;
                FaultRecord_debugmoe := w__7 |})).

Definition undefined_MemAttrHints '(tt : unit) : M (MemAttrHints) :=
   (undefined_bitvector (2)) >>= fun (w__0 : mword 2) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| MemAttrHints_attrs := w__0;
                MemAttrHints_hints := w__1;
                MemAttrHints_transient := w__2 |})).

Definition undefined_MemType '(tt : unit) : MemType := MemType_Normal.

Definition undefined_MemoryAttributes '(tt : unit) : M (MemoryAttributes) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   returnM (({| MemoryAttributes_MA_type := undefined_MemType (tt);
                MemoryAttributes_shareable := w__0 |})).

Definition undefined_FullAddress '(tt : unit) : M (FullAddress) :=
   (undefined_bitvector (64)) >>= fun (w__0 : mword 64) =>
   (undefined_bit (tt)) >>= fun (w__1 : bitU) =>
   returnM (({| FullAddress_physicaladdress := w__0;  FullAddress_NS := w__1 |})).

Definition undefined_AddressDescriptor '(tt : unit) : M (AddressDescriptor) :=
   (undefined_FaultRecord (tt)) >>= fun (w__0 : FaultRecord) =>
   (undefined_MemoryAttributes (tt)) >>= fun (w__1 : MemoryAttributes) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   returnM (({| AddressDescriptor_fault := w__0;
                AddressDescriptor_memattrs := w__1;
                AddressDescriptor_paddress := w__2 |})).

Definition undefined_PrefetchHint '(tt : unit) : PrefetchHint := Prefetch_READ.

Definition undefined_CountOp '(tt : unit) : CountOp := CountOp_CLZ.

Definition undefined_ExtendType '(tt : unit) : ExtendType := ExtendType_SXTB.

Definition undefined_RevOp '(tt : unit) : RevOp := RevOp_RBIT.

Definition undefined_ShiftType '(tt : unit) : ShiftType := ShiftType_LSL.

Definition undefined_LogicalOp '(tt : unit) : LogicalOp := LogicalOp_AND.

Definition undefined_MemOp '(tt : unit) : MemOp := MemOp_LOAD.

Definition undefined_MemBarrierOp '(tt : unit) : MemBarrierOp := MemBarrierOp_DSB.

Definition undefined_SystemHintOp '(tt : unit) : SystemHintOp := SystemHintOp_NOP.

Definition undefined_PSTATEField '(tt : unit) : PSTATEField := PSTATEField_DAIFSet.

Definition undefined_SystemOp '(tt : unit) : SystemOp := Sys_AT.

Definition undefined_DCOp '(tt : unit) : DCOp := IVAC.

Definition undefined_ICOp '(tt : unit) : ICOp := IALLUIS.

Definition Unreachable_no_message {a : Type} '(tt : unit) : M (a) :=
   (error ("Unreachable reached"))  : M (a).

Definition Unreachable_message {a : Type} (message : string) : M (a) := (error (message))  : M (a).

Definition ELUsingAArch32 (el : mword 2) : bool := false.

Definition Halted '(tt : unit) : M (bool) :=
   (or_boolM
      (((read_reg EDSCR)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
       returnM (((eq_vec ((_get_EDSCR_type_STATUS (w__0))) ((('b"000001")  : mword 6)))  : bool)))
      (((read_reg EDSCR)  : M (mword 32)) >>= fun (w__1 : mword 32) =>
       returnM (((eq_vec ((_get_EDSCR_type_STATUS (w__1))) ((('b"000010")  : mword 6)))  : bool)))) >>= fun (w__2 : bool) =>
   returnM ((negb (w__2))).

Definition DoubleLockStatus '(tt : unit) : M (bool) :=
   (if ELUsingAArch32 (EL1) return M (bool) then
      (and_boolM
         (((read_reg DBGOSDLR)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
          returnM (((eq_vec ((_get_DBGOSDLR_type_DLK (w__0))) ((('b"1")  : mword 1)))  : bool)))
         ((and_boolM
             (((read_reg DBGPRCR)  : M (mword 32)) >>= fun (w__1 : mword 32) =>
              returnM (((eq_vec ((_get_DBGPRCR_type_CORENPDRQ (w__1))) ((('b"0")  : mword 1)))
               : bool))) ((Halted (tt)) >>= fun (w__2 : bool) => returnM (((negb (w__2))  : bool))))
          : M (bool)))
       : M (bool)
    else
      (and_boolM
         (((read_reg OSDLR_EL1)  : M (mword 32)) >>= fun (w__5 : mword 32) =>
          returnM (((eq_vec ((_get_OSDLR_type_DLK (w__5))) ((('b"1")  : mword 1)))  : bool)))
         ((and_boolM
             (((read_reg DBGPRCR_EL1)  : M (mword 32)) >>= fun (w__6 : mword 32) =>
              returnM (((eq_vec ((_get_DBGPRCR_type_CORENPDRQ (w__6))) ((('b"0")  : mword 1)))
               : bool))) ((Halted (tt)) >>= fun (w__7 : bool) => returnM (((negb (w__7))  : bool))))
          : M (bool)))
       : M (bool))
    : M (bool).

Definition undefined_signalValue '(tt : unit) : signalValue := LOw.

Definition signalDBGEN '(tt : unit) : M (signalValue) :=
   (not_implemented_extern ("signalDBGEN"))  : M (signalValue).

Definition signelNIDEN '(tt : unit) : M (signalValue) :=
   (not_implemented_extern ("signalNIDEN"))  : M (signalValue).

Definition signalSPIDEN '(tt : unit) : M (signalValue) :=
   (not_implemented_extern ("signalSPIDEN"))  : M (signalValue).

Definition signalDPNIDEN '(tt : unit) : M (signalValue) :=
   (not_implemented_extern ("signalSPNIDEN"))  : M (signalValue).

Definition ExternalInvasiveDebugEnabled '(tt : unit) : M (bool) :=
   (signalDBGEN (tt)) >>= fun (w__0 : signalValue) => returnM ((generic_eq (w__0) (HIGH))).

Definition HaveEL (el : mword 2) : M (bool) :=
   (if orb ((eq_vec (el) (EL1))) ((eq_vec (el) (EL0))) then returnM (true)
    else if eq_vec (el) (EL2) then
      returnM (IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_HaveEL2))
    else if eq_vec (el) (EL3) then
      returnM (IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_HaveEL3))
    else exit tt  : M (bool))
    : M (bool).

Definition HaveAnyAArch32 '(tt : unit) : bool :=
   IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_HaveAnyAArch32).

Definition HighestELUsingAArch32 '(tt : unit) : bool :=
   if negb ((HaveAnyAArch32 (tt))) then false
   else IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32).

Definition SCR_GEN '(tt : unit) : M (mword 32) :=
   (HaveEL (EL3)) >>= fun (w__0 : bool) =>
   assert_exp' w__0 "armV8_common_lib.sail:1082.21-1082.22" >>= fun _ =>
   (if HighestELUsingAArch32 (tt) return M (mword 32) then
      ((read_reg SCR)  : M (mword 32))
       : M (mword 32)
    else ((read_reg SCR_EL3)  : M (mword 32))  : M (mword 32))
    : M (mword 32).

Definition IsSecureBelowEL3 '(tt : unit) : M (bool) :=
   (HaveEL (EL3)) >>= fun (w__0 : bool) =>
   (if w__0 return M (bool) then
      (SCR_GEN (tt)) >>= fun (w__1 : mword 32) =>
      returnM ((eq_vec ((_get_SCRType_NS (w__1))) ((('b"0")  : mword 1))))
    else
      (HaveEL (EL2)) >>= fun (w__2 : bool) =>
      let w__3 : bool :=
        if w__2 then false
        else IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3) in
      returnM (w__3))
    : M (bool).

Definition UsingAArch32 '(tt : unit) : bool := false.

Definition IsSecure '(tt : unit) : M (bool) :=
   (and_boolM ((HaveEL (EL3))  : M (bool))
      ((and_boolM (returnM (((negb ((UsingAArch32 (tt))))  : bool)))
          ((get_PSTATE_EL (tt)) >>= fun (w__1 : mword 2) =>
           returnM (((eq_vec (w__1) (EL3))  : bool))))
       : M (bool))) >>= fun (w__3 : bool) =>
   (if w__3 then returnM (true)
    else
      (and_boolM ((HaveEL (EL3))  : M (bool))
         ((and_boolM (returnM (((UsingAArch32 (tt))  : bool)))
             (((read_reg PSTATE_M)  : M (mword 5)) >>= fun (w__5 : mword 5) =>
              returnM (((eq_vec (w__5) (M32_Monitor))  : bool))))
          : M (bool))) >>= fun (w__7 : bool) =>
      (if w__7 then returnM (true)
       else (IsSecureBelowEL3 (tt))  : M (bool))
       : M (bool))
    : M (bool).

Definition ExternalSecureInvasiveDebugEnabled '(tt : unit) : M (bool) :=
   (and_boolM ((HaveEL (EL3)) >>= fun (w__0 : bool) => returnM (((negb (w__0))  : bool)))
      ((IsSecure (tt)) >>= fun (w__1 : bool) => returnM (((negb (w__1))  : bool)))) >>= fun (w__2 : bool) =>
   (if w__2 then returnM (false)
    else
      (and_boolM ((ExternalInvasiveDebugEnabled (tt))  : M (bool))
         ((signalSPIDEN (tt)) >>= fun (w__4 : signalValue) =>
          returnM (((generic_eq (w__4) (HIGH))  : bool))))
       : M (bool))
    : M (bool).

Definition DCPSInstruction (target_el : mword 2) : M (unit) :=
   (not_implemented ("DCPSInstruction"))  : M (unit).

Definition DRPSInstruction '(tt : unit) : M (unit) :=
   (not_implemented ("DRPSInstruction"))  : M (unit).

Definition DebugHalt_Breakpoint := ('b"000111")  : mword 6.
#[export] Hint Unfold DebugHalt_Breakpoint : sail.
Definition DebugHalt_EDBGRQ := ('b"010011")  : mword 6.
#[export] Hint Unfold DebugHalt_EDBGRQ : sail.
Definition DebugHalt_Step_Normal := ('b"011011")  : mword 6.
#[export] Hint Unfold DebugHalt_Step_Normal : sail.
Definition DebugHalt_Step_Exclusive := ('b"011111")  : mword 6.
#[export] Hint Unfold DebugHalt_Step_Exclusive : sail.
Definition DebugHalt_OSUnlockCatch := ('b"100011")  : mword 6.
#[export] Hint Unfold DebugHalt_OSUnlockCatch : sail.
Definition DebugHalt_ResetCatch := ('b"100111")  : mword 6.
#[export] Hint Unfold DebugHalt_ResetCatch : sail.
Definition DebugHalt_Watchpoint := ('b"101011")  : mword 6.
#[export] Hint Unfold DebugHalt_Watchpoint : sail.
Definition DebugHalt_HaltInstruction := ('b"101111")  : mword 6.
#[export] Hint Unfold DebugHalt_HaltInstruction : sail.
Definition DebugHalt_SoftwareAccess := ('b"110011")  : mword 6.
#[export] Hint Unfold DebugHalt_SoftwareAccess : sail.
Definition DebugHalt_ExceptionCatch := ('b"110111")  : mword 6.
#[export] Hint Unfold DebugHalt_ExceptionCatch : sail.
Definition DebugHalt_Step_NoSyndrome := ('b"111011")  : mword 6.
#[export] Hint Unfold DebugHalt_Step_NoSyndrome : sail.
Definition Halt (reason : mword 6) : M (unit) := (not_implemented ("Halt"))  : M (unit).

Definition HaltingAllowed '(tt : unit) : M (bool) :=
   (or_boolM ((Halted (tt))  : M (bool)) ((DoubleLockStatus (tt))  : M (bool))) >>= fun (w__2 : bool) =>
   (if w__2 then returnM (false)
    else
      (IsSecure (tt)) >>= fun (w__3 : bool) =>
      (if w__3 return M (bool) then (ExternalSecureInvasiveDebugEnabled (tt))  : M (bool)
       else (ExternalInvasiveDebugEnabled (tt))  : M (bool))
       : M (bool))
    : M (bool).

Definition AArch64_UndefinedFault '(tt : unit) : M (unit) :=
   (not_implemented ("AArch64_UndefinedFault"))  : M (unit).

Definition ReservedValue '(tt : unit) : M (unit) := (AArch64_UndefinedFault (tt))  : M (unit).

Definition UnallocatedEncoding '(tt : unit) : M (unit) := (AArch64_UndefinedFault (tt))  : M (unit).

Definition IsFault (addrdesc : AddressDescriptor) : bool :=
   generic_neq (addrdesc.(AddressDescriptor_fault).(FaultRecord_faulttype)) (Fault_None).

Definition Zeros (N : Z) (*N >=? 0*) : mword N :=
   (autocast (T := mword) (replicate_bits ((('b"0")  : mword 1)) ((__id (N)))))  : bits N.

Definition Replicate {M0 : Z} (N : Z) (x : mword M0) (*(N >=? M0) && (M0 >=? 0)*) : M (mword N) :=
   let M' := length_mword (x) in
   assert_exp' (Z.eqb ((ZEuclid.modulo (N) M0)) (0)) "armV8_common_lib.sail:385.23-385.24" >>= fun _ =>
   let result : bits N := Zeros ((__id (N))) in
   let zeros' : bits (N - M0) := Zeros ((Z.sub ((__id (N))) M0)) in
   let result : mword N :=
     let '(loop_i_lower) := M' in
     let '(loop_i_upper) := N in
     (foreach_Z_up loop_i_lower loop_i_upper M' result
       (fun i result =>
         (or_vec (((shiftl (result) M0)  : bits N))
            (((autocast (T := mword) (concat_vec (zeros') (x)))
             : bits N)))
          : bits N)) in
   returnM (result).

Definition SignExtend {M0 : Z} (N : Z) (x : mword M0) (*(N >? M0) && (M0 >=? 1)*) : M (mword N) :=
   let M' := length_mword (x) in
   let h := access_vec_dec (x) ((Z.sub M0 (1))) in
   (Replicate ((Z.sub ((__id (N))) M0)) ((vec_of_bits [h]  : mword 1))) >>= fun (w__0 : mword (N - M0)) =>
   returnM ((autocast (T := mword) (concat_vec ((w__0  : bits (N - M0))) (x)))).

Definition ASR_C {N : Z} (x : mword N) (shift : Z) (*(N >=? 1) && (shift >=? 1)*)
: M ((mword N * bitU)) :=
   (SignExtend ((Z.add ((__id (shift))) N)) (x)) >>= fun (extended_x : bits (shift + N)) =>
   let result : bits N :=
     autocast (T := mword) (subrange_vec_dec (extended_x) ((Z.sub ((Z.add (shift) N)) (1))) (shift)) in
   let carry_out : bitU := access_vec_dec (extended_x) ((Z.sub (shift) (1))) in
   returnM ((result, carry_out)).

Definition ASR {N : Z} (x : mword N) (shift : Z) (*N >=? 1*) (*0 <=? shift*) : M (mword N) :=
   (if Z.eqb (shift) (0) then returnM (x)
    else (ASR_C (x) (shift)) >>= fun '((result', _)) => returnM (result'))
    : M (mword N).

Definition Align' (x : Z) (y : Z) (*0 <=? x*) (*0 <=? y*) : Z := Z.mul (y) ((ZEuclid.div (x) (y))).

Definition UInt {N : Z} (x : mword N) (*N >=? 0*) : Z := uint (x).

Definition Align {N : Z} (x : mword N) (y : Z) (*N >=? 0*) (*0 <=? y*) : mword N :=
   to_bits N ((Align' ((UInt (x))) (y))).

Definition HighestSetBit {N0 : Z} (x : mword N0) (*N0 >=? 0*) : option Z :=
   pure_early_return
     (let N := length_mword (x) in
     (let '(loop_i_lower) := 0 in
     let '(loop_i_upper) := Z.sub N0 (1) in
     (foreach_ZE_down loop_i_upper loop_i_lower 1 tt
       (fun i _ =>
         (if eq_bit ((access_vec_dec (x) (i))) (b1) return sum (option Z) (unit) then
            (inl ((Some (i))  : option Z) : sum (option Z) unit)
             : sum (option Z) (unit)
          else inr (tt))
          : sum (option Z) (unit)))) >>$
     inr (None)).

Definition CountLeadingZeroBits {N : Z} (x : mword N) (*N >=? 0*) : Z :=
   match (HighestSetBit (x)) with
   | None => length_mword (x)
   | Some n => Z.sub ((Z.sub N (1))) (n)
   end.

Definition CountLeadingSignBits {N : Z} (x : mword N) (*N >=? 2*) : Z :=
   CountLeadingZeroBits
     ((xor_vec ((autocast (T := mword) (subrange_vec_dec (x) ((Z.sub N (1))) (1))))
         (((autocast (T := mword) (subrange_vec_dec (x) ((Z.sub N (2))) (0)))
          : bits (N - 1))))).

Definition ZeroExtend {M0 : Z} (N : Z) (x : mword M0) (*(N >=? M0) && (M0 >=? 0)*) : mword N :=
   let M' := length_mword (x) in
   autocast (T := mword) (concat_vec (((Zeros ((Z.sub ((__id (N))) M0)))  : bits (N - M0))) (x)).

Definition Extend {M' : Z} (n : Z) (x : mword M') (_unsigned : bool) (*(1 <=? M') && (M' <? n)*)
: M (mword n) :=
   (if _unsigned then returnM ((ZeroExtend (n) (x)))
    else (SignExtend (n) (x))  : M (mword n))
    : M (mword n).

Definition SInt {N : Z} (x : mword N) (*N >? 0*) : Z := sint (x).

Definition _Int {N : Z} (x : mword N) (_unsigned : bool) (*N >=? 1*) : Z :=
   if _unsigned then UInt (x) else SInt (x).

Definition IsZero {N : Z} (x : mword N) (*N >=? 0*) : bool := eq_vec (x) ((Zeros N)).

Definition IsZeroBit {N : Z} (x : mword N) (*N >=? 0*) : bitU := if IsZero (x) then b1 else b0.

Definition LSL_C {N : Z} (x : mword N) (shift : Z) (*(N >=? 0) && (shift >=? 1)*) : (mword N * bitU) :=
   let extended_x : bits (N + shift) := concat_vec (x) (((Zeros ((__id (shift))))  : bits shift)) in
   let result : bits N := mask N (extended_x) in
   let carry_out : bitU := access_vec_dec (extended_x) N in
   ((result, carry_out)).

Definition LSL {N : Z} (x : mword N) (shift : Z) (*N >=? 0*) (*0 <=? shift*) : mword N :=
   let result : bits N := Zeros N in
   if Z.eqb (shift) (0) then x
   else
     let '((result', _)) := LSL_C (x) (shift) in
     result'.

Definition LSR_C {N : Z} (x : mword N) (shift : Z) (*(N >=? 1) && (shift >=? 1)*) : (mword N * bitU) :=
   let extended_x : bits (N + shift) := ZeroExtend ((Z.add N ((__id (shift))))) (x) in
   let result : bits N :=
     autocast (T := mword) (subrange_vec_dec (extended_x) ((Z.sub ((Z.add N (shift))) (1))) (shift)) in
   let carry_out : bitU := access_vec_dec (extended_x) ((Z.sub (shift) (1))) in
   ((result, carry_out)).

Definition LSR {N : Z} (x : mword N) (shift : Z) (*N >=? 1*) (*0 <=? shift*) : mword N :=
   let result : bits N := Zeros N in
   if Z.eqb (shift) (0) then x
   else
     let '((result', _)) := LSR_C (x) (shift) in
     result'.

Definition Min (a : Z) (b : Z) : Z := if Z.leb (a) (b) then a else b.

Definition uMin (a : Z) (b : Z) (*(a >=? 0) && (b >=? 0)*) : Z := if Z.leb (a) (b) then a else b.

Definition NOT {N : Z} (x : mword N) (*N >=? 0*) : mword N := not_vec (x).

Definition NOT' (x : bitU) : bitU := if eq_bit (x) (b0) then b1 else b0.

Definition Ones (n : Z) (*n >=? 1*) : M (mword n) :=
   (Replicate (n) ((vec_of_bits [b1]  : mword 1)))  : M (mword n).

Definition ROR_C {N0 : Z} (x : mword N0) (shift : Z) (*(N0 >=? 1) && negb (shift =? 0)*)
: (mword N0 * bitU) :=
   let N := length_mword (x) in
   let m := ZEuclid.modulo (shift) N0 in
   let result : bits N0 := or_vec ((LSR (x) (m))) ((LSL (x) ((Z.sub N0 (m))))) in
   let carry_out : bitU := access_vec_dec (result) ((Z.sub N0 (1))) in
   ((result, carry_out)).

Definition ROR {N : Z} (x : mword N) (shift : Z) (*N >=? 1*) (*0 <=? shift*) : mword N :=
   let result : bits N := Zeros N in
   if Z.eqb (shift) (0) then x
   else
     let '((result', _)) := ROR_C (x) (shift) in
     result'.

Definition BitReverse {N0 : Z} (data : mword N0) (*N0 >=? 0*) : mword N0 :=
   let N := length_mword (data) in
   let result : bits N0 := Zeros N0 in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub N0 (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 result
     (fun i result =>
       update_vec_dec (result) ((Z.sub ((Z.sub N0 (i))) (1))) ((access_vec_dec (data) (i))))).

Definition HaveCRCExt '(tt : unit) : bool :=
   IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_HaveCRCExt).

Definition Poly32Mod2 {N0 : Z} (data : mword N0) (poly : mword 32) (*N0 >=? 0*) : M (mword 32) :=
   let result : bits N0 := data in
   let N := length_mword (data) in
   assert_exp' (Z.gtb N0 (32)) "armV8_common_lib.sail:453.15-453.16" >>= fun _ =>
   let data' : bits N0 := data in
   let data' : mword N0 :=
     let '(loop_i_lower) := 32 in
     let '(loop_i_upper) := Z.sub N0 (1) in
     (foreach_Z_down loop_i_upper loop_i_lower 1 data'
       (fun i data' =>
         if eq_bit ((access_vec_dec (data') (i))) (b1) then
           update_subrange_vec_dec (data') ((Z.sub (i) (1))) (0)
             ((xor_vec ((autocast (T := mword) (subrange_vec_dec (data') ((Z.sub (i) (1))) (0))))
                 ((autocast (T := mword) (concat_vec (poly) ((Zeros ((Z.sub (i) (32))))))))))
         else data')) in
   returnM ((subrange_vec_dec (data') (31) (0))).

Definition ClearExclusiveByAddress (paddress : FullAddress) (processorid : Z) (size : Z)
(*0 <=? size*)
: unit :=
   info ("The model does not implement the exclusive monitors explicitly.").

Definition ClearExclusiveLocal (processorid : Z) : unit :=
   info ("The model does not implement the exclusive monitors explicitly.").

Definition ExclusiveMonitorsStatus '(tt : unit) : M (bitU) :=
   let '(_) := (info ("The model does not implement the exclusive monitors explicitly."))  : unit in
   (not_implemented ("ExclusiveMonitorsStatus should not be called"))
    : M (bitU).

Definition IsExclusiveGlobal (paddress : FullAddress) (processorid : Z) (size : Z) (*0 <=? size*)
: bool :=
   let '(_) := (info ("The model does not implement the exclusive monitors explicitly."))  : unit in
   true.

Definition IsExclusiveLocal (paddress : FullAddress) (processorid : Z) (size : Z) (*0 <=? size*)
: bool :=
   let '(_) := (info ("The model does not implement the exclusive monitors explicitly."))  : unit in
   true.

Definition MarkExclusiveGlobal (paddress : FullAddress) (processorid : Z) (size : Z) (*0 <=? size*)
: unit :=
   info ("The model does not implement the exclusive monitors explicitly.").

Definition MarkExclusiveLocal (paddress : FullAddress) (processorid : Z) (size : Z) (*0 <=? size*)
: unit :=
   info ("The model does not implement the exclusive monitors explicitly.").

Definition ProcessorID '(tt : unit) : Z := 0.

Definition AddWithCarry {N : Z} (x : mword N) (y : mword N) (carry_in : bitU) (*N >? 0*)
: (mword N * mword 4) :=
   let unsigned_sum : uinteger :=
     Z.add ((Z.add ((UInt (x))) ((UInt (y))))) ((UInt ((vec_of_bits [carry_in]  : mword 1)))) in
   let signed_sum : integer :=
     Z.add ((Z.add ((SInt (x))) ((SInt (y))))) ((UInt ((vec_of_bits [carry_in]  : mword 1)))) in
   let result : bits N := __GetSlice_int N (unsigned_sum) (0) in
   let n : bitU := access_vec_dec (result) ((Z.sub N (1))) in
   let z : bitU := if IsZero (result) then b1 else b0 in
   let c : bitU := if Z.eqb ((UInt (result))) (unsigned_sum) then b1 else b0 in
   let v : bitU := if Z.eqb ((SInt (result))) (signed_sum) then b1 else b0 in
   ((result, (vec_of_bits [n;z;c;v]  : mword 4))).

Definition S1TranslationRegime '(tt : unit) : M (mword 2) :=
   (get_PSTATE_EL (tt)) >>= fun (w__0 : mword 2) =>
   (if neq_vec (w__0) (EL0) return M (mword 2) then (get_PSTATE_EL (tt))  : M (mword 2)
    else
      (and_boolM ((IsSecure (tt))  : M (bool))
         ((and_boolM ((HaveEL (EL3))  : M (bool)) (returnM (((ELUsingAArch32 (EL3))  : bool))))
          : M (bool))) >>= fun (w__5 : bool) =>
      let w__6 : mword 2 := if w__5 then EL3 else EL1 in
      returnM (w__6))
    : M (mword 2).

Definition SCTLR (regime : mword 2) : M (mword 32) :=
   (if eq_vec (regime) (EL1) return M (mword 32) then
      ((read_reg SCTLR_EL1)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
      returnM ((SCTLR_EL1_type_to_SCTLR_type (w__0)))
    else if eq_vec (regime) (EL2) return M (mword 32) then
      ((read_reg SCTLR_EL2)  : M (mword 32))
       : M (mword 32)
    else if eq_vec (regime) (EL3) return M (mword 32) then
      ((read_reg SCTLR_EL3)  : M (mword 32))
       : M (mword 32)
    else (Unreachable_message ("SCTLR_type unreachable"))  : M (mword 32))
    : M (mword 32).

Definition SCTLR' '(tt : unit) : M (mword 32) :=
   (S1TranslationRegime (tt)) >>= fun (w__0 : mword 2) => (SCTLR (w__0))  : M (mword 32).

Definition BigEndian '(tt : unit) : M (bool) :=
   (if UsingAArch32 (tt) return M (bool) then
      ((read_reg PSTATE_E)  : M (mword 1)) >>= fun (w__0 : mword 1) =>
      returnM ((neq_vec (w__0) ((('b"0")  : mword 1))))
    else
      (get_PSTATE_EL (tt)) >>= fun (w__1 : mword 2) =>
      (if eq_vec (w__1) (EL0) return M (bool) then
         ((read_reg SCTLR_EL1)  : M (mword 32)) >>= fun (w__2 : mword 32) =>
         returnM ((neq_vec ((_get_SCTLR_EL1_type_E0E (w__2))) ((('b"0")  : mword 1))))
       else
         (SCTLR' (tt)) >>= fun (w__3 : mword 32) =>
         returnM ((neq_vec ((_get_SCTLR_type_EE (w__3))) ((('b"0")  : mword 1)))))
       : M (bool))
    : M (bool).

Definition DataMemoryBarrier_NonShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_NonShare, A64_barrier_LD)))))  : M (unit).

Definition DataMemoryBarrier_NonShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_NonShare, A64_barrier_ST)))))  : M (unit).

Definition DataMemoryBarrier_NonShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_NonShare, A64_barrier_all)))))  : M (unit).

Definition DataMemoryBarrier_InnerShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_InnerShare, A64_barrier_LD)))))  : M (unit).

Definition DataMemoryBarrier_InnerShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_InnerShare, A64_barrier_ST)))))  : M (unit).

Definition DataMemoryBarrier_InnerShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_InnerShare, A64_barrier_all)))))  : M (unit).

Definition DataMemoryBarrier_OuterShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_OuterShare, A64_barrier_LD)))))  : M (unit).

Definition DataMemoryBarrier_OuterShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_OuterShare, A64_barrier_ST)))))  : M (unit).

Definition DataMemoryBarrier_OuterShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_OuterShare, A64_barrier_all)))))  : M (unit).

Definition DataMemoryBarrier_FullShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_FullShare, A64_barrier_LD)))))  : M (unit).

Definition DataMemoryBarrier_FullShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_FullShare, A64_barrier_ST)))))  : M (unit).

Definition DataMemoryBarrier_FullShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DMB ((A64_FullShare, A64_barrier_all)))))  : M (unit).

Definition DataMemoryBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   (match (domain, types) with
    | (MBReqDomain_Nonshareable, MBReqTypes_Reads) =>
       (DataMemoryBarrier_NonShReads (tt))  : M (unit)
    | (MBReqDomain_Nonshareable, MBReqTypes_Writes) =>
       (DataMemoryBarrier_NonShWrites (tt))  : M (unit)
    | (MBReqDomain_Nonshareable, MBReqTypes_All) => (DataMemoryBarrier_NonShAll (tt))  : M (unit)
    | (MBReqDomain_InnerShareable, MBReqTypes_Reads) =>
       (DataMemoryBarrier_InnerShReads (tt))  : M (unit)
    | (MBReqDomain_InnerShareable, MBReqTypes_Writes) =>
       (DataMemoryBarrier_InnerShWrites (tt))  : M (unit)
    | (MBReqDomain_InnerShareable, MBReqTypes_All) =>
       (DataMemoryBarrier_InnerShAll (tt))  : M (unit)
    | (MBReqDomain_OuterShareable, MBReqTypes_Reads) =>
       (DataMemoryBarrier_OuterShReads (tt))  : M (unit)
    | (MBReqDomain_OuterShareable, MBReqTypes_Writes) =>
       (DataMemoryBarrier_OuterShWrites (tt))  : M (unit)
    | (MBReqDomain_OuterShareable, MBReqTypes_All) =>
       (DataMemoryBarrier_OuterShAll (tt))  : M (unit)
    | (MBReqDomain_FullSystem, MBReqTypes_Reads) => (DataMemoryBarrier_FullShReads (tt))  : M (unit)
    | (MBReqDomain_FullSystem, MBReqTypes_Writes) =>
       (DataMemoryBarrier_FullShWrites (tt))  : M (unit)
    | (MBReqDomain_FullSystem, MBReqTypes_All) => (DataMemoryBarrier_FullShAll (tt))  : M (unit)
    end)
    : M (unit).

Definition DataSynchronizationBarrier_NonShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_NonShare, A64_barrier_LD)))))  : M (unit).

Definition DataSynchronizationBarrier_NonShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_NonShare, A64_barrier_ST)))))  : M (unit).

Definition DataSynchronizationBarrier_NonShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_NonShare, A64_barrier_all)))))  : M (unit).

Definition DataSynchronizationBarrier_InnerShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_InnerShare, A64_barrier_LD)))))  : M (unit).

Definition DataSynchronizationBarrier_InnerShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_InnerShare, A64_barrier_ST)))))  : M (unit).

Definition DataSynchronizationBarrier_InnerShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_InnerShare, A64_barrier_all)))))  : M (unit).

Definition DataSynchronizationBarrier_OuterShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_OuterShare, A64_barrier_LD)))))  : M (unit).

Definition DataSynchronizationBarrier_OuterShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_OuterShare, A64_barrier_ST)))))  : M (unit).

Definition DataSynchronizationBarrier_OuterShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_OuterShare, A64_barrier_all)))))  : M (unit).

Definition DataSynchronizationBarrier_FullShReads '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_FullShare, A64_barrier_LD)))))  : M (unit).

Definition DataSynchronizationBarrier_FullShWrites '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_FullShare, A64_barrier_ST)))))  : M (unit).

Definition DataSynchronizationBarrier_FullShAll '(tt : unit) : M (unit) :=
   (barrier ((Barrier_DSB ((A64_FullShare, A64_barrier_all)))))  : M (unit).

Definition DataSynchronizationBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   (match (domain, types) with
    | (MBReqDomain_Nonshareable, MBReqTypes_Reads) =>
       (DataSynchronizationBarrier_NonShReads (tt))  : M (unit)
    | (MBReqDomain_Nonshareable, MBReqTypes_Writes) =>
       (DataSynchronizationBarrier_NonShWrites (tt))  : M (unit)
    | (MBReqDomain_Nonshareable, MBReqTypes_All) =>
       (DataSynchronizationBarrier_NonShAll (tt))  : M (unit)
    | (MBReqDomain_InnerShareable, MBReqTypes_Reads) =>
       (DataSynchronizationBarrier_InnerShReads (tt))  : M (unit)
    | (MBReqDomain_InnerShareable, MBReqTypes_Writes) =>
       (DataSynchronizationBarrier_InnerShWrites (tt))  : M (unit)
    | (MBReqDomain_InnerShareable, MBReqTypes_All) =>
       (DataSynchronizationBarrier_InnerShAll (tt))  : M (unit)
    | (MBReqDomain_OuterShareable, MBReqTypes_Reads) =>
       (DataSynchronizationBarrier_OuterShReads (tt))  : M (unit)
    | (MBReqDomain_OuterShareable, MBReqTypes_Writes) =>
       (DataSynchronizationBarrier_OuterShWrites (tt))  : M (unit)
    | (MBReqDomain_OuterShareable, MBReqTypes_All) =>
       (DataSynchronizationBarrier_OuterShAll (tt))  : M (unit)
    | (MBReqDomain_FullSystem, MBReqTypes_Reads) =>
       (DataSynchronizationBarrier_FullShReads (tt))  : M (unit)
    | (MBReqDomain_FullSystem, MBReqTypes_Writes) =>
       (DataSynchronizationBarrier_FullShWrites (tt))  : M (unit)
    | (MBReqDomain_FullSystem, MBReqTypes_All) =>
       (DataSynchronizationBarrier_FullShAll (tt))  : M (unit)
    end)
    : M (unit).

Definition Hint_Prefetch (addr : mword 64) (hint : PrefetchHint) (target : Z) (stream : bool) : unit :=
   tt.

Definition rMem_NORMAL (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (mword (size * 8)) :=
   autocast_m (T := mword) ((read_mem (Read_plain) (64) (address) (size))  : M (mword (8 * size))).

Definition rMem_STREAM (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (mword (size * 8)) :=
   autocast_m (T := mword) ((read_mem (Read_stream) (64) (address) (size))  : M (mword (8 * size))).

Definition rMem_ORDERED (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (mword (size * 8)) :=
   autocast_m (T := mword) ((read_mem (Read_acquire) (64) (address) (size))  : M (mword (8 * size))).

Definition rMem_ATOMIC (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (mword (size * 8)) :=
   autocast_m (T := mword) ((read_mem (Read_exclusive) (64) (address) (size))
    : M (mword (8 * size))).

Definition rMem_ATOMIC_ORDERED (address : mword 64) (size : Z)
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (mword (size * 8)) :=
   autocast_m (T := mword) ((read_mem (Read_exclusive_acquire) (64) (address) (size))
    : M (mword (8 * size))).

Definition undefined_read_buffer_type '(tt : unit) : M (read_buffer_type) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   (undefined_bitvector (64)) >>= fun (w__1 : mword 64) =>
   (undefined_nat (tt)) >>= fun (w__2 : Z) =>
   returnM (({| read_buffer_type_acctype := undefined_AccType (tt);
                read_buffer_type_exclusive := w__0;
                read_buffer_type_address := w__1;
                read_buffer_type_size := w__2 |})).

Definition empty_read_buffer : read_buffer_type :=
{| read_buffer_type_size := 0;
   read_buffer_type_acctype := AccType_NORMAL;
   read_buffer_type_exclusive := false;
   read_buffer_type_address := Zeros (64) |}.
#[export] Hint Unfold empty_read_buffer : sail.
Definition _rMem
(read_buffer : read_buffer_type) (desc : AddressDescriptor) (size : Z) (acctype : AccType)
(exclusive : bool) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (read_buffer_type) :=
   (if Z.eqb (read_buffer.(read_buffer_type_size)) (0) then
      returnM (({| read_buffer_type_acctype := acctype;
                   read_buffer_type_exclusive := exclusive;
                   read_buffer_type_address :=
                     desc.(AddressDescriptor_paddress).(FullAddress_physicaladdress);
                   read_buffer_type_size := size |}))
    else
      assert_exp (generic_eq (read_buffer.(read_buffer_type_acctype)) (acctype)) "armV8_common_lib.sail:727.41-727.42" >>
      assert_exp (Bool.eqb (read_buffer.(read_buffer_type_exclusive)) (exclusive)) "armV8_common_lib.sail:728.45-728.46" >>
      assert_exp (eq_vec
                    (((add_vec_int (read_buffer.(read_buffer_type_address))
                         (read_buffer.(read_buffer_type_size)))
                     : bits 64)) (desc.(AddressDescriptor_paddress).(FullAddress_physicaladdress))) "armV8_common_lib.sail:729.97-729.98" >>
      returnM ((read_buffer
      <|read_buffer_type_size := Z.add (read_buffer.(read_buffer_type_size)) (size)|>)))
    : M (read_buffer_type).

Definition flush_read_buffer (read_buffer : read_buffer_type) (size : Z)
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (mword (size * 8)) :=
   assert_exp (Z.eqb (read_buffer.(read_buffer_type_size)) (size)) "armV8_common_lib.sail:738.33-738.34" >>
   let value : bits (size * 8) := Zeros ((Z.mul ((__id (size))) (8))) in
   (if read_buffer.(read_buffer_type_exclusive) return M (mword (size * 8)) then
      (match read_buffer.(read_buffer_type_acctype) with
       | AccType_ATOMIC =>
          (rMem_ATOMIC (read_buffer.(read_buffer_type_address)) (size))  : M (mword (size * 8))
       | AccType_ORDERED =>
          (rMem_ATOMIC_ORDERED (read_buffer.(read_buffer_type_address)) (size))
           : M (mword (size * 8))
       | _ => (not_implemented ("unimplemented memory access")) >> returnM (value)
       end)
       : M (mword (size * 8))
    else
      (match read_buffer.(read_buffer_type_acctype) with
       | AccType_NORMAL =>
          (rMem_NORMAL (read_buffer.(read_buffer_type_address)) (size))  : M (mword (size * 8))
       | AccType_STREAM =>
          (rMem_STREAM (read_buffer.(read_buffer_type_address)) (size))  : M (mword (size * 8))
       | AccType_UNPRIV =>
          (rMem_NORMAL (read_buffer.(read_buffer_type_address)) (size))  : M (mword (size * 8))
       | AccType_ORDERED =>
          (rMem_ORDERED (read_buffer.(read_buffer_type_address)) (size))  : M (mword (size * 8))
       | AccType_ATOMIC =>
          (error ("Reached AccType_ATOMIC: unreachable when address values are known")) >>
          returnM (value)
       | _ => exit tt >> returnM (value)
       end)
       : M (mword (size * 8))) >>= fun (value : mword (size * 8)) =>
   (BigEndian (tt)) >>= fun (w__6 : bool) =>
   let value : mword (size * 8) := if w__6 then reverse_endianness (value) else value in
   returnM (value).

Definition wMem_Addr_NORMAL (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (write_mem_ea (Write_plain) (64) (address) (size))  : M (unit).

Definition wMem_Addr_ORDERED (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (write_mem_ea (Write_release) (64) (address) (size))  : M (unit).

Definition wMem_Addr_ATOMIC (address : mword 64) (size : Z) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (write_mem_ea (Write_exclusive) (64) (address) (size))  : M (unit).

Definition wMem_Addr_ATOMIC_ORDERED (address : mword 64) (size : Z)
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (write_mem_ea (Write_exclusive_release) (64) (address) (size))  : M (unit).

Definition wMem_Addr (address : mword 64) (size : Z) (acctype : AccType) (excl : bool)
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (match (excl, acctype) with
    | (false, AccType_NORMAL) => (wMem_Addr_NORMAL (address) (size))  : M (unit)
    | (false, AccType_STREAM) => (wMem_Addr_NORMAL (address) (size))  : M (unit)
    | (false, AccType_UNPRIV) => (wMem_Addr_NORMAL (address) (size))  : M (unit)
    | (false, AccType_ORDERED) => (wMem_Addr_ORDERED (address) (size))  : M (unit)
    | (true, AccType_ATOMIC) => (wMem_Addr_ATOMIC (address) (size))  : M (unit)
    | (true, AccType_ORDERED) => (wMem_Addr_ATOMIC_ORDERED (address) (size))  : M (unit)
    | _ => (not_implemented ("unrecognised memory access"))  : M (unit)
    end)
    : M (unit).

Definition wMem_Val_NORMAL (address : mword 64) (size : Z) (value : mword (size * 8))
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (write_mem (Write_plain) (64) (address) (size) ((autocast (T := mword)  value))) >>= fun b =>
   returnM (tt).

Definition wMem_Val_ORDERED (address : mword 64) (size : Z) (value : mword (size * 8))
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (unit) :=
   (write_mem (Write_release) (64) (address) (size) ((autocast (T := mword)  value))) >>= fun b =>
   returnM (tt).

Definition wMem_Val_ATOMIC (address : mword 64) (size : Z) (value : mword (size * 8))
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (bool) :=
   (write_mem (Write_exclusive) (64) (address) (size) ((autocast (T := mword)  value)))  : M (bool).

Definition wMem_Val_ATOMIC_ORDERED (address : mword 64) (size : Z) (value : mword (size * 8))
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (bool) :=
   (write_mem (Write_exclusive_release) (64) (address) (size) ((autocast (T := mword)  value)))
    : M (bool).

Definition undefined_write_buffer_type '(tt : unit) : M (write_buffer_type) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   (undefined_bitvector (64)) >>= fun (w__1 : mword 64) =>
   (undefined_bitvector (128)) >>= fun (w__2 : mword 128) =>
   (undefined_range (0) (16)) >>= fun (w__3 : Z) =>
   returnM (({| write_buffer_type_acctype := undefined_AccType (tt);
                write_buffer_type_exclusive := w__0;
                write_buffer_type_address := w__1;
                write_buffer_type_value := w__2;
                write_buffer_type_size := w__3 |})).

Definition empty_write_buffer : write_buffer_type :=
{| write_buffer_type_size := 0;
   write_buffer_type_acctype := AccType_NORMAL;
   write_buffer_type_exclusive := false;
   write_buffer_type_address := Zeros (64);
   write_buffer_type_value := Zeros (128) |}.
#[export] Hint Unfold empty_write_buffer : sail.
Definition _wMem
(write_buffer : write_buffer_type) (desc : AddressDescriptor) (size : Z) (acctype : AccType)
(exclusive : bool) (value : mword (size * 8)) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (write_buffer_type) :=
   let s := write_buffer.(write_buffer_type_size) in
   (if Z.eqb (s) (0) then
      returnM (({| write_buffer_type_acctype := acctype;
                   write_buffer_type_exclusive := exclusive;
                   write_buffer_type_address :=
                     desc.(AddressDescriptor_paddress).(FullAddress_physicaladdress);
                   write_buffer_type_value := ZeroExtend (128) (value);
                   write_buffer_type_size := size |}))
    else
      assert_exp (generic_eq (write_buffer.(write_buffer_type_acctype)) (acctype)) "armV8_common_lib.sail:836.42-836.43" >>
      assert_exp (Bool.eqb (write_buffer.(write_buffer_type_exclusive)) (exclusive)) "armV8_common_lib.sail:837.46-837.47" >>
      assert_exp (eq_vec (((add_vec_int (write_buffer.(write_buffer_type_address)) (s))  : bits 64))
                    (desc.(AddressDescriptor_paddress).(FullAddress_physicaladdress))) "armV8_common_lib.sail:838.83-838.84" >>
      assert_exp' (Z.leb ((Z.add ((Z.mul (s) (8))) ((Z.mul ((__id (size))) (8))))) (128)) "armV8_common_lib.sail:839.34-839.35" >>= fun _ =>
      returnM ((write_buffer
      <|write_buffer_type_value :=
        ZeroExtend (128)
          ((concat_vec (value)
              ((subrange_vec_dec (write_buffer.(write_buffer_type_value))
                  ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))|>
      <|write_buffer_type_size := Z.add (s) (size)|>)))
    : M (write_buffer_type).

Definition flush_write_buffer (write_buffer : write_buffer_type) : M (unit) :=
   assert_exp (Bool.eqb (write_buffer.(write_buffer_type_exclusive)) (false)) "armV8_common_lib.sail:849.40-849.41" >>
   let s : Z := write_buffer.(write_buffer_type_size) in
   assert_exp' (orb ((Z.eqb (s) (1)))
                  ((orb ((Z.eqb (s) (2)))
                      ((orb ((Z.eqb (s) (4))) ((orb ((Z.eqb (s) (8))) ((Z.eqb (s) (16)))))))))) "armV8_common_lib.sail:851.53-851.54" >>= fun _ =>
   (match write_buffer.(write_buffer_type_acctype) with
    | AccType_NORMAL =>
       (wMem_Val_NORMAL (write_buffer.(write_buffer_type_address)) (s)
          ((autocast (T := mword) (subrange_vec_dec (write_buffer.(write_buffer_type_value))
                                     ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))
        : M (unit)
    | AccType_STREAM =>
       (wMem_Val_NORMAL (write_buffer.(write_buffer_type_address)) (s)
          ((autocast (T := mword) (subrange_vec_dec (write_buffer.(write_buffer_type_value))
                                     ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))
        : M (unit)
    | AccType_UNPRIV =>
       (wMem_Val_NORMAL (write_buffer.(write_buffer_type_address)) (s)
          ((autocast (T := mword) (subrange_vec_dec (write_buffer.(write_buffer_type_value))
                                     ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))
        : M (unit)
    | AccType_ORDERED =>
       (wMem_Val_ORDERED (write_buffer.(write_buffer_type_address)) (s)
          ((autocast (T := mword) (subrange_vec_dec (write_buffer.(write_buffer_type_value))
                                     ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))
        : M (unit)
    | _ => (not_implemented ("unrecognised memory access"))  : M (unit)
    end)
    : M (unit).

Definition flush_write_buffer_exclusive (write_buffer : write_buffer_type) : M (bool) :=
   assert_exp write_buffer.(write_buffer_type_exclusive) "armV8_common_lib.sail:863.31-863.32" >>
   let s := write_buffer.(write_buffer_type_size) in
   assert_exp' (orb ((Z.eqb (s) (1)))
                  ((orb ((Z.eqb (s) (2)))
                      ((orb ((Z.eqb (s) (4))) ((orb ((Z.eqb (s) (8))) ((Z.eqb (s) (16)))))))))) "armV8_common_lib.sail:865.53-865.54" >>= fun _ =>
   (match write_buffer.(write_buffer_type_acctype) with
    | AccType_ATOMIC =>
       (wMem_Val_ATOMIC (write_buffer.(write_buffer_type_address)) (s)
          ((autocast (T := mword) (subrange_vec_dec (write_buffer.(write_buffer_type_value))
                                     ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))
        : M (bool)
    | AccType_ORDERED =>
       (wMem_Val_ATOMIC_ORDERED (write_buffer.(write_buffer_type_address)) (s)
          ((autocast (T := mword) (subrange_vec_dec (write_buffer.(write_buffer_type_value))
                                     ((Z.sub ((Z.mul (s) (8))) (1))) (0)))))
        : M (bool)
    | _ => (not_implemented ("unrecognised memory access")) >> returnM (false)
    end)
    : M (bool).

Definition Hint_Branch (hint : BranchType) : unit :=
   info ("This hint can be used for hardware optimization that has no effect on the model.").

Definition BranchTo {N : Z} (target : mword N) (branch_type : BranchType)
(*member_Z_list N [32; 64]*)
: M (unit) :=
   let target' : bits N := target in
   let '(_) := (Hint_Branch (branch_type))  : unit in
   (if Z.eqb N (32) return M (unit) then
      assert_exp (UsingAArch32 (tt)) "armV8_common_lib.sail:881.26-881.27" >>
      write_reg _PC (ZeroExtend (64) (target))
       : M (unit)
    else
      assert_exp' (andb ((Z.eqb N (64))) ((negb ((UsingAArch32 (tt)))))) "armV8_common_lib.sail:884.53-884.54" >>= fun _ =>
      (get_PSTATE_EL (tt)) >>= fun pstate_el =>
      (if eq_vec (pstate_el) (EL0) return M (mword N) then
         (and_boolM (returnM (((eq_bit ((access_vec_dec (target') (55))) (b1))  : bool)))
            (((read_reg TCR_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
             returnM (((eq_vec ((_get_TCR_EL1_type_TBI1 (w__0))) ((('b"1")  : mword 1)))  : bool)))) >>= fun (w__1 : bool) =>
         let target' : mword N :=
           if w__1 then update_subrange_vec_dec (target') (63) (56) (((Ox"FF")  : mword 8))
           else target' in
         (and_boolM (returnM (((eq_bit ((access_vec_dec (target') (55))) (b0))  : bool)))
            (((read_reg TCR_EL1)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
             returnM (((eq_vec ((_get_TCR_EL1_type_TBI0 (w__2))) ((('b"1")  : mword 1)))  : bool)))) >>= fun (w__3 : bool) =>
         let target' : mword N :=
           if w__3 then update_subrange_vec_dec (target') (63) (56) (((Ox"00")  : mword 8))
           else target' in
         returnM (target')
       else if eq_vec (pstate_el) (EL1) return M (mword N) then
         (and_boolM (returnM (((eq_bit ((access_vec_dec (target') (55))) (b1))  : bool)))
            (((read_reg TCR_EL1)  : M (mword 64)) >>= fun (w__4 : mword 64) =>
             returnM (((eq_vec ((_get_TCR_EL1_type_TBI1 (w__4))) ((('b"1")  : mword 1)))  : bool)))) >>= fun (w__5 : bool) =>
         let target' : mword N :=
           if w__5 then update_subrange_vec_dec (target') (63) (56) (((Ox"FF")  : mword 8))
           else target' in
         (and_boolM (returnM (((eq_bit ((access_vec_dec (target') (55))) (b0))  : bool)))
            (((read_reg TCR_EL1)  : M (mword 64)) >>= fun (w__6 : mword 64) =>
             returnM (((eq_vec ((_get_TCR_EL1_type_TBI0 (w__6))) ((('b"1")  : mword 1)))  : bool)))) >>= fun (w__7 : bool) =>
         let target' : mword N :=
           if w__7 then update_subrange_vec_dec (target') (63) (56) (((Ox"00")  : mword 8))
           else target' in
         returnM (target')
       else if eq_vec (pstate_el) (EL2) return M (mword N) then
         ((read_reg TCR_EL2)  : M (mword 32)) >>= fun (w__8 : mword 32) =>
         let target' : mword N :=
           if eq_vec ((_get_TCR_type_TBI (w__8))) ((('b"1")  : mword 1)) then
             update_subrange_vec_dec (target') (63) (56) (((Ox"00")  : mword 8))
           else target' in
         returnM (target')
       else if eq_vec (pstate_el) (EL3) return M (mword N) then
         ((read_reg TCR_EL3)  : M (mword 32)) >>= fun (w__9 : mword 32) =>
         let target' : mword N :=
           if eq_vec ((_get_TCR_type_TBI (w__9))) ((('b"1")  : mword 1)) then
             update_subrange_vec_dec (target') (63) (56) (((Ox"00")  : mword 8))
           else target' in
         returnM (target')
       else exit tt >> returnM (target')) >>= fun (target' : mword N) =>
      write_reg _PC (autocast (T := mword)  target')
       : M (unit))
    : M (unit).

Definition ResetExternalDebugRegisters (b : bool) : M (unit) :=
   (not_implemented_extern ("ResetExternalDebugRegisters"))  : M (unit).

Definition rPC '(tt : unit) : M (mword 64) := ((read_reg _PC)  : M (mword 64))  : M (mword 64).

Definition ThisInstrAddr (N : Z) (*N >=? 0*) : M (mword N) :=
   assert_exp' (orb ((Z.eqb (N) (64))) ((andb ((Z.eqb (N) (32))) ((UsingAArch32 (tt)))))) "armV8_common_lib.sail:929.45-929.46" >>= fun _ =>
   (rPC (tt)) >>= fun (w__0 : mword 64) => returnM ((mask ((__id (N))) (w__0))).

Definition rSPSR '(tt : unit) : M (mword 32) :=
   (if UsingAArch32 (tt) return M (mword 32) then
      (not_implemented ("rSPSR UsingAArch32"))
       : M (mword 32)
    else
      (get_PSTATE_EL (tt)) >>= fun pstate_el =>
      (if eq_vec (pstate_el) (EL1) return M (mword 32) then
         ((read_reg SPSR_EL1)  : M (mword 32)) >>= fun (w__1 : mword 32) =>
         returnM ((_get_SPSR_type_bits (w__1)))
       else if eq_vec (pstate_el) (EL2) return M (mword 32) then
         ((read_reg SPSR_EL2)  : M (mword 32)) >>= fun (w__2 : mword 32) =>
         returnM ((_get_SPSR_type_bits (w__2)))
       else if eq_vec (pstate_el) (EL3) return M (mword 32) then
         ((read_reg SPSR_EL3)  : M (mword 32)) >>= fun (w__3 : mword 32) =>
         returnM ((_get_SPSR_type_bits (w__3)))
       else (Unreachable_no_message (tt)) >> returnM ((Zeros (32))))
       : M (mword 32))
    : M (mword 32).

Definition ClearEventRegister '(tt : unit) : M (unit) :=
   (not_implemented_extern ("ClearEventRegister"))  : M (unit).

Definition ConditionHolds (_cond : mword 4) : M (bool) :=
   let result : boolean := false in
   let b__0 := subrange_vec_dec (_cond) (3) (1) in
   (if eq_vec (b__0) ((('b"000")  : mword 3)) return M (bool) then
      (get_PSTATE_Z (tt)) >>= fun (w__0 : mword 1) =>
      let result := (eq_vec (w__0) ((('b"1")  : mword 1)))  : bool in
      returnM (result)
    else if eq_vec (b__0) ((('b"001")  : mword 3)) return M (bool) then
      (get_PSTATE_C (tt)) >>= fun (w__1 : mword 1) =>
      let result := (eq_vec (w__1) ((('b"1")  : mword 1)))  : bool in
      returnM (result)
    else if eq_vec (b__0) ((('b"010")  : mword 3)) return M (bool) then
      (get_PSTATE_N (tt)) >>= fun (w__2 : mword 1) =>
      let result := (eq_vec (w__2) ((('b"1")  : mword 1)))  : bool in
      returnM (result)
    else if eq_vec (b__0) ((('b"011")  : mword 3)) return M (bool) then
      (get_PSTATE_V (tt)) >>= fun (w__3 : mword 1) =>
      let result := (eq_vec (w__3) ((('b"1")  : mword 1)))  : bool in
      returnM (result)
    else if eq_vec (b__0) ((('b"100")  : mword 3)) return M (bool) then
      (and_boolM
         ((get_PSTATE_C (tt)) >>= fun (w__4 : mword 1) =>
          returnM (((eq_vec (w__4) ((('b"1")  : mword 1)))  : bool)))
         ((get_PSTATE_Z (tt)) >>= fun (w__5 : mword 1) =>
          returnM (((eq_vec (w__5) ((('b"0")  : mword 1)))  : bool))))
       : M (bool)
    else if eq_vec (b__0) ((('b"101")  : mword 3)) return M (bool) then
      (get_PSTATE_N (tt)) >>= fun (w__7 : mword 1) =>
      (get_PSTATE_V (tt)) >>= fun (w__8 : mword 1) =>
      let result := (eq_vec (w__7) (w__8))  : bool in
      returnM (result)
    else if eq_vec (b__0) ((('b"110")  : mword 3)) return M (bool) then
      (and_boolM
         ((get_PSTATE_N (tt)) >>= fun (w__9 : mword 1) =>
          (get_PSTATE_V (tt)) >>= fun (w__10 : mword 1) =>
          returnM (((eq_vec (w__9) (w__10))  : bool)))
         ((get_PSTATE_Z (tt)) >>= fun (w__11 : mword 1) =>
          returnM (((eq_vec (w__11) ((('b"0")  : mword 1)))  : bool))))
       : M (bool)
    else returnM (true)) >>= fun (result : bool) =>
   let result : bool :=
     if andb ((eq_bit ((access_vec_dec (_cond) (0))) (b1)))
          ((neq_vec (_cond) (((Ox"F")  : mword 4)))) then
       negb (result)
     else result in
   returnM (result).

Definition EventRegisterSet '(tt : unit) : M (unit) :=
   (not_implemented_extern ("EventRegisterSet"))  : M (unit).

Definition EventRegistered '(tt : unit) : M (bool) :=
   (not_implemented_extern ("EventRegistered"))  : M (bool).

Definition HaveAArch32EL (el : mword 2) : M (bool) :=
   (HaveEL (el)) >>= fun (w__0 : bool) =>
   let w__1 : bool :=
     if negb (w__0) then false
     else if negb ((HaveAnyAArch32 (tt))) then false
     else if HighestELUsingAArch32 (tt) then true
     else if eq_vec (el) (EL0) then true
     else IMPLEMENTATION_DEFINED.(IMPLEMENTATION_DEFINED_type_HaveAArch32EL) in
   returnM (w__1).

Definition Hint_Yield '(tt : unit) : unit := tt.

Definition InstructionSynchronizationBarrier '(tt : unit) : M (unit) :=
   (barrier ((Barrier_ISB (tt))))  : M (unit).

Definition InterruptPending '(tt : unit) : M (bool) :=
   (not_implemented_extern ("InterruptPending"))  : M (bool).

Definition SendEvent '(tt : unit) : unit := tt.

Definition WaitForEvent '(tt : unit) : M (unit) :=
   (not_implemented_extern ("WaitForEvent"))  : M (unit).

Definition WaitForInterrupt '(tt : unit) : M (unit) :=
   (not_implemented_extern ("WaitForInterrupt"))  : M (unit).

Definition PAMax '(tt : unit) : M (Z) :=
   let pa_size : Z := 32 in
   ((read_reg ID_AA64MMFR0_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   let b__0 := _get_ID_AA64MMFR0_type_PARange (w__0) in
   (if eq_vec (b__0) (((Ox"0")  : mword 4)) then returnM (32)
    else if eq_vec (b__0) (((Ox"1")  : mword 4)) then returnM (36)
    else if eq_vec (b__0) (((Ox"2")  : mword 4)) then returnM (40)
    else if eq_vec (b__0) (((Ox"3")  : mword 4)) then returnM (42)
    else if eq_vec (b__0) (((Ox"4")  : mword 4)) then returnM (44)
    else if eq_vec (b__0) (((Ox"5")  : mword 4)) then returnM (48)
    else (Unreachable_no_message (tt)) >> returnM (pa_size))
    : M (Z).

Definition AArch64_Abort (vaddress : mword 64) (fault : FaultRecord) : M (unit) :=
   (not_implemented ("AArch64_Abort"))  : M (unit).

Definition AArch64_SPAlignmentFault '(tt : unit) : M (unit) :=
   (not_implemented ("AArch64_SPAlignmentFault"))  : M (unit).

Definition AArch64_SoftwareBreakpoint (immediate : mword 16) : M (unit) :=
   (not_implemented ("AArch64_SoftwareBreakpoint"))  : M (unit).

Definition wX {N : Z} (n : Z) (value : mword N) (*member_Z_list N [8; 16; 32; 64]*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (if neq_int (n) (31) return M (unit) then
      write_reg_ref (vec_access_dec (_R) (n)) (ZeroExtend (64) (value))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition AArch64_ResetGeneralRegisters '(tt : unit) : M (unit) :=
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := 30 in
   (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
     (fun i _ => (wX (i) (((UNKNOWN_BITS (64))  : bits 64)))  : M (unit))).

Definition wV {N : Z} (n : Z) (value : mword N) (*member_Z_list N [8; 16; 32; 64; 128]*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   write_reg_ref (vec_access_dec (_V) (n)) (ZeroExtend (128) (value))  : M (unit).

Definition AArch64_ResetSIMDFPRegisters '(tt : unit) : M (unit) :=
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := 31 in
   (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
     (fun i _ => (wV (i) (((UNKNOWN_BITS (128))  : bits 128)))  : M (unit))).

Definition AArch64_ResetSpecialRegisters '(tt : unit) : M (unit) :=
   write_reg SP_EL0 ((UNKNOWN_BITS (64))  : bits 64) >>
   write_reg SP_EL1 ((UNKNOWN_BITS (64))  : bits 64) >>
   (_set_SPSR_type_bits (SPSR_EL1_ref) (((UNKNOWN_BITS (32))  : bits 32))) >>
   write_reg ELR_EL1 ((UNKNOWN_BITS (64))  : bits 64) >>
   (HaveEL (EL2)) >>= fun (w__0 : bool) =>
   (if w__0 return M (unit) then
      write_reg SP_EL2 ((UNKNOWN_BITS (64))  : bits 64) >>
      (_set_SPSR_type_bits (SPSR_EL2_ref) (((UNKNOWN_BITS (32))  : bits 32))) >>
      write_reg ELR_EL2 ((UNKNOWN_BITS (64))  : bits 64)
       : M (unit)
    else returnM (tt)) >>
   (HaveEL (EL3)) >>= fun (w__1 : bool) =>
   (if w__1 return M (unit) then
      write_reg SP_EL3 ((UNKNOWN_BITS (64))  : bits 64) >>
      (_set_SPSR_type_bits (SPSR_EL3_ref) (((UNKNOWN_BITS (32))  : bits 32))) >>
      write_reg ELR_EL3 ((UNKNOWN_BITS (64))  : bits 64)
       : M (unit)
    else returnM (tt)) >>
   (HaveAArch32EL (EL1)) >>= fun (w__2 : bool) =>
   let '(_) :=
     (if w__2 then
        let SPSR_fiq := (UNKNOWN_BITS (32))  : bits 32 in
        let SPSR_irq := (UNKNOWN_BITS (32))  : bits 32 in
        let SPSR_abt := (UNKNOWN_BITS (32))  : bits 32 in
        let SPSR_und := (UNKNOWN_BITS (32))  : bits 32 in
        tt
      else tt)
      : unit in
   let DLR_EL0 := (UNKNOWN_BITS (64))  : bits 64 in
   let DSPSR_EL0 := (UNKNOWN_BITS (32))  : bits 32 in
   returnM (tt).

Definition AArch64_TakeReset (cold_reset : bool) : M (unit) :=
   assert_exp (negb ((HighestELUsingAArch32 (tt)))) "armV8_A64_lib.sail:62.35-62.36" >>
   write_reg PSTATE_nRW (('b"0")  : mword 1) >>
   (HaveEL (EL3)) >>= fun (w__0 : bool) =>
   (if w__0 return M (unit) then
      (set_PSTATE_EL (EL3)) >> (_set_SCRType_NS (SCR_EL3_ref) ((('b"0")  : mword 1)))  : M (unit)
    else
    (HaveEL (EL2)) >>= fun (w__1 : bool) =>
    if w__1 return M (unit) then (set_PSTATE_EL (EL2))  : M (unit)
    else (set_PSTATE_EL (EL1))  : M (unit)) >>
   let '(_) := (AArch64_ResetControlRegisters (cold_reset))  : unit in
   let PSTATE_SP := 0 in
   (wPSTATE_DAIF (((Ox"F")  : mword 4))) >>
   let PSTATE_SS := 0 in
   let PSTATE_IL := 0 in
   (AArch64_ResetGeneralRegisters (tt)) >>
   (AArch64_ResetSIMDFPRegisters (tt)) >>
   (AArch64_ResetSpecialRegisters (tt)) >>
   (ResetExternalDebugRegisters (cold_reset)) >>
   let rv : bits 64 := Zeros (64) in
   (HaveEL (EL3)) >>= fun (w__2 : bool) =>
   (if w__2 return M (mword 64) then ((read_reg RVBAR_EL3)  : M (mword 64))  : M (mword 64)
    else
      (HaveEL (EL2)) >>= fun (w__4 : bool) =>
      (if w__4 return M (mword 64) then ((read_reg RVBAR_EL2)  : M (mword 64))  : M (mword 64)
       else ((read_reg RVBAR_EL1)  : M (mword 64))  : M (mword 64))
       : M (mword 64)) >>= fun (rv : mword 64) =>
   (and_boolM
      ((PAMax (tt)) >>= fun (w__7 : Z) =>
       returnM (((IsZero ((subrange_vec_dec (rv) (63) (w__7))))  : bool)))
      (returnM (((IsZero ((subrange_vec_dec (rv) (1) (0))))  : bool)))) >>= fun (w__8 : bool) =>
   assert_exp' w__8 "reset vector not correctly aligned" >>= fun _ =>
   (BranchTo (rv) (BranchType_UNKNOWN))
    : M (unit).

Definition AArch64_CallHypervisor (immediate : mword 16) : M (unit) :=
   (not_implemented ("AArch64_CallHypervisor"))  : M (unit).

Definition AArch64_CallSecureMonitor (immediate : mword 16) : M (unit) :=
   (not_implemented ("AArch64_CallSecureMonitor"))  : M (unit).

Definition AArch64_CallSupervisor (immediate : mword 16) : M (unit) :=
   (not_implemented ("AArch64_CallSupervisor"))  : M (unit).

Definition AArch64_CheckForSMCTrap (imm : mword 16) : M (unit) :=
   (and_boolM ((HaveEL (EL2))  : M (bool))
      ((and_boolM ((IsSecure (tt)) >>= fun (w__1 : bool) => returnM (((negb (w__1))  : bool)))
          ((and_boolM
              ((or_boolM
                  ((get_PSTATE_EL (tt)) >>= fun (w__2 : mword 2) =>
                   returnM (((eq_vec (w__2) (EL0))  : bool)))
                  ((get_PSTATE_EL (tt)) >>= fun (w__3 : mword 2) =>
                   returnM (((eq_vec (w__3) (EL1))  : bool))))
               : M (bool))
              (((read_reg HCR_EL2)  : M (mword 64)) >>= fun (w__5 : mword 64) =>
               returnM (((eq_vec ((_get_HCR_type_TSC (w__5))) ((('b"1")  : mword 1)))  : bool))))
           : M (bool)))
       : M (bool))) >>= fun (route_to_el2 : boolean) =>
   (if route_to_el2 return M (unit) then
      (not_implemented ("AArch64_CheckForSMCTrap route_to_el2"))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition AArch64_WFxTrap (target_el : mword 2) (is_wfe : bool) : M (unit) :=
   (not_implemented ("AArch64_WFxTrap"))  : M (unit).

Definition AArch64_CheckForWFxTrap (target_el : mword 2) (is_wfe : bool) : M (unit) :=
   (HaveEL (target_el)) >>= fun (w__0 : bool) =>
   assert_exp' w__0 "armV8_A64_lib.sail:148.28-148.29" >>= fun _ =>
   let trap : boolean := false in
   (if eq_vec (target_el) (EL1) return M (bool) then
      (if is_wfe return M (mword 1) then
         ((read_reg SCTLR_EL1)  : M (mword 32)) >>= fun (w__1 : mword 32) =>
         returnM ((_get_SCTLR_EL1_type_nTWE (w__1)))
       else
         ((read_reg SCTLR_EL1)  : M (mword 32)) >>= fun (w__2 : mword 32) =>
         returnM ((_get_SCTLR_EL1_type_nTWI (w__2)))) >>= fun (w__3 : mword 1) =>
      let trap := (eq_vec (w__3) ((('b"0")  : mword 1)))  : bool in
      returnM (trap)
    else if eq_vec (target_el) (EL2) return M (bool) then
      (if is_wfe return M (mword 1) then
         ((read_reg HCR_EL2)  : M (mword 64)) >>= fun (w__4 : mword 64) =>
         returnM ((_get_HCR_type_TWE (w__4)))
       else
         ((read_reg HCR_EL2)  : M (mword 64)) >>= fun (w__5 : mword 64) =>
         returnM ((_get_HCR_type_TWI (w__5)))) >>= fun (w__6 : mword 1) =>
      let trap := (eq_vec (w__6) ((('b"1")  : mword 1)))  : bool in
      returnM (trap)
    else if eq_vec (target_el) (EL3) return M (bool) then
      (if is_wfe return M (mword 1) then
         ((read_reg SCR_EL3)  : M (mword 32)) >>= fun (w__7 : mword 32) =>
         returnM ((_get_SCRType_TWE (w__7)))
       else
         ((read_reg SCR_EL3)  : M (mword 32)) >>= fun (w__8 : mword 32) =>
         returnM ((_get_SCRType_TWI (w__8)))) >>= fun (w__9 : mword 1) =>
      let trap := (eq_vec (w__9) ((('b"1")  : mword 1)))  : bool in
      returnM (trap)
    else exit tt >> returnM (trap)) >>= fun (trap : bool) =>
   (if trap return M (unit) then (AArch64_WFxTrap (target_el) (is_wfe))  : M (unit)
    else returnM (tt))
    : M (unit).

Definition AArch64_SystemRegisterTrap
(target_el : mword 2) (op0 : mword 2) (op2 : mword 3) (op1 : mword 3) (crn : mword 4) (rt : mword 5)
(crm : mword 4) (dir : bitU)
: M (unit) :=
   (not_implemented ("AArch64_SystemRegisterTrap"))  : M (unit).

Definition AArch64_CreateFaultRecord
(faulttype : Fault) (ipaddress : mword 48) (level : Z) (acctype : AccType) (write : bool)
(extflag : bitU) (secondstage : bool) (s2fs1walk : bool) (*0 <=? level*)
: FaultRecord :=
   {| FaultRecord_faulttype := faulttype;
      FaultRecord_domain := (UNKNOWN_BITS (4))  : bits 4;
      FaultRecord_debugmoe := (UNKNOWN_BITS (4))  : bits 4;
      FaultRecord_ipaddress := ipaddress;
      FaultRecord_level := level;
      FaultRecord_acctype := acctype;
      FaultRecord_write := write;
      FaultRecord_extflag := extflag;
      FaultRecord_secondstage := secondstage;
      FaultRecord_s2fs1walk := s2fs1walk |}.

Definition AArch64_AlignmentFault (acctype : AccType) (iswrite : bool) (secondstage : bool)
: M (FaultRecord) :=
   let ipaddress : bits 48 := UNKNOWN_BITS (48) in
   let level : uinteger := UNKNOWN in
   let extflag : bitU := UNKNOWN_BIT in
   (undefined_bool (tt)) >>= fun (s2fs1walk : boolean) =>
   returnM ((AArch64_CreateFaultRecord (Fault_Alignment) (ipaddress) (level) (acctype) (iswrite)
               (extflag) (secondstage) (s2fs1walk))).

Definition AArch64_IsExclusiveVA (address : mword 64) (processorid : Z) (size : Z) (*0 <=? size*)
: bool :=
   let '(_) := (info ("The model does not implement the exclusive monitors explicitly."))  : unit in
   true.

Definition AArch64_NoFault '(tt : unit) : M (FaultRecord) :=
   let ipaddress : bits 48 := UNKNOWN_BITS (48) in
   let level : uinteger := UNKNOWN in
   let acctype : AccType := AccType_NORMAL in
   (undefined_bool (tt)) >>= fun (iswrite : boolean) =>
   let extflag : bitU := UNKNOWN_BIT in
   let secondstage : boolean := false in
   let s2fs1walk : boolean := false in
   returnM ((AArch64_CreateFaultRecord (Fault_None) (ipaddress) (level) (acctype) (iswrite)
               (extflag) (secondstage) (s2fs1walk))).

Definition AArch64_TranslateAddress
(vaddress : mword 64) (acctype : AccType) (iswrite : bool) (wasaligned : bool) (size : Z)
(*0 <=? size*)
: M (AddressDescriptor) :=
   let '(_) :=
     (info
        ("Translation is not implemented, return same address as the virtual (no fault, normal, shareable, non-secure)."))
      : unit in
   (AArch64_NoFault (tt)) >>= fun (w__0 : FaultRecord) =>
   let result : AddressDescriptor :=
     {| AddressDescriptor_fault := w__0;
        AddressDescriptor_memattrs :=
          {| MemoryAttributes_MA_type := MemType_Normal;
             MemoryAttributes_shareable := true |};
        AddressDescriptor_paddress :=
          {| FullAddress_physicaladdress := vaddress;
             FullAddress_NS := b1 |} |} in
   returnM (result).

Definition AArch64_ExclusiveMonitorsPass (address : mword 64) (size : Z) (*0 <=? size*) : M (bool) :=
   let acctype : AccType := AccType_ATOMIC in
   let iswrite : boolean := true in
   let aligned : boolean := eq_vec (address) ((Align (address) (size))) in
   (if negb (aligned) return M (unit) then
      let secondstage : boolean := false in
      (AArch64_AlignmentFault (acctype) (iswrite) (secondstage)) >>= fun (w__0 : FaultRecord) =>
      (AArch64_Abort (address) (w__0))
       : M (unit)
    else returnM (tt)) >>
   let passed : boolean := AArch64_IsExclusiveVA (address) ((ProcessorID (tt))) (size) in
   (if negb (passed) then returnM (false)
    else
      (AArch64_TranslateAddress (address) (acctype) (iswrite) (aligned) (size)) >>= fun (memaddrdesc : AddressDescriptor) =>
      (if IsFault (memaddrdesc) return M (unit) then
         (AArch64_Abort (address) (memaddrdesc.(AddressDescriptor_fault)))
          : M (unit)
       else returnM (tt)) >>
      let passed : boolean :=
        IsExclusiveLocal (memaddrdesc.(AddressDescriptor_paddress)) ((ProcessorID (tt))) (size) in
      let passed : bool :=
        if passed then
          let '(_) := (ClearExclusiveLocal ((ProcessorID (tt))))  : unit in
          if memaddrdesc.(AddressDescriptor_memattrs).(MemoryAttributes_shareable) then
            IsExclusiveGlobal (memaddrdesc.(AddressDescriptor_paddress)) ((ProcessorID (tt))) (size)
          else passed
        else passed in
      returnM (passed))
    : M (bool).

Definition AArch64_MarkExclusiveVA (address : mword 64) (processorid : Z) (size : Z) (*0 <=? size*)
: unit :=
   info ("The model does not implement the exclusive monitors explicitly.").

Definition AArch64_SetExclusiveMonitors (address : mword 64) (size : Z) (*0 <=? size*) : M (unit) :=
   let acctype : AccType := AccType_ATOMIC in
   let iswrite : boolean := false in
   let aligned : boolean := neq_vec (address) ((Align (address) (size))) in
   (AArch64_TranslateAddress (address) (acctype) (iswrite) (aligned) (size)) >>= fun (memaddrdesc : AddressDescriptor) =>
   returnM ((if IsFault (memaddrdesc) then tt
             else
               let '(_) :=
                 (if memaddrdesc.(AddressDescriptor_memattrs).(MemoryAttributes_shareable) then
                    MarkExclusiveGlobal (memaddrdesc.(AddressDescriptor_paddress))
                      ((ProcessorID (tt))) (size)
                  else tt)
                  : unit in
               let '(_) :=
                 (MarkExclusiveLocal (memaddrdesc.(AddressDescriptor_paddress)) ((ProcessorID (tt)))
                    (size))
                  : unit in
               AArch64_MarkExclusiveVA (address) ((ProcessorID (tt))) (size))).

Definition AArch64_CheckAlignment
(address : mword 64) (size : Z) (acctype : AccType) (iswrite : bool) (*0 <=? size*)
: M (bool) :=
   let aligned : boolean := eq_vec (address) ((Align (address) (size))) in
   (SCTLR' (tt)) >>= fun (w__0 : mword 32) =>
   let b__0 := _get_SCTLR_type_A (w__0) in
   let A := access_vec_dec (b__0) (0) in
   (if andb ((negb (aligned)))
         ((orb ((generic_eq (acctype) (AccType_ATOMIC)))
             ((orb ((generic_eq (acctype) (AccType_ORDERED))) ((eq_bit (A) (b1)))))))
      return
      M (unit) then
      let secondstage := false in
      (AArch64_AlignmentFault (acctype) (iswrite) (secondstage)) >>= fun (w__1 : FaultRecord) =>
      (AArch64_Abort (address) (w__1))
       : M (unit)
    else returnM (tt)) >>
   returnM (aligned).

Definition AArch64_rMemSingle
(read_buffer : read_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(wasaligned : bool) (exclusive : bool) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (read_buffer_type) :=
   assert_exp (eq_vec (address) ((Align (address) (size)))) "armV8_A64_lib.sail:297.40-297.41" >>
   let value : bits (size * 8) := Zeros ((Z.mul ((__id (size))) (8))) in
   let iswrite : boolean := false in
   (AArch64_TranslateAddress (address) (acctype) (iswrite) (wasaligned) (size)) >>= fun (memaddrdesc : AddressDescriptor) =>
   (if IsFault (memaddrdesc) return M (unit) then
      (AArch64_Abort (address) (memaddrdesc.(AddressDescriptor_fault)))
       : M (unit)
    else returnM (tt)) >>
   (_rMem (read_buffer) (memaddrdesc) (size) (acctype) (exclusive))
    : M (read_buffer_type).

Definition AArch64_wMemSingle
(write_buffer : write_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(wasaligned : bool) (exclusive : bool) (value : mword (size * 8))
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (write_buffer_type) :=
   assert_exp (eq_vec (address) ((Align (address) (size)))) "armV8_A64_lib.sail:319.40-319.41" >>
   let iswrite : boolean := true in
   (AArch64_TranslateAddress (address) (acctype) (iswrite) (wasaligned) (size)) >>= fun (memaddrdesc : AddressDescriptor) =>
   (if IsFault (memaddrdesc) return M (unit) then
      (AArch64_Abort (address) (memaddrdesc.(AddressDescriptor_fault)))
       : M (unit)
    else returnM (tt)) >>
   let '(_) :=
     (if memaddrdesc.(AddressDescriptor_memattrs).(MemoryAttributes_shareable) then
        ClearExclusiveByAddress (memaddrdesc.(AddressDescriptor_paddress)) ((ProcessorID (tt)))
          (size)
      else tt)
      : unit in
   (_wMem (write_buffer) (memaddrdesc) (size) (acctype) (exclusive) (value))
    : M (write_buffer_type).

Definition rSP (N : Z) (*member_Z_list N [8; 16; 32; 64]*) : M (mword N) :=
   (get_PSTATE_SP (tt)) >>= fun (w__0 : mword 1) =>
   (if eq_vec (w__0) ((('b"0")  : mword 1)) return M (mword N) then
      ((read_reg SP_EL0)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
      returnM ((mask ((__id (N))) (w__1)))
    else
      (get_PSTATE_EL (tt)) >>= fun pstate_el =>
      (if eq_vec (pstate_el) (EL0) return M (mword N) then
         ((read_reg SP_EL0)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
         returnM ((mask ((__id (N))) (w__2)))
       else if eq_vec (pstate_el) (EL1) return M (mword N) then
         ((read_reg SP_EL1)  : M (mword 64)) >>= fun (w__3 : mword 64) =>
         returnM ((mask ((__id (N))) (w__3)))
       else if eq_vec (pstate_el) (EL2) return M (mword N) then
         ((read_reg SP_EL2)  : M (mword 64)) >>= fun (w__4 : mword 64) =>
         returnM ((mask ((__id (N))) (w__4)))
       else if eq_vec (pstate_el) (EL3) return M (mword N) then
         ((read_reg SP_EL3)  : M (mword 64)) >>= fun (w__5 : mword 64) =>
         returnM ((mask ((__id (N))) (w__5)))
       else exit tt  : M (mword N))
       : M (mword N))
    : M (mword N).

Definition CheckSPAlignment '(tt : unit) : M (unit) :=
   (rSP (64)) >>= fun (sp : bits 64) =>
   let stack_align_check : bool := false in
   (get_PSTATE_EL (tt)) >>= fun (w__0 : mword 2) =>
   (if eq_vec (w__0) (EL0) return M (bool) then
      ((read_reg SCTLR_EL1)  : M (mword 32)) >>= fun (w__1 : mword 32) =>
      let stack_align_check :=
        (neq_vec ((_get_SCTLR_EL1_type_SA0 (w__1))) ((('b"0")  : mword 1)))
         : bool in
      returnM (stack_align_check)
    else
      (SCTLR' (tt)) >>= fun (w__2 : mword 32) =>
      let stack_align_check :=
        (neq_vec ((_get_SCTLR_type_SA (w__2))) ((('b"0")  : mword 1)))
         : bool in
      returnM (stack_align_check)) >>= fun (stack_align_check : bool) =>
   (if andb (stack_align_check) ((neq_vec (sp) ((Align (sp) (16))))) return M (unit) then
      (AArch64_SPAlignmentFault (tt))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition rMem'
(read_buffer : read_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(exclusive : bool) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (read_buffer_type) :=
   let read_buffer' : read_buffer_type := read_buffer in
   let i : uinteger := 0 in
   let iswrite : boolean := false in
   (AArch64_CheckAlignment (address) (size) (acctype) (iswrite)) >>= fun (aligned : boolean) =>
   let atomic : boolean :=
     orb
       ((andb (aligned)
           ((negb
               ((orb ((generic_eq (acctype) (AccType_VEC)))
                   ((generic_eq (acctype) (AccType_VECSTREAM))))))))) ((Z.eqb (size) (1))) in
   (if negb (atomic) return M (read_buffer_type) then
      assert_exp' (negb (exclusive)) "armV8_A64_lib.sail:370.23-370.24" >>= fun _ =>
      assert_exp' (Z.gtb (size) (1)) "armV8_A64_lib.sail:372.19-372.20" >>= fun _ =>
      (AArch64_rMemSingle (read_buffer') (address) (1) (acctype) (aligned) (false)) >>= fun (w__0 : read_buffer_type) =>
      let read_buffer' := w__0  : read_buffer_type in
      (let '(loop_i_lower) := 1 in
      let '(loop_i_upper) := Z.sub (size) (1) in
      (foreach_ZM_up loop_i_lower loop_i_upper 1 read_buffer'
        (fun i read_buffer' =>
          (AArch64_rMemSingle (read_buffer') ((add_vec_int (address) (i))) (1) (acctype) (aligned)
             (false))
           : M (read_buffer_type))))
       : M (read_buffer_type)
    else
      (AArch64_rMemSingle (read_buffer') (address) (size) (acctype) (aligned) (exclusive))
       : M (read_buffer_type))
    : M (read_buffer_type).

Definition rMem (read_buffer : read_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (read_buffer_type) :=
   (rMem' (read_buffer) (address) (size) (acctype) (false))  : M (read_buffer_type).

Definition rMem_exclusive
(read_buffer : read_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(*member_Z_list size [1; 2; 4; 8; 16]*)
: M (read_buffer_type) :=
   (rMem' (read_buffer) (address) (size) (acctype) (true))  : M (read_buffer_type).

Definition wMem'
(write_buffer : write_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(value : mword (size * 8)) (exclusive : bool) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (write_buffer_type) :=
   let write_buffer' : write_buffer_type := write_buffer in
   let value' : bits (size * 8) := value in
   let i : uinteger := 0 in
   let iswrite : boolean := true in
   (BigEndian (tt)) >>= fun (w__0 : bool) =>
   let value' : mword (size * 8) := if w__0 then reverse_endianness (value') else value' in
   (AArch64_CheckAlignment (address) (size) (acctype) (iswrite)) >>= fun (aligned : boolean) =>
   let atomic : boolean :=
     orb
       ((andb (aligned)
           ((negb
               ((orb ((generic_eq (acctype) (AccType_VEC)))
                   ((generic_eq (acctype) (AccType_VECSTREAM))))))))) ((Z.eqb (size) (1))) in
   let exclusiveSuccess : bool := false in
   (if negb (atomic) return M (write_buffer_type) then
      assert_exp' (negb (exclusive)) "armV8_A64_lib.sail:428.23-428.24" >>= fun _ =>
      assert_exp' (Z.gtb (size) (1)) "armV8_A64_lib.sail:431.19-431.20" >>= fun _ =>
      (AArch64_wMemSingle (write_buffer') (address) (1) (acctype) (aligned) (false)
         ((subrange_vec_dec (value') (7) (0)))) >>= fun (w__1 : write_buffer_type) =>
      let write_buffer' := w__1  : write_buffer_type in
      (let '(loop_i_lower) := 1 in
      let '(loop_i_upper) := Z.sub (size) (1) in
      (foreach_ZM_up loop_i_lower loop_i_upper 1 write_buffer'
        (fun i write_buffer' =>
          (AArch64_wMemSingle (write_buffer') ((add_vec_int (address) (i))) (1) (acctype) (aligned)
             (false)
             ((autocast (T := mword) (subrange_vec_dec (value') ((Z.add ((Z.mul (8) (i))) (7)))
                                        ((Z.mul (8) (i)))))))
           : M (write_buffer_type))))
       : M (write_buffer_type)
    else
      (AArch64_wMemSingle (write_buffer') (address) (size) (acctype) (aligned) (exclusive) (value'))
       : M (write_buffer_type))
    : M (write_buffer_type).

Definition wMem
(write_buffer : write_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(value : mword (size * 8)) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (write_buffer_type) :=
   (wMem' (write_buffer) (address) (size) (acctype) (value) (false))  : M (write_buffer_type).

Definition wMem_exclusive
(write_buffer : write_buffer_type) (address : mword 64) (size : Z) (acctype : AccType)
(value : mword (size * 8)) (*member_Z_list size [1; 2; 4; 8; 16]*)
: M (write_buffer_type) :=
   (wMem' (write_buffer) (address) (size) (acctype) (value) (true))  : M (write_buffer_type).

Definition wSP {N : Z} (value : mword N) (*member_Z_list N [32; 64]*) : M (unit) :=
   (get_PSTATE_SP (tt)) >>= fun (w__0 : mword 1) =>
   (if eq_vec (w__0) ((('b"0")  : mword 1)) return M (unit) then
      write_reg SP_EL0 (ZeroExtend (64) (value))
       : M (unit)
    else
    (get_PSTATE_EL (tt)) >>= fun pstate_el =>
    if eq_vec (pstate_el) (EL0) return M (unit) then
      write_reg SP_EL0 (ZeroExtend (64) (value))
       : M (unit)
    else if eq_vec (pstate_el) (EL1) return M (unit) then
      write_reg SP_EL1 (ZeroExtend (64) (value))
       : M (unit)
    else if eq_vec (pstate_el) (EL2) return M (unit) then
      write_reg SP_EL2 (ZeroExtend (64) (value))
       : M (unit)
    else if eq_vec (pstate_el) (EL3) return M (unit) then
      write_reg SP_EL3 (ZeroExtend (64) (value))
       : M (unit)
    else exit tt  : M (unit))
    : M (unit).

Definition rV (N : Z) (n : Z) (*member_Z_list N [8; 16; 32; 64; 128]*) (*(0 <=? n) && (n <=? 31)*)
: M (mword N) :=
   (reg_deref ((vec_access_dec (_V) (n)))) >>= fun (w__0 : mword 128) =>
   returnM ((mask ((__id (N))) (w__0))).

Definition rVpart (N : Z) (n : Z) (part : Z) (*member_Z_list N [8; 16; 32; 64; 128]*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? part) && (part <=? 1)*)
: M (mword N) :=
   (if Z.eqb (part) (0) return M (mword N) then
      (reg_deref ((vec_access_dec (_V) (n)))) >>= fun (w__0 : mword 128) =>
      returnM (((mask ((__id (N))) (w__0))  : bits N))
    else
      assert_exp' (Z.eqb (N) (64)) "armV8_A64_lib.sail:564.18-564.19" >>= fun _ =>
      (reg_deref ((vec_access_dec (_V) (n)))) >>= fun (w__1 : mword 128) =>
      returnM ((autocast (T := mword) ((subrange_vec_dec (w__1) (127) (64))  : bits 64))))
    : M (mword N).

Definition wVpart {N : Z} (n : Z) (part : Z) (value : mword N)
(*member_Z_list N [8; 16; 32; 64; 128]*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? part) && (part <=? 1)*)
: M (unit) :=
   (if Z.eqb (part) (0) return M (unit) then
      write_reg_ref (vec_access_dec (_V) (n)) (ZeroExtend (128) (value))
       : M (unit)
    else
      assert_exp' (Z.eqb N (64)) "armV8_A64_lib.sail:576.30-576.31" >>= fun _ =>
      (reg_deref ((vec_access_dec (_V) (n)))) >>= fun (w__0 : mword 128) =>
      write_reg_ref
        (vec_access_dec (_V) (n))
        (update_subrange_vec_dec (w__0) (127) (64) ((autocast (T := mword)  value)))
       : M (unit))
    : M (unit).

Definition rX (N : Z) (n : Z) (*member_Z_list N [8; 16; 32; 64]*) (*(0 <=? n) && (n <=? 31)*)
: M (mword N) :=
   (if neq_int (n) (31) return M (mword N) then
      (reg_deref ((vec_access_dec (_R) (n)))) >>= fun (w__0 : mword 64) =>
      returnM ((mask ((__id (N))) (w__0)))
    else returnM ((Zeros ((__id (N))))))
    : M (mword N).

Definition rELR (el : mword 2) : M (mword 64) :=
   let r := (Zeros (64))  : bits 64 in
   (if eq_vec (el) (EL1) return M (mword 64) then
      ((read_reg ELR_EL1)  : M (mword 64))
       : M (mword 64)
    else if eq_vec (el) (EL2) return M (mword 64) then
      ((read_reg ELR_EL2)  : M (mword 64))
       : M (mword 64)
    else if eq_vec (el) (EL3) return M (mword 64) then
      ((read_reg ELR_EL3)  : M (mword 64))
       : M (mword 64)
    else (Unreachable_no_message (tt)) >> returnM (r))
    : M (mword 64).

Definition rELR' '(tt : unit) : M (mword 64) :=
   (get_PSTATE_EL (tt)) >>= fun pstate_el =>
   assert_exp (neq_vec (pstate_el) (EL0)) "armV8_A64_lib.sail:616.28-616.29" >>
   (rELR (pstate_el))
    : M (mword 64).

Definition AArch64_CheckUnallocatedSystemAccess
(op0 : mword 2) (op1 : mword 3) (crn : mword 4) (crm : mword 4) (op2 : mword 3) (read : bitU)
: M (bool) :=
   (match (op0, op1, crn, crm, op2, read) with
    | (b__0, b__1, b__2, g__159, b__3, g__160) =>
       (if andb ((eq_vec (b__0) ((('b"00")  : mword 2))))
             ((andb ((eq_vec (b__1) ((('b"000")  : mword 3))))
                 ((andb ((eq_vec (b__2) (((Ox"4")  : mword 4))))
                     ((eq_vec (b__3) ((('b"101")  : mword 3))))))))
          return
          M (bool) then
          (get_PSTATE_EL (tt)) >>= fun (w__0 : mword 2) =>
          returnM ((Z.ltb ((UInt (w__0))) ((UInt (EL1)))))
        else if andb ((eq_vec (b__0) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec (b__1) ((('b"011")  : mword 3))))
                      ((andb ((eq_vec (b__2) (((Ox"4")  : mword 4))))
                          ((eq_vec (b__3) ((('b"110")  : mword 3)))))))) then
          returnM (false)
        else if andb ((eq_vec (b__0) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec (b__1) ((('b"011")  : mword 3))))
                      ((andb ((eq_vec (b__2) (((Ox"4")  : mword 4))))
                          ((eq_vec (b__3) ((('b"111")  : mword 3)))))))) then
          returnM (false)
        else if andb ((eq_vec (b__0) ((('b"11")  : mword 2))))
                  ((andb ((eq_vec (b__1) ((('b"011")  : mword 3))))
                      ((andb ((eq_vec (b__2) (((Ox"4")  : mword 4))))
                          ((andb ((eq_vec (g__159) (((Ox"2")  : mword 4))))
                              ((eq_vec (b__3) ((('b"000")  : mword 3)))))))))) then
          returnM (false)
        else if andb ((eq_vec (b__0) ((('b"11")  : mword 2))))
                  ((andb ((eq_vec (b__1) ((('b"011")  : mword 3))))
                      ((andb ((eq_vec (b__2) (((Ox"4")  : mword 4))))
                          ((andb ((eq_vec (g__159) (((Ox"2")  : mword 4))))
                              ((eq_vec (b__3) ((('b"001")  : mword 3)))))))))) then
          returnM (false)
        else exit tt  : M (bool))
        : M (bool)
    end)
    : M (bool).

Definition CheckSystemAccess
(op0 : mword 2) (op1 : mword 3) (crn : mword 4) (crm : mword 4) (op2 : mword 3) (rt : mword 5)
(read : bitU)
: M (unit) :=
   let unallocated : boolean := false in
   let need_secure : boolean := false in
   let min_EL : bits 2 := ('b"00")  : mword 2 in
   let v__0 := op1 in
   (if eq_vec ((subrange_vec_dec (v__0) (2) (1))) ((('b"00")  : mword 2)) then
      let min_EL : bits 2 := EL1 in
      returnM ((min_EL, need_secure))
    else if eq_vec (v__0) ((('b"010")  : mword 3)) then
      let min_EL : bits 2 := EL1 in
      returnM ((min_EL, need_secure))
    else if eq_vec (v__0) ((('b"011")  : mword 3)) then
      let min_EL : bits 2 := EL0 in
      returnM ((min_EL, need_secure))
    else if eq_vec (v__0) ((('b"100")  : mword 3)) then
      let min_EL : bits 2 := EL2 in
      returnM ((min_EL, need_secure))
    else if eq_vec (v__0) ((('b"101")  : mword 3)) return M ((mword 2 * bool)) then
      (UnallocatedEncoding (tt)) >> returnM ((min_EL, need_secure))
    else
      let '((min_EL, need_secure)) :=
        (if eq_vec (v__0) ((('b"110")  : mword 3)) then
           let min_EL : bits 2 := EL3 in
           (min_EL, need_secure)
         else
           let min_EL : bits 2 := EL1 in
           let need_secure : boolean := true in
           (min_EL, need_secure))
         : (mword 2 * bool) in
      returnM ((min_EL, need_secure))) >>= fun '((min_EL, need_secure)
   : (mword 2 * bool)) =>
   (get_PSTATE_EL (tt)) >>= fun (w__0 : mword 2) =>
   (if Z.ltb ((UInt (w__0))) ((UInt (min_EL))) return M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else
    (and_boolM (returnM ((need_secure  : bool)))
       ((IsSecure (tt)) >>= fun (w__1 : bool) => returnM (((negb (w__1))  : bool)))) >>= fun (w__2 : bool) =>
    if w__2 return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
    else
    (AArch64_CheckUnallocatedSystemAccess (op0) (op1) (crn) (crm) (op2) (read)) >>= fun (w__3 : bool) =>
    if w__3 return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
    else returnM (tt))
    : M (unit).

Definition SysOp_R (op0 : Z) (op1 : Z) (crn : Z) (crm : Z) (op2 : Z) (*0 <=? op0*) (*0 <=? op1*)
(*0 <=? crn*) (*0 <=? crm*) (*0 <=? op2*)
: M (mword 64) :=
   (not_implemented ("SysOp_R")) >> returnM ((Zeros (64))).

Definition SysOp_W (op0 : Z) (op1 : Z) (crn : Z) (crm : Z) (op2 : Z) (_val : mword 64) (*0 <=? op0*)
(*0 <=? op1*) (*0 <=? crn*) (*0 <=? crm*) (*0 <=? op2*)
: M (unit) :=
   (not_implemented ("SysOp_W"))  : M (unit).

Definition System_Get (op0 : Z) (op1 : Z) (crn : Z) (crm : Z) (op2 : Z) (*0 <=? op0*) (*0 <=? op1*)
(*0 <=? crn*) (*0 <=? crm*) (*0 <=? op2*)
: M (mword 64) :=
   (match (op0, op1, crn, crm, op2) with
    | (l__15, l__16, l__17, l__18, l__19) =>
       (if andb
             ((andb
                 ((andb ((andb ((Z.eqb (l__15) (3))) ((Z.eqb (l__16) (3))))) ((Z.eqb (l__17) (4)))))
                 ((Z.eqb (l__18) (2))))) ((Z.eqb (l__19) (0)))
          return
          M (mword 64) then
          ((read_reg NZCV)  : M (mword 32)) >>= fun (w__0 : mword 32) =>
          returnM ((ZeroExtend (64) ((_get_NZCV_type_bits (w__0)))))
        else if andb
                  ((andb
                      ((andb ((andb ((Z.eqb (l__15) (3))) ((Z.eqb (l__16) (3)))))
                          ((Z.eqb (l__17) (4))))) ((Z.eqb (l__18) (2))))) ((Z.eqb (l__19) (1)))
          return
          M (mword 64) then
          ((read_reg DAIF)  : M (mword 32)) >>= fun (w__1 : mword 32) =>
          returnM ((ZeroExtend (64) ((_get_DAIF_type_bits (w__1)))))
        else if andb
                  ((andb
                      ((andb ((andb ((Z.eqb (l__15) (3))) ((Z.eqb (l__16) (3)))))
                          ((Z.eqb (l__17) (13))))) ((Z.eqb (l__18) (0))))) ((Z.eqb (l__19) (2)))
          return
          M (mword 64) then
          ((read_reg TPIDR_EL0)  : M (mword 64))
           : M (mword 64)
        else exit tt  : M (mword 64))
        : M (mword 64)
    end)
    : M (mword 64).

Definition System_Put (op0 : Z) (op1 : Z) (crn : Z) (crm : Z) (op2 : Z) (_val : mword 64)
(*0 <=? op0*) (*0 <=? op1*) (*0 <=? crn*) (*0 <=? crm*) (*0 <=? op2*)
: M (unit) :=
   (match (op0, op1, crn, crm, op2) with
    | (l__0, l__1, l__2, l__3, l__4) =>
       (if andb
             ((andb ((andb ((andb ((Z.eqb (l__0) (3))) ((Z.eqb (l__1) (3))))) ((Z.eqb (l__2) (4)))))
                 ((Z.eqb (l__3) (2))))) ((Z.eqb (l__4) (0)))
          return
          M (unit) then
          (_set_NZCV_type_bits (NZCV_ref) ((subrange_vec_dec (_val) (31) (0))))
           : M (unit)
        else if andb
                  ((andb
                      ((andb ((andb ((Z.eqb (l__0) (3))) ((Z.eqb (l__1) (3))))) ((Z.eqb (l__2) (4)))))
                      ((Z.eqb (l__3) (2))))) ((Z.eqb (l__4) (1)))
          return
          M (unit) then
          (_set_DAIF_type_bits (DAIF_ref) ((subrange_vec_dec (_val) (31) (0))))
           : M (unit)
        else if andb
                  ((andb
                      ((andb ((andb ((Z.eqb (l__0) (3))) ((Z.eqb (l__1) (3)))))
                          ((Z.eqb (l__2) (13))))) ((Z.eqb (l__3) (0))))) ((Z.eqb (l__4) (2)))
          return
          M (unit) then
          write_reg TPIDR_EL0 (subrange_vec_dec (_val) (63) (0))
           : M (unit)
        else exit tt  : M (unit))
        : M (unit)
    end)
    : M (unit).

Definition AArch64_ExceptionReturn (new_pc : mword 64) (spsr : mword 32) : M (unit) :=
   (not_implemented ("AArch64_ExceptionReturn"))  : M (unit).

Definition DecodeRegExtend (op : mword 3) : ExtendType :=
   let b__0 := op in
   if eq_vec (b__0) ((('b"000")  : mword 3)) then ExtendType_UXTB
   else if eq_vec (b__0) ((('b"001")  : mword 3)) then ExtendType_UXTH
   else if eq_vec (b__0) ((('b"010")  : mword 3)) then ExtendType_UXTW
   else if eq_vec (b__0) ((('b"011")  : mword 3)) then ExtendType_UXTX
   else if eq_vec (b__0) ((('b"100")  : mword 3)) then ExtendType_SXTB
   else if eq_vec (b__0) ((('b"101")  : mword 3)) then ExtendType_SXTH
   else if eq_vec (b__0) ((('b"110")  : mword 3)) then ExtendType_SXTW
   else ExtendType_SXTX.

Definition ExtendReg (N : Z) (_reg : Z) (etype : ExtendType) (shift : Z)
(*member_Z_list N [8; 16; 32; 64] && ((shift >=? 0) && (shift <=? 7))*)
(*(0 <=? _reg) && (_reg <=? 31)*)
: M (mword N) :=
   (rX ((__id (N))) (_reg)) >>= fun (_val : bits N) =>
   let _unsigned : boolean := false in
   let len : uinteger := 0 in
   let '((_unsigned, len)) :=
     (match etype with
      | ExtendType_SXTB =>
         let _unsigned : boolean := false in
         let len : uinteger := 8 in
         (_unsigned, len)
      | ExtendType_SXTH =>
         let _unsigned : boolean := false in
         let len : uinteger := 16 in
         (_unsigned, len)
      | ExtendType_SXTW =>
         let _unsigned : boolean := false in
         let len : uinteger := 32 in
         (_unsigned, len)
      | ExtendType_SXTX =>
         let _unsigned : boolean := false in
         let len : uinteger := 64 in
         (_unsigned, len)
      | ExtendType_UXTB =>
         let _unsigned : boolean := true in
         let len : uinteger := 8 in
         (_unsigned, len)
      | ExtendType_UXTH =>
         let _unsigned : boolean := true in
         let len : uinteger := 16 in
         (_unsigned, len)
      | ExtendType_UXTW =>
         let _unsigned : boolean := true in
         let len : uinteger := 32 in
         (_unsigned, len)
      | ExtendType_UXTX =>
         let _unsigned : boolean := true in
         let len : uinteger := 64 in
         (_unsigned, len)
      end)
      : (bool * Z) in
   let len := uMin (len) ((Z.sub ((length_mword (_val))) (shift))) in
   assert_exp' (andb ((Z.geb (len) (1))) ((Z.ltb ((Z.add ((__id (shift))) (len))) ((__id (N)))))) "armV8_A64_lib.sail:804.34-804.35" >>= fun _ =>
   (Extend ((__id (N)))
      ((concat_vec ((subrange_vec_dec (_val) ((Z.sub (len) (1))) (0)))
          (((Zeros ((__id (shift))))
           : bits shift)))) (_unsigned))
    : M (mword N).

Definition DecodeBitMasks
(M' : Z) (immN : bitU) (imms : mword 6) (immr : mword 6) (immediate : bool) (*M' >=? 0*)
: M ((mword M' * mword M')) :=
   let levels : bits 6 := Zeros (6) in
   (match (HighestSetBit ((concat_vec ((vec_of_bits [immN]  : mword 1)) ((not_vec (imms)))))) with
    | None => assert_exp' false "DecodeBitMasks: HighestSetBit returned None" >>= fun _ => exit tt
    | Some c => returnM (c)
    end) >>= fun (len : Z) =>
   (if Z.ltb (len) (1) return M ((mword M' * mword M')) then
      (ReservedValue (tt)) >> exit tt  : M ((mword M' * mword M'))
    else
      assert_exp' (Z.geb (M') ((lsl' (1) (len)))) "armV8_A64_lib.sail:828.25-828.26" >>= fun _ =>
      let levels : bits 6 := ZeroExtend (6) ((replicate_bits ((('b"1")  : mword 1)) (len))) in
      (if andb (immediate) ((eq_vec ((and_vec (imms) (levels))) (levels))) return M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      let S' := UInt ((and_vec (imms) (levels))) in
      let R' := UInt ((and_vec (immr) (levels))) in
      let diff : bits 6 := to_bits (6) ((Z.sub (S') (R'))) in
      let '(esize) := lsl' (1) (len) in
      let d := UInt ((subrange_vec_dec (diff) ((Z.sub (len) (1))) (0))) in
      assert_exp' (Z.geb (esize) ((Z.add (S') (1)))) "armV8_A64_lib.sail:844.21-844.22" >>= fun _ =>
      (Ones ((Z.add (S') (1)))) >>= fun w__2 =>
      let welem : bits esize := ZeroExtend ((__id (esize))) (w__2) in
      (Ones ((Z.add (d) (1)))) >>= fun w__3 =>
      let telem : bits esize := ZeroExtend ((length_mword (welem))) (w__3) in
      (Replicate (M') ((ROR (welem) (R')))) >>= fun wmask =>
      (Replicate (M') (telem)) >>= fun tmask => returnM ((wmask, tmask)))
    : M ((mword M' * mword M')).

Definition DecodeShift (op : mword 2) : ShiftType :=
   let b__0 := op in
   if eq_vec (b__0) ((('b"00")  : mword 2)) then ShiftType_LSL
   else if eq_vec (b__0) ((('b"01")  : mword 2)) then ShiftType_LSR
   else if eq_vec (b__0) ((('b"10")  : mword 2)) then ShiftType_ASR
   else ShiftType_ROR.

Definition ShiftReg (N : Z) (_reg : Z) (stype : ShiftType) (amount : Z)
(*member_Z_list N [8; 16; 32; 64]*) (*(0 <=? _reg) && (_reg <=? 31)*) (*0 <=? amount*)
: M (mword N) :=
   (rX ((__id (N))) (_reg)) >>= fun (result : bits N) =>
   (match stype with
    | ShiftType_LSL =>
       let result : bits N := LSL (result) (amount) in
       returnM (result)
    | ShiftType_LSR =>
       let result : bits N := LSR (result) (amount) in
       returnM (result)
    | ShiftType_ASR => (ASR (result) (amount))  : M (mword N)
    | ShiftType_ROR =>
       let result : bits N := ROR (result) (amount) in
       returnM (result)
    end)
    : M (mword N).

Definition Prefetch (address : mword 64) (prfop : mword 5) : unit :=
   let hint : PrefetchHint := Prefetch_READ in
   let target : uinteger := 0 in
   let stream : boolean := false in
   let returnv : bool := false in
   let b__0 := subrange_vec_dec (prfop) (4) (3) in
   let '((hint, returnv)) :=
     (if eq_vec (b__0) ((('b"00")  : mword 2)) then
        let hint : PrefetchHint := Prefetch_READ in
        (hint, returnv)
      else
        let '((hint, returnv)) :=
          (if eq_vec (b__0) ((('b"01")  : mword 2)) then
             let hint : PrefetchHint := Prefetch_EXEC in
             (hint, returnv)
           else
             let '((hint, returnv)) :=
               (if eq_vec (b__0) ((('b"10")  : mword 2)) then
                  let hint : PrefetchHint := Prefetch_WRITE in
                  (hint, returnv)
                else
                  let returnv : bool := true in
                  (hint, returnv))
                : (PrefetchHint * bool) in
             (hint, returnv))
           : (PrefetchHint * bool) in
        (hint, returnv))
      : (PrefetchHint * bool) in
   let '(_) :=
     (if negb (returnv) then
        let target : uinteger := UInt ((subrange_vec_dec (prfop) (2) (1))) in
        let stream : boolean := generic_neq ((access_vec_dec (prfop) (0))) (b0) in
        Hint_Prefetch (address) (hint) (target) (stream)
      else tt)
      : unit in
   tt.

Definition SysOp (op1 : mword 3) (CRn : mword 4) (CRm : mword 4) (op2 : mword 3) : SystemOp :=
   let v__3 := concat_vec (op1) ((concat_vec (CRn) ((concat_vec (CRm) (op2))))) in
   if eq_vec (v__3) ((('b"00001111000000")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"10001111000000")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"11001111000000")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"00001111000001")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"10001111000001")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"11001111000001")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"00001111000010")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"00001111000011")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"10001111000100")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"10001111000101")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"10001111000110")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"10001111000111")  : mword 14)) then Sys_AT
   else if eq_vec (v__3) ((('b"01101110100001")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"00001110110001")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"00001110110010")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"01101111010001")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"00001111010010")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"01101111011001")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"01101111110001")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"00001111110010")  : mword 14)) then Sys_DC
   else if eq_vec (v__3) ((('b"00001110001000")  : mword 14)) then Sys_IC
   else if eq_vec (v__3) ((('b"00001110101000")  : mword 14)) then Sys_IC
   else if eq_vec (v__3) ((('b"01101110101001")  : mword 14)) then Sys_IC
   else if eq_vec (v__3) ((('b"10010000000001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000000101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000011000")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000011000")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"11010000011000")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000011001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000011001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"11010000011001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000011010")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000011011")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000011100")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000011101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000011101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"11010000011101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000011110")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000011111")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000100001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000100101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000111000")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000111000")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"11010000111000")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000111001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000111001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"11010000111001")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000111010")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000111011")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000111100")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000111101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000111101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"11010000111101")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"10010000111110")  : mword 14)) then Sys_TLBI
   else if eq_vec (v__3) ((('b"00010000111111")  : mword 14)) then Sys_TLBI
   else Sys_SYS.

Definition decodeTMStart (Rt : mword 5) : option ast :=
   let t : reg_index := UInt_reg (Rt) in
   Some ((TMStart (t))).

Definition decodeTMCommit '(tt : unit) : option ast := Some ((TMCommit (tt))).

Definition decodeTMTest '(tt : unit) : option ast := Some ((TMTest (tt))).

Definition decodeTMAbort (v__278 : mword 6) : M (option ast) :=
   let R' := access_vec_dec (v__278) (5) in
   let imm5 : bits 5 := subrange_vec_dec (v__278) (4) (0) in
   (cast_bit_bool (R')) >>= fun (w__0 : bool) => returnM ((Some ((TMAbort ((w__0, imm5)))))).

Definition decodeCompareBranchImmediate (v__280 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__280) (30) (25))) ((('b"011010")  : mword 6))
      return
      M (option ast) then
      let sf := access_vec_dec (v__280) (31) in
      let op := access_vec_dec (v__280) (24) in
      let imm19 : bits 19 := subrange_vec_dec (v__280) (23) (5) in
      let Rt : bits 5 := subrange_vec_dec (v__280) (4) (0) in
      let t : reg_index := UInt_reg (Rt) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let iszero : boolean := eq_bit (op) (b0) in
      (SignExtend (64) ((concat_vec (imm19) ((('b"00")  : mword 2))))) >>= fun (offset : bits 64) =>
      returnM ((Some ((CompareAndBranch ((t, datasize, iszero, offset))))))
    else assert_exp' false "Pattern match failure at armV8.sail:185.0-192.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeConditionalBranchImmediate (v__284 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__284) (31) (24))) (((Ox"54")  : mword 8))))
         ((eq_vec ((subrange_vec_dec (v__284) (4) (4))) ((('b"0")  : mword 1))))
      return
      M (option ast) then
      let imm19 : bits 19 := subrange_vec_dec (v__284) (23) (5) in
      let _cond : bits 4 := subrange_vec_dec (v__284) (3) (0) in
      (SignExtend (64) ((concat_vec (imm19) ((('b"00")  : mword 2))))) >>= fun (offset : bits 64) =>
      let condition : bits 4 := _cond in
      returnM ((Some ((BranchConditional ((offset, condition))))))
    else assert_exp' false "Pattern match failure at armV8.sail:202.0-207.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeExceptionGeneration (v__288 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__288) (31) (21))) ((('b"11010100000")  : mword 11))))
         ((eq_vec ((subrange_vec_dec (v__288) (4) (0))) ((('b"00001")  : mword 5)))) then
      let imm16 : bits 16 := subrange_vec_dec (v__288) (20) (5) in
      let imm : bits 16 := imm16 in
      returnM ((Some ((GenerateExceptionEL1 (imm)))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__288) (31) (21))) ((('b"11010100000")  : mword 11))))
              ((eq_vec ((subrange_vec_dec (v__288) (4) (0))) ((('b"00010")  : mword 5)))) then
      let imm16 : bits 16 := subrange_vec_dec (v__288) (20) (5) in
      let imm : bits 16 := imm16 in
      returnM ((Some ((GenerateExceptionEL2 (imm)))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__288) (31) (21))) ((('b"11010100000")  : mword 11))))
              ((eq_vec ((subrange_vec_dec (v__288) (4) (0))) ((('b"00011")  : mword 5)))) then
      let imm16 : bits 16 := subrange_vec_dec (v__288) (20) (5) in
      let imm : bits 16 := imm16 in
      returnM ((Some ((GenerateExceptionEL3 (imm)))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__288) (31) (21))) ((('b"11010100001")  : mword 11))))
              ((eq_vec ((subrange_vec_dec (v__288) (4) (0))) ((('b"00000")  : mword 5)))) then
      let imm16 : bits 16 := subrange_vec_dec (v__288) (20) (5) in
      let comment : bits 16 := imm16 in
      returnM ((Some ((DebugBreakpoint (comment)))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__288) (31) (21))) ((('b"11010100010")  : mword 11))))
              ((eq_vec ((subrange_vec_dec (v__288) (4) (0))) ((('b"00000")  : mword 5)))) then
      returnM ((Some ((ExternalDebugBreakpoint (tt)))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__288) (31) (21))) ((('b"11010100101")  : mword 11))))
              ((eq_vec ((subrange_vec_dec (v__288) (4) (2))) ((('b"000")  : mword 3))))
      return
      M (option ast) then
      let LL : bits 2 := subrange_vec_dec (v__288) (1) (0) in
      let target_level : bits 2 := LL in
      (if eq_vec (LL) ((('b"00")  : mword 2)) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      returnM ((Some ((DebugSwitchToExceptionLevel (target_level)))))
    else assert_exp' false "Pattern match failure at armV8.sail:291.0-298.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeSystem (v__317 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__317) (31) (19))) ((('b"1101010100000")  : mword 13))))
         ((andb ((eq_vec ((subrange_vec_dec (v__317) (15) (12))) (((Ox"4")  : mword 4))))
             ((eq_vec ((subrange_vec_dec (v__317) (4) (0))) ((('b"11111")  : mword 5))))))
      return
      M (option ast) then
      let op2 : bits 3 := subrange_vec_dec (v__317) (7) (5) in
      let op1 : bits 3 := subrange_vec_dec (v__317) (18) (16) in
      let CRm : bits 4 := subrange_vec_dec (v__317) (11) (8) in
      let operand : bits 4 := CRm in
      let field' : PSTATEField := PSTATEField_DAIFSet in
      let v__323 := concat_vec (op1) (op2) in
      (if eq_vec (v__323) ((('b"000101")  : mword 6)) then returnM (PSTATEField_SP)
       else if eq_vec (v__323) ((('b"011110")  : mword 6)) then returnM (PSTATEField_DAIFSet)
       else if eq_vec (v__323) ((('b"011111")  : mword 6)) then returnM (PSTATEField_DAIFClr)
       else (UnallocatedEncoding (tt)) >> returnM (field')) >>= fun (field' : PSTATEField) =>
      returnM ((Some ((MoveSystemImmediate ((operand, field'))))))
    else if andb ((eq_vec ((subrange_vec_dec (v__317) (31) (12))) (((Ox"D5032")  : mword 20))))
              ((eq_vec ((subrange_vec_dec (v__317) (4) (0))) ((('b"11111")  : mword 5)))) then
      let op2 : bits 3 := subrange_vec_dec (v__317) (7) (5) in
      let CRm : bits 4 := subrange_vec_dec (v__317) (11) (8) in
      let op : SystemHintOp := SystemHintOp_NOP in
      let v__339 := concat_vec (CRm) (op2) in
      let op : SystemHintOp :=
        if eq_vec (v__339) ((('b"0000000")  : mword 7)) then SystemHintOp_NOP
        else if eq_vec (v__339) ((('b"0000001")  : mword 7)) then SystemHintOp_YIELD
        else if eq_vec (v__339) ((('b"0000010")  : mword 7)) then SystemHintOp_WFE
        else if eq_vec (v__339) ((('b"0000011")  : mword 7)) then SystemHintOp_WFI
        else if eq_vec (v__339) ((('b"0000100")  : mword 7)) then SystemHintOp_SEV
        else if eq_vec (v__339) ((('b"0000101")  : mword 7)) then SystemHintOp_SEVL
        else SystemHintOp_NOP in
      returnM ((Some ((Hint (op)))))
    else if andb ((eq_vec ((subrange_vec_dec (v__317) (31) (12))) (((Ox"D5033")  : mword 20))))
              ((eq_vec ((subrange_vec_dec (v__317) (7) (0))) (((Ox"5F")  : mword 8)))) then
      let CRm : bits 4 := subrange_vec_dec (v__317) (11) (8) in
      let imm : uinteger := UInt (CRm) in
      returnM ((Some ((ClearExclusiveMonitor (imm)))))
    else if andb ((eq_vec ((subrange_vec_dec (v__317) (31) (12))) (((Ox"D5033")  : mword 20))))
              ((andb ((eq_vec ((subrange_vec_dec (v__317) (7) (7))) ((('b"1")  : mword 1))))
                  ((eq_vec ((subrange_vec_dec (v__317) (4) (0))) ((('b"11111")  : mword 5))))))
      return
      M (option ast) then
      let opc : bits 2 := subrange_vec_dec (v__317) (6) (5) in
      let CRm : bits 4 := subrange_vec_dec (v__317) (11) (8) in
      let op : MemBarrierOp := MemBarrierOp_DSB in
      let domain : MBReqDomain := MBReqDomain_Nonshareable in
      let types : MBReqTypes := MBReqTypes_Reads in
      let b__0 := opc in
      (if eq_vec (b__0) ((('b"00")  : mword 2)) then returnM (MemBarrierOp_DSB)
       else if eq_vec (b__0) ((('b"01")  : mword 2)) then returnM (MemBarrierOp_DMB)
       else if eq_vec (b__0) ((('b"10")  : mword 2)) then returnM (MemBarrierOp_ISB)
       else (UnallocatedEncoding (tt)) >> returnM (op)) >>= fun (op : MemBarrierOp) =>
      let b__3 := subrange_vec_dec (CRm) (3) (2) in
      let domain : MBReqDomain :=
        if eq_vec (b__3) ((('b"00")  : mword 2)) then MBReqDomain_OuterShareable
        else if eq_vec (b__3) ((('b"01")  : mword 2)) then MBReqDomain_Nonshareable
        else if eq_vec (b__3) ((('b"10")  : mword 2)) then MBReqDomain_InnerShareable
        else MBReqDomain_FullSystem in
      let b__6 := subrange_vec_dec (CRm) (1) (0) in
      let '((domain, types)) :=
        (if eq_vec (b__6) ((('b"01")  : mword 2)) then
           let types : MBReqTypes := MBReqTypes_Reads in
           (domain, types)
         else
           let '((domain, types)) :=
             (if eq_vec (b__6) ((('b"10")  : mword 2)) then
                let types : MBReqTypes := MBReqTypes_Writes in
                (domain, types)
              else
                let '((domain, types)) :=
                  (if eq_vec (b__6) ((('b"11")  : mword 2)) then
                     let types : MBReqTypes := MBReqTypes_All in
                     (domain, types)
                   else
                     let types : MBReqTypes := MBReqTypes_All in
                     let domain : MBReqDomain := MBReqDomain_FullSystem in
                     (domain, types))
                   : (MBReqDomain * MBReqTypes) in
                (domain, types))
              : (MBReqDomain * MBReqTypes) in
           (domain, types))
         : (MBReqDomain * MBReqTypes) in
      returnM ((Some ((Barrier ((op, domain, types))))))
    else if andb ((eq_vec ((subrange_vec_dec (v__317) (31) (22))) ((('b"1101010100")  : mword 10))))
              ((eq_vec ((subrange_vec_dec (v__317) (20) (19))) ((('b"01")  : mword 2))))
      return
      M (option ast) then
      let L := access_vec_dec (v__317) (21) in
      let op2 : bits 3 := subrange_vec_dec (v__317) (7) (5) in
      let op1 : bits 3 := subrange_vec_dec (v__317) (18) (16) in
      let Rt : bits 5 := subrange_vec_dec (v__317) (4) (0) in
      let CRn : bits 4 := subrange_vec_dec (v__317) (15) (12) in
      let CRm : bits 4 := subrange_vec_dec (v__317) (11) (8) in
      let t : reg_index := UInt_reg (Rt) in
      let sysop : SystemOp := Sys_SYS in
      let sysop : SystemOp := if eq_bit (L) (b0) then SysOp (op1) (CRn) (CRm) (op2) else sysop in
      (match sysop with
       | Sys_AT => (not_implemented ("AT"))  : M (option ast)
       | Sys_DC =>
          (match (op1, CRm, op2) with
           | (b__9, b__10, b__11) =>
              (if andb ((eq_vec (b__9) ((('b"000")  : mword 3))))
                    ((andb ((eq_vec (b__10) (((Ox"6")  : mword 4))))
                        ((eq_vec (b__11) ((('b"001")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, IVAC))))))
               else if andb ((eq_vec (b__9) ((('b"000")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"6")  : mword 4))))
                             ((eq_vec (b__11) ((('b"010")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, ISW))))))
               else if andb ((eq_vec (b__9) ((('b"000")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"A")  : mword 4))))
                             ((eq_vec (b__11) ((('b"010")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, CSW))))))
               else if andb ((eq_vec (b__9) ((('b"000")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"E")  : mword 4))))
                             ((eq_vec (b__11) ((('b"010")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, CISW))))))
               else if andb ((eq_vec (b__9) ((('b"011")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"4")  : mword 4))))
                             ((eq_vec (b__11) ((('b"001")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, ZVA))))))
               else if andb ((eq_vec (b__9) ((('b"011")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"A")  : mword 4))))
                             ((eq_vec (b__11) ((('b"001")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, CVAC))))))
               else if andb ((eq_vec (b__9) ((('b"011")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"B")  : mword 4))))
                             ((eq_vec (b__11) ((('b"001")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, CVAU))))))
               else if andb ((eq_vec (b__9) ((('b"011")  : mword 3))))
                         ((andb ((eq_vec (b__10) (((Ox"E")  : mword 4))))
                             ((eq_vec (b__11) ((('b"001")  : mword 3)))))) then
                 returnM ((Some ((DataCache ((t, CIVAC))))))
               else (error ("should never happen"))  : M (option ast))
               : M (option ast)
           end)
           : M (option ast)
       | Sys_IC =>
          (match (op1, CRm, op2) with
           | (b__33, b__34, b__35) =>
              (if andb ((eq_vec (b__33) ((('b"000")  : mword 3))))
                    ((andb ((eq_vec (b__34) (((Ox"1")  : mword 4))))
                        ((eq_vec (b__35) ((('b"000")  : mword 3)))))) then
                 returnM ((Some ((InstructionCache ((t, IALLUIS))))))
               else if andb ((eq_vec (b__33) ((('b"000")  : mword 3))))
                         ((andb ((eq_vec (b__34) (((Ox"5")  : mword 4))))
                             ((eq_vec (b__35) ((('b"000")  : mword 3)))))) then
                 returnM ((Some ((InstructionCache ((t, IALLU))))))
               else if andb ((eq_vec (b__33) ((('b"011")  : mword 3))))
                         ((andb ((eq_vec (b__34) (((Ox"5")  : mword 4))))
                             ((eq_vec (b__35) ((('b"001")  : mword 3)))))) then
                 returnM ((Some ((InstructionCache ((t, IVAU))))))
               else (error ("should never happen"))  : M (option ast))
               : M (option ast)
           end)
           : M (option ast)
       | Sys_TLBI => (not_implemented ("TLBI"))  : M (option ast)
       | Sys_SYS =>
          let sys_op0 : uinteger := 1 in
          let sys_op1 : uinteger := UInt (op1) in
          let sys_op2 : uinteger := UInt (op2) in
          let sys_crn : uinteger := UInt (CRn) in
          let sys_crm : uinteger := UInt (CRm) in
          let has_result : boolean := eq_bit (L) (b1) in
          returnM ((Some ((System ((t, sys_op0, sys_op1, sys_op2, sys_crn, sys_crm, has_result))))))
       end)
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__317) (31) (22))) ((('b"1101010100")  : mword 10))))
              ((eq_vec ((subrange_vec_dec (v__317) (20) (20))) ((('b"1")  : mword 1)))) then
      let L := access_vec_dec (v__317) (21) in
      let o0 := access_vec_dec (v__317) (19) in
      let op2 : bits 3 := subrange_vec_dec (v__317) (7) (5) in
      let op1 : bits 3 := subrange_vec_dec (v__317) (18) (16) in
      let Rt : bits 5 := subrange_vec_dec (v__317) (4) (0) in
      let CRn : bits 4 := subrange_vec_dec (v__317) (15) (12) in
      let CRm : bits 4 := subrange_vec_dec (v__317) (11) (8) in
      let t : reg_index := UInt_reg (Rt) in
      let sys_op0 : uinteger := Z.add (2) ((UInt ((vec_of_bits [o0]  : mword 1)))) in
      let sys_op1 : uinteger := UInt (op1) in
      let sys_op2 : uinteger := UInt (op2) in
      let sys_crn : uinteger := UInt (CRn) in
      let sys_crm : uinteger := UInt (CRm) in
      let read : boolean := eq_bit (L) (b1) in
      returnM ((Some ((MoveSystemRegister ((t, sys_op0, sys_op1, sys_op2, sys_crn, sys_crm, read))))))
    else assert_exp' false "Pattern match failure at armV8.sail:561.0-575.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeImplementationDefined (v__382 : mword 32) : M (option ast) :=
   (if andb
         ((eq_vec ((subrange_vec_dec (v__382) (31) (15))) ((('b"11010101000010111")  : mword 17))))
         ((eq_vec ((subrange_vec_dec (v__382) (13) (1))) ((('b"1100000000000")  : mword 13)))) then
      let isEnd := access_vec_dec (v__382) (0) in
      returnM ((Some ((ImplementationDefinedTestBeginEnd ((eq_bit (isEnd) (b1)))))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__382) (31) (15)))
                  ((('b"11010101000010111")
                   : mword 17))))
              ((eq_vec ((subrange_vec_dec (v__382) (13) (0))) ((('b"11000000000010")  : mword 14))))
    then
      returnM ((Some ((ImplementationDefinedStopFetching (tt)))))
    else if andb
              ((eq_vec ((subrange_vec_dec (v__382) (31) (15)))
                  ((('b"11010101000010111")
                   : mword 17))))
              ((eq_vec ((subrange_vec_dec (v__382) (13) (0))) ((('b"11000000000011")  : mword 14))))
    then
      returnM ((Some ((ImplementationDefinedThreadStart (tt)))))
    else assert_exp' false "Pattern match failure at armV8.sail:611.0-613.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeTestBranchImmediate (v__416 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__416) (30) (25))) ((('b"011011")  : mword 6))
      return
      M (option ast) then
      let b5 := access_vec_dec (v__416) (31) in
      let op := access_vec_dec (v__416) (24) in
      let imm14 : bits 14 := subrange_vec_dec (v__416) (18) (5) in
      let b40 : bits 5 := subrange_vec_dec (v__416) (23) (19) in
      let Rt : bits 5 := subrange_vec_dec (v__416) (4) (0) in
      let t : reg_index := UInt_reg (Rt) in
      let datasize : Z := if eq_bit (b5) (b1) then 64 else 32 in
      let bit_pos : uinteger := UInt ((concat_vec ((vec_of_bits [b5]  : mword 1)) (b40))) in
      let bit_val : bitU := op in
      (SignExtend (64) ((concat_vec (imm14) ((('b"00")  : mword 2))))) >>= fun (offset : bits 64) =>
      assert_exp' (Z.leb (bit_pos) ((Z.sub (datasize) (1)))) "armV8.sail:632.32-632.33" >>= fun _ =>
      returnM ((Some ((TestBitAndBranch ((t, datasize, bit_pos, bit_val, offset))))))
    else assert_exp' false "Pattern match failure at armV8.sail:624.0-635.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeUnconditionalBranchImmediate (v__420 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__420) (30) (26))) ((('b"00101")  : mword 5))
      return
      M (option ast) then
      let op := access_vec_dec (v__420) (31) in
      let imm26 : bits 26 := subrange_vec_dec (v__420) (25) (0) in
      let branch_type : BranchType := if eq_bit (op) (b1) then BranchType_CALL else BranchType_JMP in
      (SignExtend (64) ((concat_vec (imm26) ((('b"00")  : mword 2))))) >>= fun (offset : bits 64) =>
      returnM ((Some ((BranchImmediate ((branch_type, offset))))))
    else assert_exp' false "Pattern match failure at armV8.sail:650.0-655.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeUnconditionalBranchRegister (v__423 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__423) (31) (23))) ((('b"110101100")  : mword 9))))
         ((andb ((eq_vec ((subrange_vec_dec (v__423) (20) (10))) ((('b"11111000000")  : mword 11))))
             ((eq_vec ((subrange_vec_dec (v__423) (4) (0))) ((('b"00000")  : mword 5))))))
      return
      M (option ast) then
      let op : bits 2 := subrange_vec_dec (v__423) (22) (21) in
      let Rn : bits 5 := subrange_vec_dec (v__423) (9) (5) in
      let n : reg_index := UInt_reg (Rn) in
      let branch_type : BranchType := BranchType_CALL in
      let b__0 := op in
      (if eq_vec (b__0) ((('b"00")  : mword 2)) then returnM (BranchType_JMP)
       else if eq_vec (b__0) ((('b"01")  : mword 2)) then returnM (BranchType_CALL)
       else if eq_vec (b__0) ((('b"10")  : mword 2)) then returnM (BranchType_RET)
       else (UnallocatedEncoding (tt)) >> returnM (branch_type)) >>= fun (branch_type : BranchType) =>
      returnM ((Some ((BranchRegister ((n, branch_type))))))
    else if eq_vec (v__423) (((Ox"D69F03E0")  : mword 32)) then
      returnM ((Some ((ExceptionReturn (tt)))))
    else if eq_vec (v__423) (((Ox"D6BF03E0")  : mword 32)) then
      returnM ((Some ((DebugRestorePState (tt)))))
    else assert_exp' false "Pattern match failure at armV8.sail:706.0-711.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeAdvSIMDLoadStoreMultiStruct (machineCode : mword 32) : M (option ast) :=
   (not_implemented ("decodeAdvSIMDLoadStoreMultiStruct")) >> returnM ((Some ((Unallocated (tt))))).

Definition decodeAdvSIMDLoadStoreMultiStructPostIndexed (machineCode : mword 32) : M (option ast) :=
   (not_implemented ("decodeAdvSIMDLoadStoreMultiStructPostIndexed")) >>
   returnM ((Some ((Unallocated (tt))))).

Definition decodeAdvSIMDLoadStoreSingleStruct (machineCode : mword 32) : M (option ast) :=
   (not_implemented ("decodeAdvSIMDLoadStoreSingleStruct")) >> returnM ((Some ((Unallocated (tt))))).

Definition decodeAdvSIMDLoadStoreSingleStructPostIndexed (machineCode : mword 32) : M (option ast) :=
   (not_implemented ("decodeAdvSIMDLoadStoreSingleStructPostIndexed")) >>
   returnM ((Some ((Unallocated (tt))))).

Definition decodeLoadRegisterLiteral (v__443 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__443) (29) (24))) ((('b"011000")  : mword 6))
      return
      M (option ast) then
      let opc : bits 2 := subrange_vec_dec (v__443) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__443) (31) (30) in
      let imm19 : bits 19 := subrange_vec_dec (v__443) (23) (5) in
      let Rt : bits 5 := subrange_vec_dec (v__443) (4) (0) in
      let t : reg_index := UInt_reg (Rt) in
      let memop : MemOp := MemOp_LOAD in
      let _signed : boolean := false in
      let size : Z := 4 in
      let b__0 := opc in
      let '((_signed, memop, size)) :=
        (if eq_vec (b__0) ((('b"00")  : mword 2)) then
           let size : Z := 4 in
           (_signed, memop, size)
         else
           let '((_signed, memop, size)) :=
             (if eq_vec (b__0) ((('b"01")  : mword 2)) then
                let size : Z := 8 in
                (_signed, memop, size)
              else
                let '((_signed, memop, size)) :=
                  (if eq_vec (b__0) ((('b"10")  : mword 2)) then
                     let size : Z := 4 in
                     let _signed : boolean := true in
                     (_signed, memop, size)
                   else
                     let memop : MemOp := MemOp_PREFETCH in
                     (_signed, memop, size))
                   : (bool * MemOp * Z) in
                (_signed, memop, size))
              : (bool * MemOp * Z) in
           (_signed, memop, size))
         : (bool * MemOp * Z) in
      (SignExtend (64) ((concat_vec (imm19) ((('b"00")  : mword 2))))) >>= fun (offset : bits 64) =>
      let size := size in
      let datasize := Z.mul (size) (8) in
      returnM ((Some ((LoadLiteral ((t, memop, _signed, size, offset, datasize))))))
    else assert_exp' false "Pattern match failure at armV8.sail:747.0-774.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreExclusive (v__447 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__447) (29) (24))) ((('b"001000")  : mword 6))
      return
      M (option ast) then
      let o2 := access_vec_dec (v__447) (23) in
      let L := access_vec_dec (v__447) (22) in
      let o1 := access_vec_dec (v__447) (21) in
      let o0 := access_vec_dec (v__447) (15) in
      let size : bits 2 := subrange_vec_dec (v__447) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__447) (31) (30) in
      let Rt2 : bits 5 := subrange_vec_dec (v__447) (14) (10) in
      let Rt : bits 5 := subrange_vec_dec (v__447) (4) (0) in
      let Rs : bits 5 := subrange_vec_dec (v__447) (20) (16) in
      let Rn : bits 5 := subrange_vec_dec (v__447) (9) (5) in
      let n : reg_index := UInt_reg (Rn) in
      let t : reg_index := UInt_reg (Rt) in
      let t2 : reg_index := UInt_reg (Rt2) in
      let s : reg_index := UInt_reg (Rs) in
      (if orb ((eq_vec ((vec_of_bits [o2;o1;o0]  : mword 3)) ((('b"100")  : mword 3))))
            ((eq_vec ((vec_of_bits [o2;o1]  : mword 2)) ((('b"11")  : mword 2))))
         return
         M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      (if andb ((eq_bit (o1) (b1))) ((eq_bit ((access_vec_dec (size) (1))) (b0)))
         return
         M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let acctype : AccType := if eq_bit (o0) (b1) then AccType_ORDERED else AccType_ATOMIC in
      let excl : boolean := eq_bit (o2) (b0) in
      let pair' : boolean := eq_bit (o1) (b1) in
      let memop : MemOp := if eq_bit (L) (b1) then MemOp_LOAD else MemOp_STORE in
      let '(size_uint) := UInt (size) in
      let elsize : Z := lsl' (8) (size_uint) in
      let '(elsize) := elsize in
      assert_exp' (orb ((Z.eqb (elsize) (8)))
                     ((orb ((Z.eqb (elsize) (16)))
                         ((orb ((Z.eqb (elsize) (32))) ((Z.eqb (elsize) (64)))))))) "armV8.sail:837.65-837.66" >>= fun _ =>
      let '(regsize) := if Z.eqb (elsize) (64) then 64 else 32 in
      let datasize : Z := if pair' then Z.mul (elsize) (2) else elsize in
      returnM ((Some
                  ((LoadStoreAcqExc
                      ((n, t, t2, s, acctype, excl, pair', memop, elsize, regsize, datasize))))))
    else assert_exp' false "Pattern match failure at armV8.sail:821.0-846.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreNoAllocatePairOffset (v__453 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__453) (29) (23))) ((('b"1010000")  : mword 7))
      return
      M (option ast) then
      let L := access_vec_dec (v__453) (22) in
      let opc : bits 2 := subrange_vec_dec (v__453) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__453) (31) (30) in
      let imm7 : bits 7 := subrange_vec_dec (v__453) (21) (15) in
      let Rt2 : bits 5 := subrange_vec_dec (v__453) (14) (10) in
      let Rt : bits 5 := subrange_vec_dec (v__453) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__453) (9) (5) in
      let wback : boolean := false in
      let postindex : boolean := false in
      let n : reg_index := UInt_reg (Rn) in
      let t : reg_index := UInt_reg (Rt) in
      let t2 : reg_index := UInt_reg (Rt2) in
      let acctype : AccType := AccType_STREAM in
      let memop : MemOp := if eq_bit (L) (b1) then MemOp_LOAD else MemOp_STORE in
      (if eq_bit ((access_vec_dec (opc) (0))) (b1) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let scale : Z := Z.add (2) ((UInt ((vec_of_bits [access_vec_dec (opc) (1)]  : mword 1)))) in
      let datasize := lsl' (8) (scale) in
      assert_exp' (orb ((Z.eqb (datasize) (32))) ((Z.eqb (datasize) (64)))) "armV8.sail:1036.40-1036.41" >>= fun _ =>
      (SignExtend (64) (imm7)) >>= fun (w__0 : mword 64) =>
      let offset : bits 64 := LSL (w__0) (scale) in
      returnM ((Some
                  ((LoadStorePairNonTemp
                      ((wback, postindex, n, t, t2, acctype, memop, scale, datasize, offset))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1022.0-1040.1" >>= fun _ => exit tt)
    : M (option ast).

Definition sharedDecodeLoadImmediate
(opc : mword 2) (size : mword 2) (Rn : mword 5) (Rt : mword 5) (wback : bool) (postindex : bool)
(scale : Z) (offset : mword 64) (acctype : AccType) (prefetchAllowed : bool)
(*(0 <=? scale) && (scale <=? 3)*)
: M (option ast) :=
   let n : reg_index := UInt_reg (Rn) in
   let t : reg_index := UInt_reg (Rt) in
   let memop : MemOp := MemOp_LOAD in
   let _signed : boolean := false in
   let regsize : Z := 64 in
   (if eq_bit ((access_vec_dec (opc) (1))) (b0) then
      let memop : MemOp :=
        if eq_bit ((access_vec_dec (opc) (0))) (b1) then MemOp_LOAD
        else MemOp_STORE in
      let regsize : Z := if eq_vec (size) ((('b"11")  : mword 2)) then 64 else 32 in
      let _signed : boolean := false in
      returnM ((_signed, memop, regsize))
    else if eq_vec (size) ((('b"11")  : mword 2)) return M ((bool * MemOp * Z)) then
      (if prefetchAllowed return M (MemOp) then
         let memop : MemOp := MemOp_PREFETCH in
         (if eq_bit ((access_vec_dec (opc) (0))) (b1) return M (unit) then
            (UnallocatedEncoding (tt))
             : M (unit)
          else returnM (tt)) >>
         returnM (memop)
       else (UnallocatedEncoding (tt)) >> returnM (memop)) >>= fun (memop : MemOp) =>
      returnM ((_signed, memop, regsize))
    else
      let memop : MemOp := MemOp_LOAD in
      (if andb ((eq_vec (size) ((('b"10")  : mword 2))))
            ((eq_bit ((access_vec_dec (opc) (0))) (b1)))
         return
         M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let regsize : Z := if eq_bit ((access_vec_dec (opc) (0))) (b1) then 32 else 64 in
      let _signed : boolean := true in
      returnM ((_signed, memop, regsize))) >>= fun '((_signed, memop, regsize)
   : (bool * MemOp * Z)) =>
   let datasize := lsl' (8) (scale) in
   assert_exp' (orb ((Z.eqb (datasize) (8)))
                  ((orb ((Z.eqb (datasize) (16)))
                      ((orb ((Z.eqb (datasize) (32))) ((Z.eqb (datasize) (64)))))))) "armV8.sail:1166.74-1166.75" >>= fun _ =>
   returnM ((Some
               ((LoadImmediate
                   ((n, t, acctype, memop, _signed, wback, postindex, offset, regsize, datasize)))))).

Definition decodeLoadStoreRegisterImmediatePostIndexed (v__458 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__458) (29) (24))) ((('b"111000")  : mword 6))))
         ((andb ((eq_vec ((subrange_vec_dec (v__458) (21) (21))) ((('b"0")  : mword 1))))
             ((eq_vec ((subrange_vec_dec (v__458) (11) (10))) ((('b"01")  : mword 2))))))
      return
      M (option ast) then
      let size : bits 2 := subrange_vec_dec (v__458) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__458) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__458) (23) (22) in
      let imm9 : bits 9 := subrange_vec_dec (v__458) (20) (12) in
      let Rt : bits 5 := subrange_vec_dec (v__458) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__458) (9) (5) in
      let wback : boolean := true in
      let postindex : boolean := true in
      let scale : Z := UInt (size) in
      (SignExtend (64) (imm9)) >>= fun (offset : bits 64) =>
      (sharedDecodeLoadImmediate (opc) (size) (Rn) (Rt) (wback) (postindex) (scale) (offset)
         (AccType_NORMAL) (false))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1178.0-1185.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreRegisterImmediatePreIndexed (v__464 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__464) (29) (24))) ((('b"111000")  : mword 6))))
         ((andb ((eq_vec ((subrange_vec_dec (v__464) (21) (21))) ((('b"0")  : mword 1))))
             ((eq_vec ((subrange_vec_dec (v__464) (11) (10))) ((('b"11")  : mword 2))))))
      return
      M (option ast) then
      let size : bits 2 := subrange_vec_dec (v__464) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__464) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__464) (23) (22) in
      let imm9 : bits 9 := subrange_vec_dec (v__464) (20) (12) in
      let Rt : bits 5 := subrange_vec_dec (v__464) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__464) (9) (5) in
      let wback : boolean := true in
      let postindex : boolean := false in
      let scale : Z := UInt (size) in
      (SignExtend (64) (imm9)) >>= fun (offset : bits 64) =>
      (sharedDecodeLoadImmediate (opc) (size) (Rn) (Rt) (wback) (postindex) (scale) (offset)
         (AccType_NORMAL) (false))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1292.0-1299.1" >>= fun _ => exit tt)
    : M (option ast).

Definition sharedDecodeLoadRegister
(Rn : mword 5) (Rt : mword 5) (Rm : mword 5) (opc : mword 2) (size : mword 2) (wback : bool)
(postindex : bool) (scale : Z) (extend_type : ExtendType) (shift : Z)
(*(0 <=? scale) && (scale <=? 3)*) (*(0 <=? shift) && (shift <=? 3)*)
: M (option ast) :=
   let n : reg_index := UInt_reg (Rn) in
   let t : reg_index := UInt_reg (Rt) in
   let m : reg_index := UInt_reg (Rm) in
   let acctype : AccType := AccType_NORMAL in
   let memop : MemOp := MemOp_LOAD in
   let _signed : boolean := false in
   let regsize : Z := 64 in
   (if eq_bit ((access_vec_dec (opc) (1))) (b0) then
      let memop : MemOp :=
        if eq_bit ((access_vec_dec (opc) (0))) (b1) then MemOp_LOAD
        else MemOp_STORE in
      let regsize : Z := if eq_vec (size) ((('b"11")  : mword 2)) then 64 else 32 in
      let _signed : boolean := false in
      returnM ((_signed, memop, regsize))
    else if eq_vec (size) ((('b"11")  : mword 2)) return M ((bool * MemOp * Z)) then
      let memop : MemOp := MemOp_PREFETCH in
      (if eq_bit ((access_vec_dec (opc) (0))) (b1) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      returnM ((_signed, memop, regsize))
    else
      let memop : MemOp := MemOp_LOAD in
      (if andb ((eq_vec (size) ((('b"10")  : mword 2))))
            ((eq_bit ((access_vec_dec (opc) (0))) (b1)))
         return
         M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let regsize : Z := if eq_bit ((access_vec_dec (opc) (0))) (b1) then 32 else 64 in
      let _signed : boolean := true in
      returnM ((_signed, memop, regsize))) >>= fun '((_signed, memop, regsize)
   : (bool * MemOp * Z)) =>
   let datasize := lsl' (8) (scale) in
   assert_exp' (orb ((Z.eqb (datasize) (8)))
                  ((orb ((Z.eqb (datasize) (16)))
                      ((orb ((Z.eqb (datasize) (32))) ((Z.eqb (datasize) (64)))))))) "armV8.sail:1329.74-1329.75" >>= fun _ =>
   returnM ((Some
               ((LoadRegister
                   ((n, t, m, acctype, memop, _signed, wback, postindex, extend_type, shift, regsize, datasize)))))).

Definition decodeLoadStoreRegisterRegisterOffset (v__470 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__470) (29) (24))) ((('b"111000")  : mword 6))))
         ((andb ((eq_vec ((subrange_vec_dec (v__470) (21) (21))) ((('b"1")  : mword 1))))
             ((eq_vec ((subrange_vec_dec (v__470) (11) (10))) ((('b"10")  : mword 2))))))
      return
      M (option ast) then
      let S' := access_vec_dec (v__470) (12) in
      let size : bits 2 := subrange_vec_dec (v__470) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__470) (31) (30) in
      let option_v : bits 3 := subrange_vec_dec (v__470) (15) (13) in
      let opc : bits 2 := subrange_vec_dec (v__470) (23) (22) in
      let Rt : bits 5 := subrange_vec_dec (v__470) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__470) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__470) (20) (16) in
      let wback : boolean := false in
      let postindex : boolean := false in
      let scale : Z := UInt (size) in
      (if eq_bit ((access_vec_dec (option_v) (1))) (b0) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let extend_type : ExtendType := DecodeRegExtend (option_v) in
      let shift : Z := if eq_bit (S') (b1) then scale else 0 in
      (sharedDecodeLoadRegister (Rn) (Rt) (Rm) (opc) (size) (wback) (postindex) (scale)
         (extend_type) (shift))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1342.0-1351.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreRegisterUnprivileged (v__477 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__477) (29) (24))) ((('b"111000")  : mword 6))))
         ((andb ((eq_vec ((subrange_vec_dec (v__477) (21) (21))) ((('b"0")  : mword 1))))
             ((eq_vec ((subrange_vec_dec (v__477) (11) (10))) ((('b"10")  : mword 2))))))
      return
      M (option ast) then
      let size : bits 2 := subrange_vec_dec (v__477) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__477) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__477) (23) (22) in
      let imm9 : bits 9 := subrange_vec_dec (v__477) (20) (12) in
      let Rt : bits 5 := subrange_vec_dec (v__477) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__477) (9) (5) in
      let wback : boolean := false in
      let postindex : boolean := false in
      let scale : Z := UInt (size) in
      (SignExtend (64) (imm9)) >>= fun (offset : bits 64) =>
      (sharedDecodeLoadImmediate (opc) (size) (Rn) (Rt) (wback) (postindex) (scale) (offset)
         (AccType_UNPRIV) (false))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1460.0-1467.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreRegisterUnscaledImmediate (v__483 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__483) (29) (24))) ((('b"111000")  : mword 6))))
         ((andb ((eq_vec ((subrange_vec_dec (v__483) (21) (21))) ((('b"0")  : mword 1))))
             ((eq_vec ((subrange_vec_dec (v__483) (11) (10))) ((('b"00")  : mword 2))))))
      return
      M (option ast) then
      let size : bits 2 := subrange_vec_dec (v__483) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__483) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__483) (23) (22) in
      let imm9 : bits 9 := subrange_vec_dec (v__483) (20) (12) in
      let Rt : bits 5 := subrange_vec_dec (v__483) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__483) (9) (5) in
      let wback : boolean := false in
      let postindex : boolean := false in
      let scale : Z := UInt (size) in
      (SignExtend (64) (imm9)) >>= fun (offset : bits 64) =>
      (sharedDecodeLoadImmediate (opc) (size) (Rn) (Rt) (wback) (postindex) (scale) (offset)
         (AccType_NORMAL) (true))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1477.0-1484.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreRegisterUnsignedImmediate (v__489 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__489) (29) (24))) ((('b"111001")  : mword 6))
      return
      M (option ast) then
      let size : bits 2 := subrange_vec_dec (v__489) (31) (30) in
      let size : bits 2 := subrange_vec_dec (v__489) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__489) (23) (22) in
      let imm12 : bits 12 := subrange_vec_dec (v__489) (21) (10) in
      let Rt : bits 5 := subrange_vec_dec (v__489) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__489) (9) (5) in
      let wback : boolean := false in
      let postindex : boolean := false in
      let scale : Z := UInt (size) in
      let offset : bits 64 := LSL ((ZeroExtend (64) (imm12))) (scale) in
      (sharedDecodeLoadImmediate (opc) (size) (Rn) (Rt) (wback) (postindex) (scale) (offset)
         (AccType_NORMAL) (true))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1494.0-1501.1" >>= fun _ => exit tt)
    : M (option ast).

Definition sharedDecodeLoadStorePair
(L : bitU) (opc : mword 2) (imm7 : mword 7) (Rn : mword 5) (Rt : mword 5) (Rt2 : mword 5)
(wback : bool) (postindex : bool)
: M (option ast) :=
   let n : reg_index := UInt_reg (Rn) in
   let t : reg_index := UInt_reg (Rt) in
   let t2 : reg_index := UInt_reg (Rt2) in
   let acctype : AccType := AccType_NORMAL in
   let memop : MemOp := if eq_bit (L) (b1) then MemOp_LOAD else MemOp_STORE in
   (if orb
         ((eq_vec ((vec_of_bits [L;access_vec_dec (opc) (0)]  : mword 2)) ((('b"01")  : mword 2))))
         ((eq_vec (opc) ((('b"11")  : mword 2))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   let _signed : boolean := generic_neq ((access_vec_dec (opc) (0))) (b0) in
   let scale : Z := Z.add (2) ((UInt ((vec_of_bits [access_vec_dec (opc) (1)]  : mword 1)))) in
   let datasize := lsl' (8) (scale) in
   assert_exp' (orb ((Z.eqb (datasize) (8)))
                  ((orb ((Z.eqb (datasize) (16)))
                      ((orb ((Z.eqb (datasize) (32))) ((Z.eqb (datasize) (64)))))))) "armV8.sail:1513.74-1513.75" >>= fun _ =>
   (SignExtend (64) (imm7)) >>= fun (w__0 : mword 64) =>
   let offset : bits 64 := LSL (w__0) (scale) in
   returnM ((Some
               ((LoadStorePair
                   ((wback, postindex, n, t, t2, acctype, memop, _signed, datasize, offset)))))).

Definition decodeLoadStoreRegisterPairOffset (v__493 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__493) (29) (23))) ((('b"1010010")  : mword 7))
      return
      M (option ast) then
      let L := access_vec_dec (v__493) (22) in
      let opc : bits 2 := subrange_vec_dec (v__493) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__493) (31) (30) in
      let imm7 : bits 7 := subrange_vec_dec (v__493) (21) (15) in
      let Rt2 : bits 5 := subrange_vec_dec (v__493) (14) (10) in
      let Rt : bits 5 := subrange_vec_dec (v__493) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__493) (9) (5) in
      let wback : boolean := false in
      let postindex : boolean := false in
      (sharedDecodeLoadStorePair (L) (opc) (imm7) (Rn) (Rt) (Rt2) (wback) (postindex))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1523.0-1528.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreRegisterPairPostIndexed (v__498 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__498) (29) (23))) ((('b"1010001")  : mword 7))
      return
      M (option ast) then
      let L := access_vec_dec (v__498) (22) in
      let opc : bits 2 := subrange_vec_dec (v__498) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__498) (31) (30) in
      let imm7 : bits 7 := subrange_vec_dec (v__498) (21) (15) in
      let Rt2 : bits 5 := subrange_vec_dec (v__498) (14) (10) in
      let Rt : bits 5 := subrange_vec_dec (v__498) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__498) (9) (5) in
      let wback : boolean := true in
      let postindex : boolean := true in
      (sharedDecodeLoadStorePair (L) (opc) (imm7) (Rn) (Rt) (Rt2) (wback) (postindex))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1652.0-1657.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadStoreRegisterPairPreIndexed (v__503 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__503) (29) (23))) ((('b"1010011")  : mword 7))
      return
      M (option ast) then
      let L := access_vec_dec (v__503) (22) in
      let opc : bits 2 := subrange_vec_dec (v__503) (31) (30) in
      let opc : bits 2 := subrange_vec_dec (v__503) (31) (30) in
      let imm7 : bits 7 := subrange_vec_dec (v__503) (21) (15) in
      let Rt2 : bits 5 := subrange_vec_dec (v__503) (14) (10) in
      let Rt : bits 5 := subrange_vec_dec (v__503) (4) (0) in
      let Rn : bits 5 := subrange_vec_dec (v__503) (9) (5) in
      let wback : boolean := true in
      let postindex : boolean := false in
      (sharedDecodeLoadStorePair (L) (opc) (imm7) (Rn) (Rt) (Rt2) (wback) (postindex))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:1663.0-1668.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeAddSubtractImmediate (v__508 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__508) (28) (24))) ((('b"10001")  : mword 5))
      return
      M (option ast) then
      let sf := access_vec_dec (v__508) (31) in
      let op := access_vec_dec (v__508) (30) in
      let S' := access_vec_dec (v__508) (29) in
      let shift : bits 2 := subrange_vec_dec (v__508) (23) (22) in
      let imm12 : bits 12 := subrange_vec_dec (v__508) (21) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__508) (9) (5) in
      let Rd : bits 5 := subrange_vec_dec (v__508) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let sub_op : boolean := eq_bit (op) (b1) in
      let setflags : boolean := eq_bit (S') (b1) in
      let imm := Zeros (datasize) in
      let b__0 := shift in
      (if eq_vec (b__0) ((('b"00")  : mword 2)) then
         let imm := ZeroExtend ((length_mword (imm))) (imm12) in
         returnM (imm)
       else if eq_vec (b__0) ((('b"01")  : mword 2)) then
         let imm :=
           ZeroExtend ((length_mword (imm)))
             ((concat_vec (imm12) ((replicate_bits ((('b"0")  : mword 1)) (12))))) in
         returnM (imm)
       else (ReservedValue (tt)) >> returnM (imm)) >>= fun imm =>
      returnM ((Some ((AddSubImmediate (@existT _ _ _ ((d, n, datasize, sub_op, setflags, imm)))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1673.0-1688.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeBitfield (v__513 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__513) (28) (23))) ((('b"100110")  : mword 6))
      return
      M (option ast) then
      let sf := access_vec_dec (v__513) (31) in
      let N := access_vec_dec (v__513) (22) in
      let opc : bits 2 := subrange_vec_dec (v__513) (30) (29) in
      let imms : bits 6 := subrange_vec_dec (v__513) (15) (10) in
      let immr : bits 6 := subrange_vec_dec (v__513) (21) (16) in
      let Rn : bits 5 := subrange_vec_dec (v__513) (9) (5) in
      let Rd : bits 5 := subrange_vec_dec (v__513) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let inzero : boolean := false in
      let extend : boolean := false in
      let R' : Z := 0 in
      let S' : Z := 0 in
      let b__0 := opc in
      (if eq_vec (b__0) ((('b"00")  : mword 2)) then
         let inzero : boolean := true in
         let extend : boolean := true in
         returnM ((extend, inzero))
       else if eq_vec (b__0) ((('b"01")  : mword 2)) then
         let inzero : boolean := false in
         let extend : boolean := false in
         returnM ((extend, inzero))
       else if eq_vec (b__0) ((('b"10")  : mword 2)) then
         let inzero : boolean := true in
         let extend : boolean := false in
         returnM ((extend, inzero))
       else (UnallocatedEncoding (tt)) >> returnM ((extend, inzero))) >>= fun '((extend, inzero)
      : (bool * bool)) =>
      (if andb ((eq_bit (sf) (b1))) ((generic_neq (N) (b1))) return M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      (if andb ((eq_bit (sf) (b0)))
            ((orb ((generic_neq (N) (b0)))
                ((orb ((generic_neq ((access_vec_dec (immr) (5))) (b0)))
                    ((generic_neq ((access_vec_dec (imms) (5))) (b0)))))))
         return
         M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      let R' := UInt (immr) in
      let S' := UInt (imms) in
      (DecodeBitMasks (datasize) (N) (imms) (immr) (false)) >>= fun '((wmask, tmask)) =>
      assert_exp' (andb ((Z.ltb (R') (datasize))) ((Z.ltb (S') (datasize)))) "armV8.sail:1744.36-1744.37" >>= fun _ =>
      returnM ((Some
                  ((BitfieldMove
                      (@existT _ _ _ ((d, n, datasize, inzero, extend, R', S', wmask, tmask)))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1718.0-1747.2" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeExtract (v__517 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__517) (30) (23))) (((Ox"27")  : mword 8))))
         ((eq_vec ((subrange_vec_dec (v__517) (21) (21))) ((('b"0")  : mword 1))))
      return
      M (option ast) then
      let sf := access_vec_dec (v__517) (31) in
      let N := access_vec_dec (v__517) (22) in
      let imms : bits 6 := subrange_vec_dec (v__517) (15) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__517) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__517) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__517) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let lsb : Z := 0 in
      (if generic_neq (N) (sf) return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
       else returnM (tt)) >>
      (if andb ((eq_bit (sf) (b0))) ((eq_bit ((access_vec_dec (imms) (5))) (b1)))
         return
         M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      let lsb := UInt (imms) in
      assert_exp' (Z.ltb (lsb) (datasize)) "armV8.sail:1778.23-1778.24" >>= fun _ =>
      returnM ((Some ((ExtractRegister ((d, n, m, datasize, lsb))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1767.0-1780.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLogicalImmediate (v__523 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__523) (28) (23))) ((('b"100100")  : mword 6))
      return
      M (option ast) then
      let sf := access_vec_dec (v__523) (31) in
      let N := access_vec_dec (v__523) (22) in
      let opc : bits 2 := subrange_vec_dec (v__523) (30) (29) in
      let imms : bits 6 := subrange_vec_dec (v__523) (15) (10) in
      let immr : bits 6 := subrange_vec_dec (v__523) (21) (16) in
      let Rn : bits 5 := subrange_vec_dec (v__523) (9) (5) in
      let Rd : bits 5 := subrange_vec_dec (v__523) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let setflags : boolean := false in
      let op : LogicalOp := LogicalOp_AND in
      let b__0 := opc in
      let '((op, setflags)) :=
        (if eq_vec (b__0) ((('b"00")  : mword 2)) then
           let op : LogicalOp := LogicalOp_AND in
           let setflags : boolean := false in
           (op, setflags)
         else
           let '((op, setflags)) :=
             (if eq_vec (b__0) ((('b"01")  : mword 2)) then
                let op : LogicalOp := LogicalOp_ORR in
                let setflags : boolean := false in
                (op, setflags)
              else
                let '((op, setflags)) :=
                  (if eq_vec (b__0) ((('b"10")  : mword 2)) then
                     let op : LogicalOp := LogicalOp_EOR in
                     let setflags : boolean := false in
                     (op, setflags)
                   else
                     let op : LogicalOp := LogicalOp_AND in
                     let setflags : boolean := true in
                     (op, setflags))
                   : (LogicalOp * bool) in
                (op, setflags))
              : (LogicalOp * bool) in
           (op, setflags))
         : (LogicalOp * bool) in
      (if andb ((eq_bit (sf) (b0))) ((generic_neq (N) (b0))) return M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      (DecodeBitMasks (datasize) (N) (imms) (immr) (true)) >>= fun '((imm, _)) =>
      returnM ((Some ((LogicalImmediate (@existT _ _ _ ((d, n, datasize, setflags, op, imm)))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1796.0-1813.2" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeMoveWideImmediate (v__527 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__527) (28) (23))) ((('b"100101")  : mword 6))
      return
      M (option ast) then
      let sf := access_vec_dec (v__527) (31) in
      let opc : bits 2 := subrange_vec_dec (v__527) (30) (29) in
      let imm16 : bits 16 := subrange_vec_dec (v__527) (20) (5) in
      let hw : bits 2 := subrange_vec_dec (v__527) (22) (21) in
      let Rd : bits 5 := subrange_vec_dec (v__527) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let imm : bits 16 := imm16 in
      let pos : uinteger := 0 in
      let opcode : MoveWideOp := MoveWideOp_N in
      let b__0 := opc in
      (if eq_vec (b__0) ((('b"00")  : mword 2)) then returnM (MoveWideOp_N)
       else if eq_vec (b__0) ((('b"10")  : mword 2)) then returnM (MoveWideOp_Z)
       else if eq_vec (b__0) ((('b"11")  : mword 2)) then returnM (MoveWideOp_K)
       else (UnallocatedEncoding (tt)) >> returnM (opcode)) >>= fun (opcode : MoveWideOp) =>
      (if andb ((eq_bit (sf) (b0))) ((eq_bit ((access_vec_dec (hw) (1))) (b1))) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let pos := UInt ((concat_vec (hw) (((Ox"0")  : mword 4)))) in
      assert_exp' (Z.ltb (pos) ((ZEuclid.div (datasize) (2)))) "armV8.sail:1855.29-1855.30" >>= fun _ =>
      returnM ((Some ((MoveWide ((d, datasize, imm, pos, opcode))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1839.0-1858.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodePCRelAddressing (v__530 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__530) (28) (24))) ((('b"10000")  : mword 5))
      return
      M (option ast) then
      let op := access_vec_dec (v__530) (31) in
      let immlo : bits 2 := subrange_vec_dec (v__530) (30) (29) in
      let immhi : bits 19 := subrange_vec_dec (v__530) (23) (5) in
      let Rd : bits 5 := subrange_vec_dec (v__530) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let page : boolean := eq_bit (op) (b1) in
      let imm : bits 64 := Zeros (64) in
      (if page return M (mword 64) then
         (SignExtend (64)
            ((concat_vec (immhi)
                ((concat_vec (immlo) ((replicate_bits ((('b"0")  : mword 1)) (12))))))))
          : M (mword 64)
       else (SignExtend (64) ((concat_vec (immhi) (immlo))))  : M (mword 64)) >>= fun (imm : mword 64) =>
      returnM ((Some ((Address ((d, page, imm))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1877.0-1888.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeAddSubtractExtendedRegister (v__533 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__533) (28) (21))) (((Ox"59")  : mword 8))
      return
      M (option ast) then
      let sf := access_vec_dec (v__533) (31) in
      let op := access_vec_dec (v__533) (30) in
      let S' := access_vec_dec (v__533) (29) in
      let option_v : bits 3 := subrange_vec_dec (v__533) (15) (13) in
      let imm3 : bits 3 := subrange_vec_dec (v__533) (12) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__533) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__533) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__533) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let sub_op : boolean := eq_bit (op) (b1) in
      let setflags : boolean := eq_bit (S') (b1) in
      let extend_type : ExtendType := DecodeRegExtend (option_v) in
      let shift : Z := UInt (imm3) in
      (if Z.gtb (shift) (4) return M (unit) then (ReservedValue (tt))  : M (unit)
       else returnM (tt)) >>
      returnM ((Some
                  ((AddSubExtendRegister ((d, n, m, datasize, sub_op, setflags, extend_type, shift))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1902.0-1914.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeAddSubtractShiftedRegister (v__540 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__540) (28) (24))) ((('b"01011")  : mword 5))))
         ((eq_vec ((subrange_vec_dec (v__540) (21) (21))) ((('b"0")  : mword 1))))
      return
      M (option ast) then
      let sf := access_vec_dec (v__540) (31) in
      let op := access_vec_dec (v__540) (30) in
      let S' := access_vec_dec (v__540) (29) in
      let shift : bits 2 := subrange_vec_dec (v__540) (23) (22) in
      let imm6 : bits 6 := subrange_vec_dec (v__540) (15) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__540) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__540) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__540) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let sub_op : boolean := eq_bit (op) (b1) in
      let setflags : boolean := eq_bit (S') (b1) in
      (if eq_vec (shift) ((('b"11")  : mword 2)) return M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      (if andb ((eq_bit (sf) (b0))) ((eq_bit ((access_vec_dec (imm6) (5))) (b1)))
         return
         M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      let shift_type : ShiftType := DecodeShift (shift) in
      let shift_amount : Z := UInt (imm6) in
      returnM ((Some
                  ((AddSubShiftedRegister
                      ((d, n, m, datasize, sub_op, setflags, shift_type, shift_amount))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1942.0-1957.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeAddSubtractWithCarry (v__546 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__546) (28) (21))) (((Ox"D0")  : mword 8))))
         ((eq_vec ((subrange_vec_dec (v__546) (15) (10))) ((('b"000000")  : mword 6)))) then
      let sf := access_vec_dec (v__546) (31) in
      let op := access_vec_dec (v__546) (30) in
      let S' := access_vec_dec (v__546) (29) in
      let Rn : bits 5 := subrange_vec_dec (v__546) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__546) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__546) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let sub_op : boolean := eq_bit (op) (b1) in
      let setflags : boolean := eq_bit (S') (b1) in
      returnM ((Some ((AddSubCarry ((d, n, m, datasize, sub_op, setflags))))))
    else assert_exp' false "Pattern match failure at armV8.sail:1985.0-1994.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeConditionalCompareImmediate (v__552 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__552) (29) (21))) ((('b"111010010")  : mword 9))))
         ((andb ((eq_vec ((subrange_vec_dec (v__552) (11) (10))) ((('b"10")  : mword 2))))
             ((eq_vec ((subrange_vec_dec (v__552) (4) (4))) ((('b"0")  : mword 1)))))) then
      let sf := access_vec_dec (v__552) (31) in
      let op := access_vec_dec (v__552) (30) in
      let nzcv : bits 4 := subrange_vec_dec (v__552) (3) (0) in
      let imm5 : bits 5 := subrange_vec_dec (v__552) (20) (16) in
      let _cond : bits 4 := subrange_vec_dec (v__552) (15) (12) in
      let Rn : bits 5 := subrange_vec_dec (v__552) (9) (5) in
      let n : reg_index := UInt_reg (Rn) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let sub_op : boolean := eq_bit (op) (b1) in
      let condition : bits 4 := _cond in
      let flags : bits 4 := nzcv in
      let imm := ZeroExtend (datasize) (imm5) in
      returnM ((Some
                  ((ConditionalCompareImmediate
                      (@existT _ _ _ ((n, datasize, sub_op, condition, flags, imm)))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2014.0-2023.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeConditionalCompareRegister (v__560 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__560) (29) (21))) ((('b"111010010")  : mword 9))))
         ((andb ((eq_vec ((subrange_vec_dec (v__560) (11) (10))) ((('b"00")  : mword 2))))
             ((eq_vec ((subrange_vec_dec (v__560) (4) (4))) ((('b"0")  : mword 1)))))) then
      let sf := access_vec_dec (v__560) (31) in
      let op := access_vec_dec (v__560) (30) in
      let nzcv : bits 4 := subrange_vec_dec (v__560) (3) (0) in
      let _cond : bits 4 := subrange_vec_dec (v__560) (15) (12) in
      let Rn : bits 5 := subrange_vec_dec (v__560) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__560) (20) (16) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let sub_op : boolean := eq_bit (op) (b1) in
      let condition : bits 4 := _cond in
      let flags : bits 4 := nzcv in
      returnM ((Some ((ConditionalCompareRegister ((n, m, datasize, sub_op, condition, flags))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2044.0-2053.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeConditionalSelect (v__568 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__568) (29) (21))) ((('b"011010100")  : mword 9))))
         ((eq_vec ((subrange_vec_dec (v__568) (11) (11))) ((('b"0")  : mword 1)))) then
      let sf := access_vec_dec (v__568) (31) in
      let op := access_vec_dec (v__568) (30) in
      let o2 := access_vec_dec (v__568) (10) in
      let _cond : bits 4 := subrange_vec_dec (v__568) (15) (12) in
      let Rn : bits 5 := subrange_vec_dec (v__568) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__568) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__568) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let condition : bits 4 := _cond in
      let else_inv : boolean := eq_bit (op) (b1) in
      let else_inc : boolean := eq_bit (o2) (b1) in
      returnM ((Some ((ConditionalSelect ((d, n, m, datasize, condition, else_inv, else_inc))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2076.0-2086.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeData1Source (v__575 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__575) (30) (12))) ((('b"1011010110000000000")  : mword 19))
      return
      M (option ast) then
      let sf := access_vec_dec (v__575) (31) in
      let opc : bits 2 := subrange_vec_dec (v__575) (11) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__575) (9) (5) in
      let Rd : bits 5 := subrange_vec_dec (v__575) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let op : RevOp := RevOp_RBIT in
      let b__0 := opc in
      (if eq_vec (b__0) ((('b"00")  : mword 2)) then returnM (RevOp_RBIT)
       else if eq_vec (b__0) ((('b"01")  : mword 2)) then returnM (RevOp_REV16)
       else if eq_vec (b__0) ((('b"10")  : mword 2)) then returnM (RevOp_REV32)
       else
         (if eq_bit (sf) (b0) return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
          else returnM (tt)) >>
         returnM (RevOp_REV64)) >>= fun (op : RevOp) =>
      returnM ((Some ((Reverse ((d, n, datasize, op))))))
    else if eq_vec ((subrange_vec_dec (v__575) (30) (11))) (((Ox"B5802")  : mword 20)) then
      let sf := access_vec_dec (v__575) (31) in
      let op := access_vec_dec (v__575) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__575) (9) (5) in
      let Rd : bits 5 := subrange_vec_dec (v__575) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let opcode : CountOp := if eq_bit (op) (b0) then CountOp_CLZ else CountOp_CLS in
      returnM ((Some ((CountLeading ((d, n, datasize, opcode))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2170.0-2177.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeData2Source (v__590 : mword 32) : M (option ast) :=
   (if andb ((eq_vec ((subrange_vec_dec (v__590) (30) (21))) ((('b"0011010110")  : mword 10))))
         ((eq_vec ((subrange_vec_dec (v__590) (15) (11))) ((('b"00001")  : mword 5)))) then
      let sf := access_vec_dec (v__590) (31) in
      let o1 := access_vec_dec (v__590) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__590) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__590) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__590) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let _unsigned : boolean := eq_bit (o1) (b0) in
      returnM ((Some ((Division ((d, n, m, datasize, _unsigned))))))
    else if andb ((eq_vec ((subrange_vec_dec (v__590) (30) (21))) ((('b"0011010110")  : mword 10))))
              ((eq_vec ((subrange_vec_dec (v__590) (15) (12))) (((Ox"2")  : mword 4)))) then
      let sf := access_vec_dec (v__590) (31) in
      let op2 : bits 2 := subrange_vec_dec (v__590) (11) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__590) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__590) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__590) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let shift_type : ShiftType := DecodeShift (op2) in
      returnM ((Some ((Shift ((d, n, m, datasize, shift_type))))))
    else if andb ((eq_vec ((subrange_vec_dec (v__590) (30) (21))) ((('b"0011010110")  : mword 10))))
              ((eq_vec ((subrange_vec_dec (v__590) (15) (13))) ((('b"010")  : mword 3))))
      return
      M (option ast) then
      let sf := access_vec_dec (v__590) (31) in
      let C := access_vec_dec (v__590) (12) in
      let sz : bits 2 := subrange_vec_dec (v__590) (11) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__590) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__590) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__590) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      (if andb ((eq_bit (sf) (b1))) ((neq_vec (sz) ((('b"11")  : mword 2)))) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      (if andb ((eq_bit (sf) (b0))) ((eq_vec (sz) ((('b"11")  : mword 2)))) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      let size := lsl' (8) ((UInt (sz))) in
      assert_exp' (orb ((Z.eqb (size) (8)))
                     ((orb ((Z.eqb (size) (16))) ((orb ((Z.eqb (size) (32))) ((Z.eqb (size) (64)))))))) "armV8.sail:2252.58-2252.59" >>= fun _ =>
      let crc32c : boolean := eq_bit (C) (b1) in
      returnM ((Some ((CRC ((d, n, m, size, crc32c))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2245.0-2256.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeData3Source (v__610 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__610) (30) (21))) ((('b"0011011000")  : mword 10)) then
      let sf := access_vec_dec (v__610) (31) in
      let o0 := access_vec_dec (v__610) (15) in
      let Rn : bits 5 := subrange_vec_dec (v__610) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__610) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__610) (4) (0) in
      let Ra : bits 5 := subrange_vec_dec (v__610) (14) (10) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let a : reg_index := UInt_reg (Ra) in
      let destsize := if eq_bit (sf) (b1) then 64 else 32 in
      let datasize := destsize in
      let sub_op : boolean := eq_bit (o0) (b1) in
      returnM ((Some ((MultiplyAddSub ((d, n, m, a, destsize, datasize, sub_op))))))
    else if andb ((eq_vec ((subrange_vec_dec (v__610) (31) (24))) (((Ox"9B")  : mword 8))))
              ((eq_vec ((subrange_vec_dec (v__610) (22) (21))) ((('b"01")  : mword 2)))) then
      let U := access_vec_dec (v__610) (23) in
      let o0 := access_vec_dec (v__610) (15) in
      let Rn : bits 5 := subrange_vec_dec (v__610) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__610) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__610) (4) (0) in
      let Ra : bits 5 := subrange_vec_dec (v__610) (14) (10) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let a : reg_index := UInt_reg (Ra) in
      let destsize := 64 in
      let datasize := 32 in
      let sub_op : boolean := eq_bit (o0) (b1) in
      let _unsigned : boolean := eq_bit (U) (b1) in
      returnM ((Some ((MultiplyAddSubLong ((d, n, m, a, destsize, datasize, sub_op, _unsigned))))))
    else if andb ((eq_vec ((subrange_vec_dec (v__610) (31) (24))) (((Ox"9B")  : mword 8))))
              ((andb ((eq_vec ((subrange_vec_dec (v__610) (22) (21))) ((('b"10")  : mword 2))))
                  ((eq_vec ((subrange_vec_dec (v__610) (15) (15))) ((('b"0")  : mword 1)))))) then
      let U := access_vec_dec (v__610) (23) in
      let Rn : bits 5 := subrange_vec_dec (v__610) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__610) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__610) (4) (0) in
      let Ra : bits 5 := subrange_vec_dec (v__610) (14) (10) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let a : reg_index := UInt_reg (Ra) in
      let destsize := 64 in
      let datasize := destsize in
      let _unsigned : boolean := eq_bit (U) (b1) in
      returnM ((Some ((MultiplyHigh ((d, n, m, a, destsize, datasize, _unsigned))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2341.0-2351.1" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLogicalShiftedRegister (v__630 : mword 32) : M (option ast) :=
   (if eq_vec ((subrange_vec_dec (v__630) (28) (24))) ((('b"01010")  : mword 5))
      return
      M (option ast) then
      let sf := access_vec_dec (v__630) (31) in
      let N := access_vec_dec (v__630) (21) in
      let shift : bits 2 := subrange_vec_dec (v__630) (23) (22) in
      let opc : bits 2 := subrange_vec_dec (v__630) (30) (29) in
      let imm6 : bits 6 := subrange_vec_dec (v__630) (15) (10) in
      let Rn : bits 5 := subrange_vec_dec (v__630) (9) (5) in
      let Rm : bits 5 := subrange_vec_dec (v__630) (20) (16) in
      let Rd : bits 5 := subrange_vec_dec (v__630) (4) (0) in
      let d : reg_index := UInt_reg (Rd) in
      let n : reg_index := UInt_reg (Rn) in
      let m : reg_index := UInt_reg (Rm) in
      let datasize : Z := if eq_bit (sf) (b1) then 64 else 32 in
      let setflags : boolean := false in
      let op : LogicalOp := LogicalOp_AND in
      let b__0 := opc in
      let '((op, setflags)) :=
        (if eq_vec (b__0) ((('b"00")  : mword 2)) then
           let op : LogicalOp := LogicalOp_AND in
           let setflags : boolean := false in
           (op, setflags)
         else
           let '((op, setflags)) :=
             (if eq_vec (b__0) ((('b"01")  : mword 2)) then
                let op : LogicalOp := LogicalOp_ORR in
                let setflags : boolean := false in
                (op, setflags)
              else
                let '((op, setflags)) :=
                  (if eq_vec (b__0) ((('b"10")  : mword 2)) then
                     let op : LogicalOp := LogicalOp_EOR in
                     let setflags : boolean := false in
                     (op, setflags)
                   else
                     let op : LogicalOp := LogicalOp_AND in
                     let setflags : boolean := true in
                     (op, setflags))
                   : (LogicalOp * bool) in
                (op, setflags))
              : (LogicalOp * bool) in
           (op, setflags))
         : (LogicalOp * bool) in
      (if andb ((eq_bit (sf) (b0))) ((eq_bit ((access_vec_dec (imm6) (5))) (b1)))
         return
         M (unit) then
         (ReservedValue (tt))
          : M (unit)
       else returnM (tt)) >>
      let shift_type : ShiftType := DecodeShift (shift) in
      let shift_amount : Z := UInt (imm6) in
      let invert : boolean := eq_bit (N) (b1) in
      returnM ((Some
                  ((LogicalShiftedRegister
                      ((d, n, m, datasize, setflags, op, shift_type, shift_amount, invert))))))
    else assert_exp' false "Pattern match failure at armV8.sail:2373.0-2394.1" >>= fun _ => exit tt)
    : M (option ast).

Definition execute_TestBitAndBranch
(t : Z) '(datasize : Z) (bit_pos : Z) (bit_val : bitU) (offset : mword 64)
(*member_Z_list datasize [32; 64] && ((0 <=? bit_pos) && (bit_pos <? datasize))*)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (rX ((__id (datasize))) (t)) >>= fun (operand : bits datasize) =>
   (if eq_bit ((access_vec_dec (operand) (bit_pos))) (bit_val) return M (unit) then
      (rPC (tt)) >>= fun (w__0 : mword 64) =>
      (BranchTo ((add_vec (w__0) (offset))) (BranchType_JMP))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition execute_TMTest '(tt : unit) : M (unit) :=
   ((read_reg TxNestingLevel)  : M (mword 8)) >>= fun (w__0 : mword 8) =>
   (if zopz0zI_u (((Ox"00")  : mword 8)) (w__0) return M (unit) then
      (wPSTATE_NZCV (((Ox"0")  : mword 4)))
       : M (unit)
    else (wPSTATE_NZCV (((Ox"4")  : mword 4)))  : M (unit))
    : M (unit).

Definition execute_TMStart (t : Z) (*(0 <=? t) && (t <=? 31)*) : M (unit) :=
   ((read_reg TxNestingLevel)  : M (mword 8)) >>= fun (nesting : bits 8) =>
   ((read_reg TXIDR_EL0)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (if zopz0zI_u (nesting) ((_get_TXIDR_EL0_type_DEPTH (w__0))) return M (unit) then
      write_reg TxNestingLevel (add_vec_int (nesting) (1)) >>
      let status : bits 64 := Zeros (64) in
      (if eq_vec (nesting) (((Ox"00")  : mword 8)) return M (mword 64) then
         ((read_reg TMStartEffect)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
         let status := (_get_TMSTATUS_type_bits (w__1))  : mword 64 in
         returnM (status)
       else returnM (status)) >>= fun (status : mword 64) =>
      (wX (t) (status))
       : M (unit)
    else
      let status : bits 64 := Zeros (64) in
      let status : bits 64 := update_vec_dec (status) (10) (b1) in
      (_set_TMSTATUS_type_bits (TMAbortEffect_ref) (status))
       : M (unit))
    : M (unit).

Definition execute_TMCommit '(tt : unit) : M (unit) :=
   ((read_reg TxNestingLevel)  : M (mword 8)) >>= fun (nesting : bits 8) =>
   (if eq_vec (nesting) (((Ox"01")  : mword 8)) return M (unit) then
      (TMCommitEffect (tt))
       : M (unit)
    else if eq_vec (nesting) (((Ox"00")  : mword 8)) return M (unit) then
      (AArch64_UndefinedFault (tt))
       : M (unit)
    else returnM (tt)) >>
   write_reg TxNestingLevel (sub_vec_int (nesting) (1))
    : M (unit).

Definition execute_TMAbort (retry : bool) (reason : mword 5) : M (unit) :=
   ((read_reg TxNestingLevel)  : M (mword 8)) >>= fun (w__0 : mword 8) =>
   (if zopz0zI_u (((Ox"00")  : mword 8)) (w__0) return M (unit) then
      let status : bits 64 := Zeros (64) in
      let status : bits 64 := update_subrange_vec_dec (status) (4) (0) (reason) in
      let status : bits 64 := update_vec_dec (status) (8) ((cast_bool_bit (retry))) in
      let status : bits 64 := update_vec_dec (status) (9) (b1) in
      (_set_TMSTATUS_type_bits (TMAbortEffect_ref) (status))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition execute_System
(t : Z) (sys_op0 : Z) (sys_op1 : Z) (sys_op2 : Z) (sys_crn : Z) (sys_crm : Z) (has_result : bool)
(*(0 <=? t) && (t <=? 31)*) (*0 <=? sys_op0*) (*0 <=? sys_op1*) (*0 <=? sys_op2*) (*0 <=? sys_crn*)
(*0 <=? sys_crm*)
: M (unit) :=
   (if has_result return M (unit) then
      (SysOp_R (sys_op0) (sys_op1) (sys_crn) (sys_crm) (sys_op2)) >>= fun (w__0 : mword 64) =>
      (wX (t) (w__0))
       : M (unit)
    else
      (rX (64) (t)) >>= fun (w__1 : mword 64) =>
      (SysOp_W (sys_op0) (sys_op1) (sys_crn) (sys_crm) (sys_op2) (w__1))
       : M (unit))
    : M (unit).

Definition execute_Shift (d : Z) (n : Z) (m : Z) '(datasize : Z) (shift_type : ShiftType)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   let result : bits datasize := Zeros ((__id (datasize))) in
   (rX ((length_mword (result))) (m)) >>= fun (operand2 : bits datasize) =>
   (ShiftReg ((length_mword (result))) (n) (shift_type)
      ((ZEuclid.modulo ((UInt (operand2))) (datasize)))) >>= fun (w__0 : mword datasize) =>
   let result := w__0  : mword datasize in
   (wX (d) (result))
    : M (unit).

Definition execute_Reverse (d : Z) (n : Z) '(datasize : Z) (op : RevOp)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   let result : bits datasize := Zeros ((__id (datasize))) in
   let V : bits 6 :=
     match op with
     | RevOp_REV16 => ('b"001000")  : mword 6
     | RevOp_REV32 => ('b"011000")  : mword 6
     | RevOp_REV64 => ('b"111000")  : mword 6
     | RevOp_RBIT =>
        if Z.eqb (datasize) (64) then ('b"111111")  : mword 6 else ('b"011111")  : mword 6
     end in
   (rX ((length_mword (result))) (n)) >>= fun (w__0 : mword datasize) =>
   let result : bits datasize := w__0  : mword datasize in
   (let '(loop_vbit_lower) := 0 in
   let '(loop_vbit_upper) := 5 in
   (foreach_ZM_up loop_vbit_lower loop_vbit_upper 1 result
     (fun vbit result =>
       (if eq_bit ((access_vec_dec (V) (vbit))) (b1) return M (mword datasize) then
          let tmp : bits datasize := result in
          let vsize := lsl' (1) (vbit) in
          assert_exp' (Z.gtb (vsize) (0)) "armV8.sail:2152.23-2152.24" >>= fun _ =>
          (let '(loop_base_lower) := 0 in
          let '(loop_base_upper) := Z.sub (datasize) (1) in
          (foreach_ZM_up loop_base_lower loop_base_upper (Z.mul (2) (vsize)) result
            (fun base result =>
              assert_exp' (Z.ltb ((Z.sub ((Z.add (base) ((Z.mul (vsize) (2))))) (1))) (datasize)) "armV8.sail:2154.43-2154.44" >>= fun _ =>
              let result : bits datasize :=
                update_subrange_vec_dec (result) ((Z.sub ((Z.add (base) (vsize))) (1))) (base)
                  ((autocast (T := mword) (subrange_vec_dec (tmp)
                                             ((Z.sub ((Z.add (base) ((Z.mul (2) (vsize))))) (1)))
                                             ((Z.add (base) (vsize)))))) in
              let result : bits datasize :=
                update_subrange_vec_dec (result)
                  ((Z.sub ((Z.add (base) ((Z.mul (2) (vsize))))) (1))) ((Z.add (base) (vsize)))
                  ((autocast (T := mword) (subrange_vec_dec (tmp)
                                             ((Z.sub ((Z.add (base) (vsize))) (1))) (base)))) in
              returnM (result))))
           : M (mword datasize)
        else returnM (result))
        : M (mword datasize)))) >>= fun (result : mword datasize) =>
   (wX (d) (result))
    : M (unit).

Definition execute_MultiplyHigh
(d : Z) (n : Z) (m : Z) (a : Z) '(destsize : Z) (datasize : Z) (_unsigned : bool)
(*member_Z_list destsize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*) (*(0 <=? a) && (a <=? 31)*) (*datasize =? destsize*)
: M (unit) :=
   (rX ((__id (destsize))) (n)) >>= fun (operand1 : bits destsize) =>
   (rX ((length_mword (operand1))) (m)) >>= fun (operand2 : bits destsize) =>
   let result := Z.mul ((_Int (operand1) (_unsigned))) ((_Int (operand2) (_unsigned))) in
   (wX (d) ((subrange_vec_dec (((to_bits (128) (result))  : bits 128)) (127) (64))))
    : M (unit).

Definition execute_MultiplyAddSubLong
(d : Z) (n : Z) (m : Z) (a : Z) '(destsize : Z) '(datasize : Z) (sub_op : bool) (_unsigned : bool)
(*member_Z_list datasize [8; 16; 32; 64] && member_Z_list destsize [32; 64]*)
(*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
(*(0 <=? a) && (a <=? 31)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   (rX ((length_mword (operand1))) (m)) >>= fun (operand2 : bits datasize) =>
   (rX ((__id (destsize))) (a)) >>= fun (operand3 : bits destsize) =>
   let result : integer := 0 in
   let result : Z :=
     if sub_op then
       Z.sub ((_Int (operand3) (_unsigned)))
         ((Z.mul ((_Int (operand1) (_unsigned))) ((_Int (operand2) (_unsigned)))))
     else
       Z.add ((_Int (operand3) (_unsigned)))
         ((Z.mul ((_Int (operand1) (_unsigned))) ((_Int (operand2) (_unsigned))))) in
   (wX (d) (((to_bits (64) (result))  : bits 64)))
    : M (unit).

Definition execute_MultiplyAddSub
(d : Z) (n : Z) (m : Z) (a : Z) '(destsize : Z) '(datasize : Z) (sub_op : bool)
(*member_Z_list destsize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*) (*(0 <=? a) && (a <=? 31)*)
: M (unit) :=
   (rX ((__id (destsize))) (n)) >>= fun (operand1 : bits destsize) =>
   (rX ((length_mword (operand1))) (m)) >>= fun (operand2 : bits destsize) =>
   (rX ((__id (destsize))) (a)) >>= fun (operand3 : bits destsize) =>
   let result : integer := 0 in
   let result : Z :=
     if sub_op then Z.sub ((UInt (operand3))) ((Z.mul ((UInt (operand1))) ((UInt (operand2)))))
     else Z.add ((UInt (operand3))) ((Z.mul ((UInt (operand1))) ((UInt (operand2))))) in
   (wX (d) (((to_bits ((length_mword (operand3))) (result))  : bits destsize)))
    : M (unit).

Definition execute_MoveWide (d : Z) '(datasize : Z) (imm : mword 16) (pos : Z) (opcode : MoveWideOp)
(*member_Z_list datasize [32; 64] && ((0 <=? pos) && (pos <? (ZEuclid.div datasize 2)))*)
(*(0 <=? d) && (d <=? 31)*)
: M (unit) :=
   let result : bits datasize := Zeros ((__id (datasize))) in
   (if generic_eq (opcode) (MoveWideOp_K) return M (mword datasize) then
      (rX ((length_mword (result))) (d))
       : M (mword datasize)
    else
      let result : bits datasize := Zeros ((length_mword (result))) in
      returnM (result)) >>= fun (result : mword datasize) =>
   let result : bits datasize :=
     update_subrange_vec_dec (result) ((Z.add (pos) (15))) (pos) ((autocast (T := mword)  imm)) in
   let result : mword datasize :=
     if generic_eq (opcode) (MoveWideOp_N) then NOT (result)
     else result in
   (wX (d) (result))
    : M (unit).

Definition execute_MoveSystemRegister
(t : Z) (sys_op0 : Z) (sys_op1 : Z) (sys_op2 : Z) (sys_crn : Z) (sys_crm : Z) (read : bool)
(*(0 <=? t) && (t <=? 31)*) (*0 <=? sys_op0*) (*0 <=? sys_op1*) (*0 <=? sys_op2*) (*0 <=? sys_crn*)
(*0 <=? sys_crm*)
: M (unit) :=
   (if read return M (unit) then
      (System_Get (sys_op0) (sys_op1) (sys_crn) (sys_crm) (sys_op2)) >>= fun (w__0 : mword 64) =>
      (wX (t) (w__0))
       : M (unit)
    else
      (rX (64) (t)) >>= fun (w__1 : mword 64) =>
      (System_Put (sys_op0) (sys_op1) (sys_crn) (sys_crm) (sys_op2) (w__1))
       : M (unit))
    : M (unit).

Definition execute_MoveSystemImmediate (operand : mword 4) (field' : PSTATEField) : M (unit) :=
   (match field' with
    | PSTATEField_SP =>
       (set_PSTATE_SP ((vec_of_bits [access_vec_dec (operand) (0)]  : mword 1)))  : M (unit)
    | PSTATEField_DAIFSet =>
       (get_PSTATE_D (tt)) >>= fun (w__0 : mword 1) =>
       (set_PSTATE_D ((or_vec (w__0) ((vec_of_bits [access_vec_dec (operand) (3)]  : mword 1))))) >>
       (get_PSTATE_A (tt)) >>= fun (w__1 : mword 1) =>
       (set_PSTATE_A ((or_vec (w__1) ((vec_of_bits [access_vec_dec (operand) (2)]  : mword 1))))) >>
       (get_PSTATE_I (tt)) >>= fun (w__2 : mword 1) =>
       (set_PSTATE_I ((or_vec (w__2) ((vec_of_bits [access_vec_dec (operand) (1)]  : mword 1))))) >>
       (get_PSTATE_F (tt)) >>= fun (w__3 : mword 1) =>
       (set_PSTATE_F ((or_vec (w__3) ((vec_of_bits [access_vec_dec (operand) (0)]  : mword 1)))))
        : M (unit)
    | PSTATEField_DAIFClr =>
       (get_PSTATE_D (tt)) >>= fun (w__4 : mword 1) =>
       (set_PSTATE_D
          ((and_vec (w__4) ((vec_of_bits [NOT' ((access_vec_dec (operand) (3)))]  : mword 1))))) >>
       (get_PSTATE_A (tt)) >>= fun (w__5 : mword 1) =>
       (set_PSTATE_A
          ((and_vec (w__5) ((vec_of_bits [NOT' ((access_vec_dec (operand) (2)))]  : mword 1))))) >>
       (get_PSTATE_I (tt)) >>= fun (w__6 : mword 1) =>
       (set_PSTATE_I
          ((and_vec (w__6) ((vec_of_bits [NOT' ((access_vec_dec (operand) (1)))]  : mword 1))))) >>
       (get_PSTATE_F (tt)) >>= fun (w__7 : mword 1) =>
       (set_PSTATE_F
          ((and_vec (w__7) ((vec_of_bits [NOT' ((access_vec_dec (operand) (0)))]  : mword 1)))))
        : M (unit)
    end)
    : M (unit).

Definition execute_LogicalShiftedRegister
(d : Z) (n : Z) (m : Z) '(datasize : Z) (setflags : bool) (op : LogicalOp) (shift_type : ShiftType)
(shift_amount : Z) (invert : bool) (*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
(*(0 <=? shift_amount) && (shift_amount <=? 63)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   (ShiftReg ((length_mword (operand1))) (m) (shift_type) (shift_amount)) >>= fun (operand2 : bits datasize) =>
   let operand2 : mword datasize := if invert then NOT (operand2) else operand2 in
   let result : bits datasize := Zeros ((length_mword (operand2))) in
   let result : mword datasize :=
     match op with
     | LogicalOp_AND => and_vec (operand1) (operand2)
     | LogicalOp_ORR => or_vec (operand1) (operand2)
     | LogicalOp_EOR => xor_vec (operand1) (operand2)
     end in
   (if setflags return M (unit) then
      (wPSTATE_NZCV
         ((concat_vec ((vec_of_bits [access_vec_dec (result) ((Z.sub (datasize) (1)))]  : mword 1))
             ((concat_vec ((vec_of_bits [IsZeroBit (result)]  : mword 1)) ((('b"00")  : mword 2)))))))
       : M (unit)
    else returnM (tt)) >>
   (wX (d) (result))
    : M (unit).

Definition execute_LogicalImmediate
(d : Z) (n : Z) '(datasize : Z) (setflags : bool) (op : LogicalOp) (imm : mword datasize)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   let result : bits datasize := Zeros ((__id (datasize))) in
   (rX ((length_mword (result))) (n)) >>= fun (operand1 : bits datasize) =>
   let operand2 : bits datasize := imm in
   let result : mword datasize :=
     match op with
     | LogicalOp_AND => and_vec (operand1) (operand2)
     | LogicalOp_ORR => or_vec (operand1) (operand2)
     | LogicalOp_EOR => xor_vec (operand1) (operand2)
     end in
   (if setflags return M (unit) then
      (wPSTATE_NZCV
         ((concat_vec
             ((vec_of_bits [access_vec_dec (result) ((Z.sub ((length_mword (result))) (1)))]
                : mword 1))
             ((concat_vec ((vec_of_bits [IsZeroBit (result)]  : mword 1)) ((('b"00")  : mword 2)))))))
       : M (unit)
    else returnM (tt)) >>
   (if andb ((Z.eqb (d) (31))) ((negb (setflags))) return M (unit) then (wSP (result))  : M (unit)
    else (wX (d) (result))  : M (unit))
    : M (unit).

Definition execute_LoadStorePairNonTemp
(wback : bool) (postindex : bool) (n : Z) (t : Z) (t2 : Z) (acctype : AccType) (memop : MemOp)
(scale : Z) '(datasize : Z) (offset : mword 64) (*member_Z_list datasize [8; 16; 32; 64]*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? t) && (t <=? 31)*) (*(0 <=? t2) && (t2 <=? 31)*)
(*0 <=? scale*)
: M (unit) :=
   let address : bits 64 := Zeros (64) in
   let data1 : bits datasize := Zeros ((__id (datasize))) in
   let data2 : bits datasize := Zeros ((__id (datasize))) in
   let dbytes : Z := ZEuclid.div (datasize) (8) in
   let rt_unknown : boolean := false in
   (if andb ((generic_eq (memop) (MemOp_LOAD))) ((Z.eqb (t) (t2))) return M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if Z.eqb (n) (31) return M (mword 64) then (CheckSPAlignment (tt)) >> (rSP (64))  : M (mword 64)
    else (rX (64) (n))  : M (mword 64)) >>= fun (address : mword 64) =>
   let address : mword 64 := if negb (postindex) then add_vec (address) (offset) else address in
   (if generic_eq (memop) (MemOp_STORE) return M (unit) then
      (wMem_Addr (address) ((Z.mul (dbytes) (2))) (acctype) (false))
       : M (unit)
    else returnM (tt)) >>
   (if wback return M (unit) then
      let address' := (if negb (postindex) then address else add_vec (address) (offset))  : bits 64 in
      (if Z.eqb (n) (31) return M (unit) then (wSP (address'))  : M (unit)
       else (wX (n) (address'))  : M (unit))
       : M (unit)
    else returnM (tt)) >>
   (match memop with
    | MemOp_STORE =>
       (if andb (rt_unknown) ((Z.eqb (t) (n))) then
          let data1 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
          returnM (data1)
        else (rX ((__id (datasize))) (t))  : M (mword datasize)) >>= fun (data1 : mword datasize) =>
       (if andb (rt_unknown) ((Z.eqb (t2) (n))) then
          let data2 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
          returnM (data2)
        else (rX ((__id (datasize))) (t2))  : M (mword datasize)) >>= fun (data2 : mword datasize) =>
       (wMem (empty_write_buffer) ((add_vec_int (address) (0))) (dbytes) (acctype)
          ((autocast (T := mword) 
          data1))) >>= fun (write_buffer : write_buffer_type) =>
       (wMem (write_buffer) ((add_vec_int (address) (dbytes))) (dbytes) (acctype)
          ((autocast (T := mword) 
          data2))) >>= fun (w__4 : write_buffer_type) =>
       let write_buffer := w__4  : write_buffer_type in
       (flush_write_buffer (write_buffer))
        : M (unit)
    | MemOp_LOAD =>
       (rMem (empty_read_buffer) ((add_vec_int (address) (0))) (dbytes) (acctype)) >>= fun (read_buffer : read_buffer_type) =>
       (rMem (read_buffer) ((add_vec_int (address) (dbytes))) (dbytes) (acctype)) >>= fun (w__5 : read_buffer_type) =>
       let read_buffer := w__5  : read_buffer_type in
       (autocast_m (T := mword) (flush_read_buffer (read_buffer) ((Z.mul (dbytes) (2))))) >>= fun (read_data : bits (datasize * 2)) =>
       let data1 : bits datasize :=
         autocast (T := mword) (subrange_vec_dec (read_data) ((Z.sub (datasize) (1))) (0)) in
       let data2 : bits datasize :=
         autocast (T := mword) (subrange_vec_dec (read_data) ((Z.sub ((Z.mul (datasize) (2))) (1)))
                                  (datasize)) in
       let '((data1, data2)) :=
         (if rt_unknown then
            let data1 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
            let data2 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
            (data1, data2)
          else (data1, data2))
          : (mword datasize * mword datasize) in
       (wX (t) (data1)) >> (wX (t2) (data2))  : M (unit)
    | _ => exit tt  : M (unit)
    end)
    : M (unit).

Definition execute_LoadStorePair
(wback : bool) (postindex : bool) (n : Z) (t : Z) (t2 : Z) (acctype : AccType) (memop : MemOp)
(_signed : bool) '(datasize : Z) (offset : mword 64) (*member_Z_list datasize [8; 16; 32; 64]*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? t) && (t <=? 31)*) (*(0 <=? t2) && (t2 <=? 31)*)
: M (unit) :=
   let address : bits 64 := Zeros (64) in
   let data1 : bits datasize := Zeros ((__id (datasize))) in
   let data2 : bits datasize := Zeros ((__id (datasize))) in
   let dbytes : Z := ZEuclid.div (datasize) (8) in
   let rt_unknown : boolean := false in
   let wb_unknown : boolean := false in
   (if andb ((generic_eq (memop) (MemOp_LOAD)))
         ((andb (wback) ((andb ((orb ((Z.eqb (t) (n))) ((Z.eqb (t2) (n))))) ((neq_int (n) (31)))))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if andb ((generic_eq (memop) (MemOp_STORE)))
         ((andb (wback) ((andb ((orb ((Z.eqb (t) (n))) ((Z.eqb (t2) (n))))) ((neq_int (n) (31)))))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if andb ((generic_eq (memop) (MemOp_LOAD))) ((Z.eqb (t) (t2))) return M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if Z.eqb (n) (31) return M (mword 64) then (CheckSPAlignment (tt)) >> (rSP (64))  : M (mword 64)
    else (rX (64) (n))  : M (mword 64)) >>= fun (address : mword 64) =>
   let address : mword 64 := if negb (postindex) then add_vec (address) (offset) else address in
   (if generic_eq (memop) (MemOp_STORE) return M (unit) then
      (wMem_Addr (address) ((Z.mul (dbytes) (2))) (acctype) (false))
       : M (unit)
    else returnM (tt)) >>
   (if wback return M (unit) then
      let address' := (if negb (postindex) then address else add_vec (address) (offset))  : bits 64 in
      (if Z.eqb (n) (31) return M (unit) then (wSP (address'))  : M (unit)
       else (wX (n) (address'))  : M (unit))
       : M (unit)
    else returnM (tt)) >>
   (match memop with
    | MemOp_STORE =>
       (if andb (rt_unknown) ((Z.eqb (t) (n))) then
          let data1 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
          returnM (data1)
        else (rX ((__id (datasize))) (t))  : M (mword datasize)) >>= fun (data1 : mword datasize) =>
       (if andb (rt_unknown) ((Z.eqb (t2) (n))) then
          let data2 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
          returnM (data2)
        else (rX ((__id (datasize))) (t2))  : M (mword datasize)) >>= fun (data2 : mword datasize) =>
       (wMem (empty_write_buffer) ((add_vec_int (address) (0))) (dbytes) (acctype)
          ((autocast (T := mword) 
          data1))) >>= fun (write_buffer : write_buffer_type) =>
       (wMem (write_buffer) ((add_vec_int (address) (dbytes))) (dbytes) (acctype)
          ((autocast (T := mword) 
          data2))) >>= fun (w__4 : write_buffer_type) =>
       let write_buffer := w__4  : write_buffer_type in
       (flush_write_buffer (write_buffer))
        : M (unit)
    | MemOp_LOAD =>
       (rMem (empty_read_buffer) ((add_vec_int (address) (0))) (dbytes) (acctype)) >>= fun (read_buffer : read_buffer_type) =>
       (rMem (read_buffer) ((add_vec_int (address) (dbytes))) (dbytes) (acctype)) >>= fun (w__5 : read_buffer_type) =>
       let read_buffer := w__5  : read_buffer_type in
       (autocast_m (T := mword) (flush_read_buffer (read_buffer) ((Z.mul (dbytes) (2))))) >>= fun (read_data : bits (datasize * 2)) =>
       let data1 : bits datasize :=
         autocast (T := mword) (subrange_vec_dec (read_data) ((Z.sub (datasize) (1))) (0)) in
       let data2 : bits datasize :=
         autocast (T := mword) (subrange_vec_dec (read_data) ((Z.sub ((Z.mul (datasize) (2))) (1)))
                                  (datasize)) in
       let '((data1, data2)) :=
         (if rt_unknown then
            let data1 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
            let data2 : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
            (data1, data2)
          else (data1, data2))
          : (mword datasize * mword datasize) in
       (if _signed return M (unit) then
          assert_exp' (Z.ltb ((__id (datasize))) (64)) "armV8.sail:1623.22-1623.23" >>= fun _ =>
          (SignExtend (64) (data1)) >>= fun (w__6 : mword 64) =>
          (wX (t) ((w__6  : bits 64))) >>
          (SignExtend (64) (data2)) >>= fun (w__7 : mword 64) =>
          (wX (t2) ((w__7  : bits 64)))
           : M (unit)
        else (wX (t) (data1)) >> (wX (t2) (data2))  : M (unit))
        : M (unit)
    | _ => exit tt  : M (unit)
    end)
    : M (unit).

Definition execute_LoadStoreAcqExc
(n : Z) (t : Z) (t2 : Z) (s : Z) (acctype : AccType) (excl : bool) (pair' : bool) (memop : MemOp)
(elsize : Z) '(regsize : Z) '(datasize : Z)
(*member_Z_list datasize [8; 16; 32; 64; 128] &&
  (member_Z_list regsize [32; 64] && (elsize <=? datasize))*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? t) && (t <=? 31)*) (*(0 <=? t2) && (t2 <=? 31)*) (*(0 <=? s) && (s <=? 31)*)
: M (unit) :=
   let address : bits 64 := Zeros (64) in
   let data : bits datasize := Zeros (datasize) in
   let dbytes : Z := ZEuclid.div (datasize) (8) in
   let rt_unknown : boolean := false in
   let rn_unknown : boolean := false in
   (if andb ((generic_eq (memop) (MemOp_LOAD))) ((andb (pair') ((Z.eqb (t) (t2)))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if andb ((generic_eq (memop) (MemOp_STORE))) (excl) return M (unit) then
      (if orb ((Z.eqb (s) (t))) ((andb (pair') ((Z.eqb (s) (t2))))) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt)) >>
      (if andb ((Z.eqb (s) (n))) ((neq_int (n) (31))) return M (unit) then
         (UnallocatedEncoding (tt))
          : M (unit)
       else returnM (tt))
       : M (unit)
    else returnM (tt)) >>
   let status : bitU := b0 in
   (if andb ((generic_eq (memop) (MemOp_STORE))) (excl) return M (bitU) then
      (speculate_exclusive_success (tt)) >>= fun (w__0 : bool) =>
      let w__1 : bitU := if w__0 then b0 else b1 in
      let status := w__1  : bitU in
      (wX (s) (((ZeroExtend (32) ((vec_of_bits [status]  : mword 1)))  : bits 32))) >>
      returnM (status)
    else returnM (status)) >>= fun (status : bitU) =>
   (if eq_bit (status) (b1) then returnM (tt)
    else
      (if Z.eqb (n) (31) return M (mword 64) then
         (CheckSPAlignment (tt)) >> (rSP (64))  : M (mword 64)
       else if rn_unknown then
         let address : bits 64 := (UNKNOWN_BITS (64))  : bits 64 in
         returnM (address)
       else (rX (64) (n))  : M (mword 64)) >>= fun (address : mword 64) =>
      (match memop with
       | MemOp_STORE =>
          (wMem_Addr (address) (dbytes) (acctype) (excl)) >>
          (if rt_unknown return M (mword datasize) then
             assert_exp' (andb ((Bool.eqb (pair') (false))) ((Z.ltb (datasize) (128)))) "armV8.sail:918.46-918.47" >>= fun _ =>
             let data : bits datasize := UNKNOWN_BITS (datasize) in
             returnM (data)
           else if pair' return M (mword datasize) then
             let halfsize : Z := ZEuclid.div (datasize) (2) in
             assert_exp' excl "armV8.sail:923.21-923.22" >>= fun _ =>
             assert_exp' (Z.gtb (datasize) (8)) "armV8.sail:924.27-924.28" >>= fun _ =>
             (rX (halfsize) (t)) >>= fun el1 =>
             (rX (halfsize) (t2)) >>= fun el2 =>
             (BigEndian (tt)) >>= fun (w__4 : bool) =>
             let w__5 : mword datasize :=
               if w__4 then autocast (T := mword) (concat_vec (el1) (el2))
               else autocast (T := mword) (concat_vec (el2) (el1)) in
             returnM ((w__5  : mword datasize))
           else
             assert_exp' (Z.ltb (datasize) (128)) "armV8.sail:929.29-929.30" >>= fun _ =>
             (rX ((__id (datasize))) (t))
              : M (mword datasize)) >>= fun (data : mword datasize) =>
          (if excl return M (unit) then
             let status : bitU := b1 in
             (AArch64_ExclusiveMonitorsPass (address) (dbytes)) >>= fun (w__7 : bool) =>
             (if w__7 return M (unit) then
                (wMem_exclusive (empty_write_buffer) (address) (dbytes) (acctype)
                   ((autocast (T := mword) 
                   data))) >>= fun (w__8 : write_buffer_type) =>
                (flush_write_buffer_exclusive (w__8)) >>= fun (w__9 : bool) =>
                let status := (cast_bool_bit (w__9))  : bitU in
                returnM (tt)
              else returnM (tt))
              : M (unit)
           else
             (wMem (empty_write_buffer) (address) (dbytes) (acctype) ((autocast (T := mword)  data))) >>= fun (w__10 : write_buffer_type) =>
             (flush_write_buffer (w__10))
              : M (unit))
           : M (unit)
       | MemOp_LOAD =>
          (if excl return M (unit) then
             (AArch64_SetExclusiveMonitors (address) (dbytes))
              : M (unit)
           else returnM (tt)) >>
          (if pair' return M (unit) then
             assert_exp' excl "armV8.sail:970.21-970.22" >>= fun _ =>
             (if rt_unknown return M (unit) then
                assert_exp' (andb ((Bool.eqb (pair') (false))) ((Z.ltb (datasize) (128)))) "armV8.sail:972.48-972.49" >>= fun _ =>
                (wX (t) (((UNKNOWN_BITS ((__id (datasize))))  : bits datasize)))
                 : M (unit)
              else if Z.eqb (elsize) (32) return M (unit) then
                (rMem_exclusive (empty_read_buffer) (address) (dbytes) (acctype)) >>= fun (w__11 : read_buffer_type) =>
                (flush_read_buffer (w__11) (dbytes)) >>= fun (w__12 : mword (ZEuclid.div datasize 8 * 8)) =>
                let data := (autocast (T := mword)  w__12)  : mword datasize in
                assert_exp' (Z.eqb (datasize) (64)) "armV8.sail:982.31-982.32" >>= fun _ =>
                (BigEndian (tt)) >>= fun (w__13 : bool) =>
                (if w__13 return M (unit) then
                   (wX (t) ((subrange_vec_dec (data) ((Z.sub (datasize) (1))) (elsize)))) >>
                   (wX (t2) ((subrange_vec_dec (data) ((Z.sub (elsize) (1))) (0))))
                    : M (unit)
                 else
                   (wX (t) ((subrange_vec_dec (data) ((Z.sub (elsize) (1))) (0)))) >>
                   (wX (t2) ((subrange_vec_dec (data) ((Z.sub (datasize) (1))) (elsize))))
                    : M (unit))
                 : M (unit)
              else
                (if neq_vec (address) ((Align (address) (dbytes))) return M (unit) then
                   let iswrite : boolean := false in
                   let secondstage : boolean := false in
                   (AArch64_AlignmentFault (acctype) (iswrite) (secondstage)) >>= fun (w__14 : FaultRecord) =>
                   (AArch64_Abort (address) (w__14))
                    : M (unit)
                 else returnM (tt)) >>
                (rMem_exclusive (empty_read_buffer) ((add_vec_int (address) (0))) (8) (acctype)) >>= fun (read_buffer : read_buffer_type) =>
                (rMem_exclusive (read_buffer) ((add_vec_int (address) (8))) (8) (acctype)) >>= fun (w__15 : read_buffer_type) =>
                let read_buffer := w__15  : read_buffer_type in
                (flush_read_buffer (read_buffer) ((Z.mul (8) (2)))) >>= fun (value : bits 128) =>
                (wX (t) ((subrange_vec_dec (value) (63) (0)))) >>
                (wX (t2) ((subrange_vec_dec (value) (127) (64))))
                 : M (unit))
              : M (unit)
           else
             (rMem' (empty_read_buffer) (address) (dbytes) (acctype) (excl)) >>= fun (w__16 : read_buffer_type) =>
             (flush_read_buffer (w__16) (dbytes)) >>= fun (w__17 : mword (ZEuclid.div datasize 8 * 8)) =>
             let data := (autocast (T := mword)  w__17)  : mword datasize in
             assert_exp' (Z.geb (regsize) (datasize)) "armV8.sail:1010.35-1010.36" >>= fun _ =>
             (wX (t) (((ZeroExtend ((__id (regsize))) (data))  : bits regsize)))
              : M (unit))
           : M (unit)
       | _ => exit tt  : M (unit)
       end)
       : M (unit))
    : M (unit).

Definition execute_LoadRegister
(n : Z) (t : Z) (m : Z) (acctype : AccType) (memop : MemOp) (_signed : bool) (wback : bool)
(postindex : bool) (extend_type : ExtendType) (shift : Z) '(regsize : Z) '(datasize : Z)
(*member_Z_list datasize [8; 16; 32; 64] && member_Z_list regsize [32; 64]*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? t) && (t <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
(*(0 <=? shift) && (shift <=? 3)*)
: M (unit) :=
   (ExtendReg (64) (m) (extend_type) (shift)) >>= fun (offset : bits 64) =>
   let address : bits 64 := Zeros (64) in
   let data : bits datasize := Zeros ((__id (datasize))) in
   let wb_unknown : boolean := false in
   let rt_unknown : boolean := false in
   (if andb ((generic_eq (memop) (MemOp_LOAD)))
         ((andb (wback) ((andb ((Z.eqb (n) (t))) ((neq_int (n) (31)))))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if andb ((generic_eq (memop) (MemOp_STORE)))
         ((andb (wback) ((andb ((Z.eqb (n) (t))) ((neq_int (n) (31)))))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if Z.eqb (n) (31) return M (mword 64) then
      (if generic_neq (memop) (MemOp_PREFETCH) return M (unit) then
         (CheckSPAlignment (tt))
          : M (unit)
       else returnM (tt)) >>
      (rSP (64))
       : M (mword 64)
    else (rX (64) (n))  : M (mword 64)) >>= fun (address : mword 64) =>
   let address : mword 64 := if negb (postindex) then add_vec (address) (offset) else address in
   (if generic_eq (memop) (MemOp_STORE) return M (unit) then
      (wMem_Addr (address) ((ZEuclid.div (datasize) (8))) (acctype) (false))
       : M (unit)
    else returnM (tt)) >>
   (if wback return M (unit) then
      let address' := (if negb (postindex) then address else add_vec (address) (offset))  : bits 64 in
      (if Z.eqb (n) (31) return M (unit) then (wSP (address'))  : M (unit)
       else (wX (n) (address'))  : M (unit))
       : M (unit)
    else returnM (tt)) >>
   (match memop with
    | MemOp_STORE =>
       (if rt_unknown then
          let data : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
          returnM (data)
        else (rX ((__id (datasize))) (t))  : M (mword datasize)) >>= fun (data : mword datasize) =>
       (wMem (empty_write_buffer) (address) ((ZEuclid.div (datasize) (8))) (acctype)
          ((autocast (T := mword) 
          data))) >>= fun (w__3 : write_buffer_type) =>
       (flush_write_buffer (w__3))
        : M (unit)
    | MemOp_LOAD =>
       (rMem (empty_read_buffer) (address) ((ZEuclid.div (datasize) (8))) (acctype)) >>= fun (w__4 : read_buffer_type) =>
       (flush_read_buffer (w__4) ((ZEuclid.div (datasize) (8)))) >>= fun (w__5 : mword (ZEuclid.div datasize 8 * 8)) =>
       let data := (autocast (T := mword)  w__5)  : mword datasize in
       (if _signed return M (unit) then
          assert_exp' (Z.gtb ((__id (regsize))) ((__id (datasize)))) "armV8.sail:1425.22-1425.23" >>= fun _ =>
          (SignExtend ((__id (regsize))) (data)) >>= fun (w__6 : mword regsize) =>
          (wX (t) ((w__6  : bits regsize)))
           : M (unit)
        else
          assert_exp' (Z.geb ((__id (regsize))) ((__id (datasize)))) "armV8.sail:1429.23-1429.24" >>= fun _ =>
          (wX (t) (((ZeroExtend ((__id (regsize))) (data))  : bits regsize)))
           : M (unit))
        : M (unit)
    | MemOp_PREFETCH => returnM ((Prefetch (address) (((to_bits (5) (t))  : bits 5))))
    end)
    : M (unit).

Definition execute_LoadLiteral
(t : Z) (memop : MemOp) (_signed : bool) (size : Z) (offset : mword 64) '(datasize : Z)
(*member_Z_list datasize [32; 64] && (member_Z_list size [1; 2; 4; 8] && ((size * 8) =? datasize))*)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (rPC (tt)) >>= fun (w__0 : mword 64) =>
   let address : bits 64 := add_vec (w__0) (offset) in
   let data := Zeros (datasize) in
   (match memop with
    | MemOp_LOAD =>
       (rMem (empty_read_buffer) (address) (size) (AccType_NORMAL)) >>= fun (w__1 : read_buffer_type) =>
       (flush_read_buffer (w__1) (size)) >>= fun data =>
       (if _signed return M (unit) then
          assert_exp' (Z.leb (size) (4)) "armV8.sail:786.25-786.26" >>= fun _ =>
          (SignExtend (64) (data)) >>= fun (w__2 : mword 64) =>
          (wX (t) ((w__2  : bits 64)))
           : M (unit)
        else (wX (t) (data))  : M (unit))
        : M (unit)
    | MemOp_PREFETCH => returnM ((Prefetch (address) (((to_bits (5) (t))  : bits 5))))
    | _ => exit tt  : M (unit)
    end)
    : M (unit).

Definition execute_LoadImmediate
(n : Z) (t : Z) (acctype : AccType) (memop : MemOp) (_signed : bool) (wback : bool)
(postindex : bool) (offset : mword 64) '(regsize : Z) '(datasize : Z)
(*member_Z_list datasize [8; 16; 32; 64] && member_Z_list regsize [32; 64]*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   let address : bits 64 := Zeros (64) in
   let data : bits datasize := Zeros ((__id (datasize))) in
   let wb_unknown : boolean := false in
   let rt_unknown : boolean := false in
   (if andb ((generic_eq (memop) (MemOp_LOAD)))
         ((andb (wback) ((andb ((Z.eqb (n) (t))) ((neq_int (n) (31)))))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if andb ((generic_eq (memop) (MemOp_STORE)))
         ((andb (wback) ((andb ((Z.eqb (n) (t))) ((neq_int (n) (31)))))))
      return
      M (unit) then
      (UnallocatedEncoding (tt))
       : M (unit)
    else returnM (tt)) >>
   (if Z.eqb (n) (31) return M (mword 64) then
      (if generic_neq (memop) (MemOp_PREFETCH) return M (unit) then
         (CheckSPAlignment (tt))
          : M (unit)
       else returnM (tt)) >>
      (rSP (64))
       : M (mword 64)
    else (rX (64) (n))  : M (mword 64)) >>= fun (address : mword 64) =>
   let address : mword 64 := if negb (postindex) then add_vec (address) (offset) else address in
   (if generic_eq (memop) (MemOp_STORE) return M (unit) then
      (wMem_Addr (address) ((ZEuclid.div (datasize) (8))) (acctype) (false))
       : M (unit)
    else returnM (tt)) >>
   (if wback return M (unit) then
      let address' := (if negb (postindex) then address else add_vec (address) (offset))  : bits 64 in
      (if Z.eqb (n) (31) return M (unit) then (wSP (address'))  : M (unit)
       else (wX (n) (address'))  : M (unit))
       : M (unit)
    else returnM (tt)) >>
   (match memop with
    | MemOp_STORE =>
       (if rt_unknown then
          let data : bits datasize := (UNKNOWN_BITS ((__id (datasize))))  : bits datasize in
          returnM (data)
        else (rX ((__id (datasize))) (t))  : M (mword datasize)) >>= fun (data : mword datasize) =>
       (wMem (empty_write_buffer) (address) ((ZEuclid.div (datasize) (8))) (acctype)
          ((autocast (T := mword) 
          data))) >>= fun (w__3 : write_buffer_type) =>
       (flush_write_buffer (w__3))
        : M (unit)
    | MemOp_LOAD =>
       (rMem (empty_read_buffer) (address) ((ZEuclid.div (datasize) (8))) (acctype)) >>= fun (w__4 : read_buffer_type) =>
       (flush_read_buffer (w__4) ((ZEuclid.div (datasize) (8)))) >>= fun (w__5 : mword (ZEuclid.div datasize 8 * 8)) =>
       let data := (autocast (T := mword)  w__5)  : mword datasize in
       (if _signed return M (unit) then
          assert_exp' (Z.gtb ((__id (regsize))) ((__id (datasize)))) "armV8.sail:1258.22-1258.23" >>= fun _ =>
          (SignExtend ((__id (regsize))) (data)) >>= fun (w__6 : mword regsize) =>
          (wX (t) ((w__6  : bits regsize)))
           : M (unit)
        else
          assert_exp' (Z.geb ((__id (regsize))) ((__id (datasize)))) "armV8.sail:1262.23-1262.24" >>= fun _ =>
          (wX (t) (((ZeroExtend ((__id (regsize))) (data))  : bits regsize)))
           : M (unit))
        : M (unit)
    | MemOp_PREFETCH => returnM ((Prefetch (address) (((to_bits (5) (t))  : bits 5))))
    end)
    : M (unit).

Definition execute_InstructionCache (t : Z) (ic_op : ICOp) (*(0 <=? t) && (t <=? 31)*) : M (unit) :=
   (rX (64) (t)) >>= fun (addr : bits 64) =>
   (match ic_op with
    | IALLUIS => (not_implemented ("IC IALLUIS"))  : M (unit)
    | IALLU => (not_implemented ("IC IALLU"))  : M (unit)
    | IVAU => write_reg instruction_cache_operation_IVAU addr  : M (unit)
    end)
    : M (unit).

Definition execute_ImplementationDefinedThreadStart '(tt : unit) : unit := info ("thread start").

Definition execute_ImplementationDefinedTestBeginEnd (isEnd : bool) : unit :=
   if isEnd then info ("test ends") else info ("test begins").

Definition execute_ImplementationDefinedStopFetching '(tt : unit) : unit :=
   info ("stop fetching instructions").

Definition execute_Hint (op : SystemHintOp) : M (unit) :=
   (match op with
    | SystemHintOp_YIELD => returnM ((Hint_Yield (tt)))
    | SystemHintOp_WFE => returnM (tt)
    | SystemHintOp_WFI =>
       (InterruptPending (tt)) >>= fun (w__0 : bool) =>
       (if negb (w__0) return M (unit) then
          (get_PSTATE_EL (tt)) >>= fun (w__1 : mword 2) =>
          (if eq_vec (w__1) (EL0) return M (unit) then
             (AArch64_CheckForWFxTrap (EL1) (false))
              : M (unit)
           else returnM (tt)) >>
          (and_boolM ((HaveEL (EL2))  : M (bool))
             ((and_boolM
                 ((IsSecure (tt)) >>= fun (w__3 : bool) => returnM (((negb (w__3))  : bool)))
                 ((or_boolM
                     ((get_PSTATE_EL (tt)) >>= fun (w__4 : mword 2) =>
                      returnM (((eq_vec (w__4) (EL0))  : bool)))
                     ((get_PSTATE_EL (tt)) >>= fun (w__5 : mword 2) =>
                      returnM (((eq_vec (w__5) (EL1))  : bool))))
                  : M (bool)))
              : M (bool))) >>= fun (w__8 : bool) =>
          (if w__8 return M (unit) then (AArch64_CheckForWFxTrap (EL2) (false))  : M (unit)
           else returnM (tt)) >>
          (and_boolM ((HaveEL (EL3))  : M (bool))
             ((get_PSTATE_EL (tt)) >>= fun (w__10 : mword 2) =>
              returnM (((neq_vec (w__10) (EL3))  : bool)))) >>= fun (w__11 : bool) =>
          (if w__11 return M (unit) then (AArch64_CheckForWFxTrap (EL3) (false))  : M (unit)
           else returnM (tt)) >>
          (WaitForInterrupt (tt))
           : M (unit)
        else returnM (tt))
        : M (unit)
    | SystemHintOp_SEV => returnM (tt)
    | SystemHintOp_SEVL => returnM (tt)
    | _ => returnM (tt)
    end)
    : M (unit).

Definition execute_GenerateExceptionEL3 (imm : mword 16) : M (unit) :=
   (or_boolM ((HaveEL (EL3)) >>= fun (w__0 : bool) => returnM (((negb (w__0))  : bool)))
      ((get_PSTATE_EL (tt)) >>= fun (w__1 : mword 2) => returnM (((eq_vec (w__1) (EL0))  : bool)))) >>= fun (w__2 : bool) =>
   (if w__2 return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
    else returnM (tt)) >>
   (AArch64_CheckForSMCTrap (imm)) >>
   ((read_reg SCR_EL3)  : M (mword 32)) >>= fun (w__3 : mword 32) =>
   (if eq_vec ((_get_SCRType_SMD (w__3))) ((('b"1")  : mword 1)) return M (unit) then
      (AArch64_UndefinedFault (tt))
       : M (unit)
    else (AArch64_CallSecureMonitor (imm))  : M (unit))
    : M (unit).

Definition execute_GenerateExceptionEL2 (imm : mword 16) : M (unit) :=
   (or_boolM ((HaveEL (EL2)) >>= fun (w__0 : bool) => returnM (((negb (w__0))  : bool)))
      ((or_boolM
          ((get_PSTATE_EL (tt)) >>= fun (w__1 : mword 2) =>
           returnM (((eq_vec (w__1) (EL0))  : bool)))
          ((and_boolM
              ((get_PSTATE_EL (tt)) >>= fun (w__2 : mword 2) =>
               returnM (((eq_vec (w__2) (EL1))  : bool))) ((IsSecure (tt))  : M (bool)))
           : M (bool)))
       : M (bool))) >>= fun (w__6 : bool) =>
   (if w__6 return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
    else returnM (tt)) >>
   (HaveEL (EL3)) >>= fun (w__7 : bool) =>
   (if w__7 return M (bitU) then
      ((read_reg SCR_EL3)  : M (mword 32)) >>= fun (w__8 : mword 32) =>
      returnM ((access_vec_dec ((_get_SCRType_HCE (w__8))) (0)))
    else
      ((read_reg HCR_EL2)  : M (mword 64)) >>= fun (w__9 : mword 64) =>
      returnM ((NOT' ((access_vec_dec ((_get_HCR_type_HCD (w__9))) (0)))))) >>= fun (hvc_enable : bitU) =>
   (if eq_bit (hvc_enable) (b0) return M (unit) then (AArch64_UndefinedFault (tt))  : M (unit)
    else (AArch64_CallHypervisor (imm))  : M (unit))
    : M (unit).

Definition execute_GenerateExceptionEL1 (imm : mword 16) : M (unit) :=
   (AArch64_CallSupervisor (imm))  : M (unit).

Definition execute_ExtractRegister (d : Z) (n : Z) (m : Z) '(datasize : Z) (lsb : Z)
(*member_Z_list datasize [32; 64] && ((0 <=? lsb) && (lsb <=? datasize))*)
(*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   let result : bits datasize := Zeros ((__id (datasize))) in
   (rX ((length_mword (result))) (n)) >>= fun (operand1 : bits datasize) =>
   (rX ((length_mword (result))) (m)) >>= fun (operand2 : bits datasize) =>
   let concat : bits (2 * datasize) := autocast (T := mword) (concat_vec (operand1) (operand2)) in
   let result : bits datasize :=
     autocast (T := mword) (subrange_vec_dec (concat) ((Z.sub ((Z.add (lsb) (datasize))) (1))) (lsb)) in
   (wX (d) (result))
    : M (unit).

Definition execute_ExternalDebugBreakpoint '(tt : unit) : M (unit) :=
   (Halt (DebugHalt_HaltInstruction))  : M (unit).

Definition execute_ExceptionReturn '(tt : unit) : M (unit) :=
   (rELR' (tt)) >>= fun (w__0 : mword 64) =>
   (rSPSR (tt)) >>= fun (w__1 : mword 32) => (AArch64_ExceptionReturn (w__0) (w__1))  : M (unit).

Definition execute_Division (d : Z) (n : Z) (m : Z) '(datasize : Z) (_unsigned : bool)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   (rX ((length_mword (operand1))) (m)) >>= fun (operand2 : bits datasize) =>
   let result : integer := 0 in
   let result : Z :=
     if IsZero (operand2) then 0
     else Z.quot ((_Int (operand1) (_unsigned))) ((_Int (operand2) (_unsigned))) in
   (wX (d) (((to_bits ((length_mword (operand2))) (result))  : bits datasize)))
    : M (unit).

Definition execute_DebugSwitchToExceptionLevel (target_level : mword 2) : M (unit) :=
   (DCPSInstruction (target_level))  : M (unit).

Definition execute_DebugRestorePState '(tt : unit) : M (unit) := (DRPSInstruction (tt))  : M (unit).

Definition execute_DebugBreakpoint (comment : mword 16) : M (unit) :=
   (AArch64_SoftwareBreakpoint (comment))  : M (unit).

Definition execute_DataCache (t : Z) (dc_op : DCOp) (*(0 <=? t) && (t <=? 31)*) : M (unit) :=
   (rX (64) (t)) >>= fun (addr : bits 64) =>
   (match dc_op with
    | IVAC => (not_implemented ("DC IVAC"))  : M (unit)
    | ISW => (not_implemented ("DC ISW"))  : M (unit)
    | CSW => (not_implemented ("DC CSW"))  : M (unit)
    | CISW => (not_implemented ("DC CISW"))  : M (unit)
    | ZVA => (not_implemented ("DC ZVA"))  : M (unit)
    | CVAC => (not_implemented ("DC CVAC"))  : M (unit)
    | CVAU => write_reg data_cache_operation_CVAU addr  : M (unit)
    | CIVAC => (not_implemented ("DC CIVAC"))  : M (unit)
    end)
    : M (unit).

Definition execute_CountLeading (d : Z) (n : Z) '(datasize : Z) (opcode : CountOp)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   let result : integer := 0 in
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   let result : Z :=
     if generic_eq (opcode) (CountOp_CLZ) then CountLeadingZeroBits (operand1)
     else CountLeadingSignBits (operand1) in
   (wX (d) (((to_bits ((length_mword (operand1))) (result))  : bits datasize)))
    : M (unit).

Definition execute_ConditionalSelect
(d : Z) (n : Z) (m : Z) '(datasize : Z) (condition : mword 4) (else_inv : bool) (else_inc : bool)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   let result : bits datasize := Zeros ((__id (datasize))) in
   (rX ((length_mword (result))) (n)) >>= fun (operand1 : bits datasize) =>
   (rX ((length_mword (result))) (m)) >>= fun (operand2 : bits datasize) =>
   (ConditionHolds (condition)) >>= fun (w__0 : bool) =>
   let result : mword datasize :=
     if w__0 then operand1
     else
       let result : bits datasize := operand2 in
       let result : mword datasize := if else_inv then NOT (result) else result in
       if else_inc then add_vec_int (result) (1)
       else result in
   (wX (d) (result))
    : M (unit).

Definition execute_ConditionalCompareRegister
(n : Z) (m : Z) '(datasize : Z) (sub_op : bool) (condition : mword 4) (flags : mword 4)
(*member_Z_list datasize [32; 64]*) (*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   (rX ((length_mword (operand1))) (m)) >>= fun (operand2 : bits datasize) =>
   let carry_in : bitU := b0 in
   let flags' : bits 4 := flags in
   (ConditionHolds (condition)) >>= fun (w__0 : bool) =>
   let flags' : mword 4 :=
     if w__0 then
       let '((carry_in, operand2)) :=
         (if sub_op then
            let operand2 : bits datasize := NOT (operand2) in
            let carry_in : bitU := b1 in
            (carry_in, operand2)
          else (carry_in, operand2))
          : (bitU * mword datasize) in
       let '((_, nzcv)) := AddWithCarry (operand1) (operand2) (carry_in) in
       nzcv
     else flags' in
   (wPSTATE_NZCV (flags'))
    : M (unit).

Definition execute_ConditionalCompareImmediate
(n : Z) '(datasize : Z) (sub_op : bool) (condition : mword 4) (flags : mword 4)
(imm : mword datasize) (*member_Z_list datasize [32; 64]*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   let operand2 : bits datasize := imm in
   let carry_in : bitU := b0 in
   let flags' : bits 4 := flags in
   (ConditionHolds (condition)) >>= fun (w__0 : bool) =>
   let flags' : mword 4 :=
     if w__0 then
       let '((carry_in, operand2)) :=
         (if sub_op then
            let operand2 : bits datasize := NOT (operand2) in
            let carry_in : bitU := b1 in
            (carry_in, operand2)
          else (carry_in, operand2))
          : (bitU * mword datasize) in
       let '((_, nzcv)) := AddWithCarry (operand1) (operand2) (carry_in) in
       nzcv
     else flags' in
   (wPSTATE_NZCV (flags'))
    : M (unit).

Definition execute_CompareAndBranch (t : Z) '(datasize : Z) (iszero : bool) (offset : mword 64)
(*member_Z_list datasize [32; 64]*) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (rX (datasize) (t)) >>= fun (operand1 : bits datasize) =>
   (if Bool.eqb ((IsZero (operand1))) (iszero) return M (unit) then
      (rPC (tt)) >>= fun (w__0 : mword 64) =>
      (BranchTo ((add_vec (w__0) (offset))) (BranchType_JMP))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition execute_ClearExclusiveMonitor (imm : Z) (*0 <=? imm*) : unit :=
   ClearExclusiveLocal ((ProcessorID (tt))).

Definition execute_CRC (d : Z) (n : Z) (m : Z) '(size : Z) (crc32c : bool)
(*member_Z_list size [8; 16; 32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (if negb ((HaveCRCExt (tt))) return M (unit) then (UnallocatedEncoding (tt))  : M (unit)
    else returnM (tt)) >>
   (rX (32) (n)) >>= fun (acc : bits 32) =>
   (rX ((__id (size))) (m)) >>= fun (_val : bits size) =>
   let poly : bits 32 := if crc32c then (Ox"1EDC6F41")  : mword 32 else (Ox"04C11DB7")  : mword 32 in
   let tempacc : bits (32 + size) :=
     concat_vec ((BitReverse (acc))) (((Zeros ((__id (size))))  : bits size)) in
   let tempval : bits (size + 32) := concat_vec ((BitReverse (_val))) (((Zeros (32))  : bits 32)) in
   (Poly32Mod2 ((xor_vec (tempacc) ((autocast (T := mword)  tempval)))) (poly)) >>= fun (w__0 : mword 32) =>
   (wX (d) ((BitReverse (w__0))))
    : M (unit).

Definition execute_BranchRegister (n : Z) (branch_type : BranchType) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (if generic_eq (branch_type) (BranchType_CALL) return M (unit) then
      (rPC (tt)) >>= fun (w__0 : mword 64) => (wX (30) ((add_vec_int (w__0) (4))))  : M (unit)
    else returnM (tt)) >>
   (rX (64) (n)) >>= fun (target : bits 64) => (BranchTo (target) (branch_type))  : M (unit).

Definition execute_BranchImmediate (branch_type : BranchType) (offset : mword 64) : M (unit) :=
   (if generic_eq (branch_type) (BranchType_CALL) return M (unit) then
      (rPC (tt)) >>= fun (w__0 : mword 64) => (wX (30) ((add_vec_int (w__0) (4))))  : M (unit)
    else returnM (tt)) >>
   (rPC (tt)) >>= fun (w__1 : mword 64) =>
   (BranchTo ((add_vec (w__1) (offset))) (branch_type))
    : M (unit).

Definition execute_BranchConditional (offset : mword 64) (condition : mword 4) : M (unit) :=
   (ConditionHolds (condition)) >>= fun (w__0 : bool) =>
   (if w__0 return M (unit) then
      (rPC (tt)) >>= fun (w__1 : mword 64) =>
      (BranchTo ((add_vec (w__1) (offset))) (BranchType_JMP))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition execute_BitfieldMove
(d : Z) (n : Z) '(datasize : Z) (inzero : bool) (extend : bool) (R' : Z) (S' : Z)
(wmask : mword datasize) (tmask : mword datasize)
(*member_Z_list datasize [32; 64] &&
  ((0 <=? R') && (R' <? datasize) && ((0 <=? S') && (S' <? datasize)))*) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (if inzero then returnM ((Zeros ((__id (datasize)))))
    else (rX ((__id (datasize))) (d))  : M (mword datasize)) >>= fun (dst : bits datasize) =>
   (rX ((__id (datasize))) (n)) >>= fun (src : bits datasize) =>
   let bot : bits datasize :=
     or_vec ((and_vec (dst) ((NOT (wmask))))) ((and_vec ((ROR (src) (R'))) (wmask))) in
   (if extend return M (mword datasize) then
      (Replicate ((length_mword (bot))) ((vec_of_bits [access_vec_dec (src) (S')]  : mword 1)))
       : M (mword datasize)
    else returnM (dst)) >>= fun (top : bits datasize) =>
   (wX (d) ((or_vec ((and_vec (top) ((NOT (tmask))))) ((and_vec (bot) (tmask))))))
    : M (unit).

Definition execute_Barrier (op : MemBarrierOp) (domain : MBReqDomain) (types : MBReqTypes)
: M (unit) :=
   (match op with
    | MemBarrierOp_DSB => (DataSynchronizationBarrier (domain) (types))  : M (unit)
    | MemBarrierOp_DMB => (DataMemoryBarrier (domain) (types))  : M (unit)
    | MemBarrierOp_ISB => (InstructionSynchronizationBarrier (tt))  : M (unit)
    end)
    : M (unit).

Definition execute_Address (d : Z) (page : bool) (imm : mword 64) (*(0 <=? d) && (d <=? 31)*)
: M (unit) :=
   (rPC (tt)) >>= fun (base : bits 64) =>
   let base : mword 64 :=
     if page then update_subrange_vec_dec (base) (11) (0) (((Zeros (12))  : bits 12))
     else base in
   (wX (d) ((add_vec (base) (imm))))
    : M (unit).

Definition execute_AddSubShiftedRegister
(d : Z) (n : Z) (m : Z) '(datasize : Z) (sub_op : bool) (setflags : bool) (shift_type : ShiftType)
(shift_amount : Z) (*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
(*(0 <=? shift_amount) && (shift_amount <=? 63)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   (ShiftReg ((length_mword (operand1))) (m) (shift_type) (shift_amount)) >>= fun (operand2 : bits datasize) =>
   let carry_in : bitU := b0 in
   let '((carry_in, operand2)) :=
     (if sub_op then
        let operand2 : bits datasize := NOT (operand2) in
        let carry_in : bitU := b1 in
        (carry_in, operand2)
      else
        let carry_in : bitU := b0 in
        (carry_in, operand2))
      : (bitU * mword datasize) in
   let '((result, nzcv)) := AddWithCarry (operand1) (operand2) (carry_in) in
   (if setflags return M (unit) then (wPSTATE_NZCV (nzcv))  : M (unit)
    else returnM (tt)) >>
   (wX (d) (result))
    : M (unit).

Definition execute_AddSubImmediate
(d : Z) (n : Z) '(datasize : Z) (sub_op : bool) (setflags : bool) (imm : mword datasize)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (if Z.eqb (n) (31) return M (mword datasize) then (rSP ((__id (datasize))))  : M (mword datasize)
    else (rX ((__id (datasize))) (n))  : M (mword datasize)) >>= fun (operand1 : bits datasize) =>
   let operand2 : bits datasize := imm in
   let carry_in : bitU := b0 in
   let '((carry_in, operand2)) :=
     (if sub_op then
        let operand2 : bits datasize := NOT (operand2) in
        let carry_in : bitU := b1 in
        (carry_in, operand2)
      else
        let carry_in : bitU := b0 in
        (carry_in, operand2))
      : (bitU * mword datasize) in
   let '((result, nzcv)) := AddWithCarry (operand1) (operand2) (carry_in) in
   (if setflags return M (unit) then (wPSTATE_NZCV (nzcv))  : M (unit)
    else returnM (tt)) >>
   (if andb ((Z.eqb (d) (31))) ((negb (setflags))) return M (unit) then (wSP (result))  : M (unit)
    else (wX (d) (result))  : M (unit))
    : M (unit).

Definition execute_AddSubExtendRegister
(d : Z) (n : Z) (m : Z) '(datasize : Z) (sub_op : bool) (setflags : bool) (extend_type : ExtendType)
(shift : Z) (*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*) (*(0 <=? shift) && (shift <=? 7)*)
: M (unit) :=
   (if Z.eqb (n) (31) return M (mword datasize) then (rSP ((__id (datasize))))  : M (mword datasize)
    else (rX ((__id (datasize))) (n))  : M (mword datasize)) >>= fun (operand1 : bits datasize) =>
   (ExtendReg ((length_mword (operand1))) (m) (extend_type) (shift)) >>= fun (operand2 : bits datasize) =>
   let carry_in : bitU := b0 in
   let '((carry_in, operand2)) :=
     (if sub_op then
        let operand2 : bits datasize := NOT (operand2) in
        let carry_in : bitU := b1 in
        (carry_in, operand2)
      else
        let carry_in : bitU := b0 in
        (carry_in, operand2))
      : (bitU * mword datasize) in
   let '((result, nzcv)) := AddWithCarry (operand1) (operand2) (carry_in) in
   (if setflags return M (unit) then (wPSTATE_NZCV (nzcv))  : M (unit)
    else returnM (tt)) >>
   (if andb ((Z.eqb (d) (31))) ((negb (setflags))) return M (unit) then (wSP (result))  : M (unit)
    else (wX (d) (result))  : M (unit))
    : M (unit).

Definition execute_AddSubCarry
(d : Z) (n : Z) (m : Z) '(datasize : Z) (sub_op : bool) (setflags : bool)
(*member_Z_list datasize [32; 64]*) (*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
(*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (rX ((__id (datasize))) (n)) >>= fun (operand1 : bits datasize) =>
   (rX ((length_mword (operand1))) (m)) >>= fun (operand2 : bits datasize) =>
   let operand2 : mword datasize := if sub_op then NOT (operand2) else operand2 in
   (get_PSTATE_C (tt)) >>= fun (w__0 : mword 1) =>
   let '((result, nzcv)) := AddWithCarry (operand1) (operand2) ((access_vec_dec (w__0) (0))) in
   (if setflags return M (unit) then (wPSTATE_NZCV (nzcv))  : M (unit)
    else returnM (tt)) >>
   (wX (d) (result))
    : M (unit).

Definition execute (merge_var : ast) : M (unit) :=
   (match merge_var with
    | TMStart t => (execute_TMStart (t))  : M (unit)
    | TMCommit arg0 => (execute_TMCommit (arg0))  : M (unit)
    | TMTest arg0 => (execute_TMTest (arg0))  : M (unit)
    | TMAbort (retry, reason) => (execute_TMAbort (retry) (reason))  : M (unit)
    | CompareAndBranch (t, arg1, iszero, offset) =>
       (execute_CompareAndBranch (t) (arg1) (iszero) (offset))  : M (unit)
    | BranchConditional (offset, condition) =>
       (execute_BranchConditional (offset) (condition))  : M (unit)
    | GenerateExceptionEL1 imm => (execute_GenerateExceptionEL1 (imm))  : M (unit)
    | GenerateExceptionEL2 imm => (execute_GenerateExceptionEL2 (imm))  : M (unit)
    | GenerateExceptionEL3 imm => (execute_GenerateExceptionEL3 (imm))  : M (unit)
    | DebugBreakpoint comment => (execute_DebugBreakpoint (comment))  : M (unit)
    | ExternalDebugBreakpoint arg0 => (execute_ExternalDebugBreakpoint (arg0))  : M (unit)
    | DebugSwitchToExceptionLevel target_level =>
       (execute_DebugSwitchToExceptionLevel (target_level))  : M (unit)
    | MoveSystemImmediate (operand, field') =>
       (execute_MoveSystemImmediate (operand) (field'))  : M (unit)
    | Hint op => (execute_Hint (op))  : M (unit)
    | ClearExclusiveMonitor imm => returnM ((execute_ClearExclusiveMonitor (imm)))
    | Barrier (op, domain, types) => (execute_Barrier (op) (domain) (types))  : M (unit)
    | DataCache (t, dc_op) => (execute_DataCache (t) (dc_op))  : M (unit)
    | InstructionCache (t, ic_op) => (execute_InstructionCache (t) (ic_op))  : M (unit)
    | System (t, sys_op0, sys_op1, sys_op2, sys_crn, sys_crm, has_result) =>
       (execute_System (t) (sys_op0) (sys_op1) (sys_op2) (sys_crn) (sys_crm) (has_result))
        : M (unit)
    | MoveSystemRegister (t, sys_op0, sys_op1, sys_op2, sys_crn, sys_crm, read) =>
       (execute_MoveSystemRegister (t) (sys_op0) (sys_op1) (sys_op2) (sys_crn) (sys_crm) (read))
        : M (unit)
    | ImplementationDefinedTestBeginEnd isEnd =>
       returnM ((execute_ImplementationDefinedTestBeginEnd (isEnd)))
    | ImplementationDefinedStopFetching arg0 =>
       returnM ((execute_ImplementationDefinedStopFetching (arg0)))
    | ImplementationDefinedThreadStart arg0 =>
       returnM ((execute_ImplementationDefinedThreadStart (arg0)))
    | TestBitAndBranch (arg0, arg1, bit_pos, bit_val, offset) =>
       (execute_TestBitAndBranch (arg0) (arg1) (bit_pos) (bit_val) (offset))  : M (unit)
    | BranchImmediate (branch_type, offset) =>
       (execute_BranchImmediate (branch_type) (offset))  : M (unit)
    | BranchRegister (n, branch_type) => (execute_BranchRegister (n) (branch_type))  : M (unit)
    | ExceptionReturn arg0 => (execute_ExceptionReturn (arg0))  : M (unit)
    | DebugRestorePState arg0 => (execute_DebugRestorePState (arg0))  : M (unit)
    | LoadLiteral (t, memop, _signed, size, offset, arg5) =>
       (execute_LoadLiteral (t) (memop) (_signed) (size) (offset) (arg5))  : M (unit)
    | LoadStoreAcqExc (n, t, t2, s, acctype, excl, pair', memop, elsize, arg9, arg10) =>
       (execute_LoadStoreAcqExc (n) (t) (t2) (s) (acctype) (excl) (pair') (memop) (elsize) (arg9)
          (arg10))
        : M (unit)
    | LoadStorePairNonTemp (wback, postindex, n, t, t2, acctype, memop, scale, arg8, offset) =>
       (execute_LoadStorePairNonTemp (wback) (postindex) (n) (t) (t2) (acctype) (memop) (scale)
          (arg8) (offset))
        : M (unit)
    | LoadImmediate (n, t, acctype, memop, _signed, wback, postindex, offset, arg8, arg9) =>
       (execute_LoadImmediate (n) (t) (acctype) (memop) (_signed) (wback) (postindex) (offset)
          (arg8) (arg9))
        : M (unit)
    | LoadRegister
      (n, t, m, acctype, memop, _signed, wback, postindex, extend_type, shift, arg10, arg11) =>
       (execute_LoadRegister (n) (t) (m) (acctype) (memop) (_signed) (wback) (postindex)
          (extend_type) (shift) (arg10) (arg11))
        : M (unit)
    | LoadStorePair (wback, postindex, n, t, t2, acctype, memop, _signed, arg8, offset) =>
       (execute_LoadStorePair (wback) (postindex) (n) (t) (t2) (acctype) (memop) (_signed) (arg8)
          (offset))
        : M (unit)
    | AddSubImmediate (@existT _ _ arg2 (d, n, _, sub_op, setflags, imm)) =>
       (execute_AddSubImmediate (d) (n) (arg2) (sub_op) (setflags) (imm))  : M (unit)
    | BitfieldMove (@existT _ _ arg2 (d, n, _, inzero, extend, R', S', wmask, tmask)) =>
       (execute_BitfieldMove (d) (n) (arg2) (inzero) (extend) (R') (S') (wmask) (tmask))  : M (unit)
    | ExtractRegister (d, n, m, arg3, lsb) =>
       (execute_ExtractRegister (d) (n) (m) (arg3) (lsb))  : M (unit)
    | LogicalImmediate (@existT _ _ arg2 (d, n, _, setflags, op, imm)) =>
       (execute_LogicalImmediate (d) (n) (arg2) (setflags) (op) (imm))  : M (unit)
    | MoveWide (d, arg1, imm, pos, opcode) =>
       (execute_MoveWide (d) (arg1) (imm) (pos) (opcode))  : M (unit)
    | Address (d, page, imm) => (execute_Address (d) (page) (imm))  : M (unit)
    | AddSubExtendRegister (d, n, m, arg3, sub_op, setflags, extend_type, shift) =>
       (execute_AddSubExtendRegister (d) (n) (m) (arg3) (sub_op) (setflags) (extend_type) (shift))
        : M (unit)
    | AddSubShiftedRegister (d, n, m, arg3, sub_op, setflags, shift_type, shift_amount) =>
       (execute_AddSubShiftedRegister (d) (n) (m) (arg3) (sub_op) (setflags) (shift_type)
          (shift_amount))
        : M (unit)
    | AddSubCarry (d, n, m, arg3, sub_op, setflags) =>
       (execute_AddSubCarry (d) (n) (m) (arg3) (sub_op) (setflags))  : M (unit)
    | ConditionalCompareImmediate (@existT _ _ arg1 (n, _, sub_op, condition, flags, imm)) =>
       (execute_ConditionalCompareImmediate (n) (arg1) (sub_op) (condition) (flags) (imm))
        : M (unit)
    | ConditionalCompareRegister (n, m, arg2, sub_op, condition, flags) =>
       (execute_ConditionalCompareRegister (n) (m) (arg2) (sub_op) (condition) (flags))  : M (unit)
    | ConditionalSelect (d, n, m, arg3, condition, else_inv, else_inc) =>
       (execute_ConditionalSelect (d) (n) (m) (arg3) (condition) (else_inv) (else_inc))  : M (unit)
    | Reverse (d, n, arg2, op) => (execute_Reverse (d) (n) (arg2) (op))  : M (unit)
    | CountLeading (d, n, arg2, opcode) =>
       (execute_CountLeading (d) (n) (arg2) (opcode))  : M (unit)
    | Division (d, n, m, arg3, _unsigned) =>
       (execute_Division (d) (n) (m) (arg3) (_unsigned))  : M (unit)
    | Shift (d, n, m, arg3, shift_type) =>
       (execute_Shift (d) (n) (m) (arg3) (shift_type))  : M (unit)
    | CRC (d, n, m, arg3, crc32c) => (execute_CRC (d) (n) (m) (arg3) (crc32c))  : M (unit)
    | MultiplyAddSub (d, n, m, a, arg4, arg5, sub_op) =>
       (execute_MultiplyAddSub (d) (n) (m) (a) (arg4) (arg5) (sub_op))  : M (unit)
    | MultiplyAddSubLong (d, n, m, a, arg4, arg5, sub_op, _unsigned) =>
       (execute_MultiplyAddSubLong (d) (n) (m) (a) (arg4) (arg5) (sub_op) (_unsigned))  : M (unit)
    | MultiplyHigh (d, n, m, a, arg4, datasize, _unsigned) =>
       (execute_MultiplyHigh (d) (n) (m) (a) (arg4) (datasize) (_unsigned))  : M (unit)
    | LogicalShiftedRegister (d, n, m, arg3, setflags, op, shift_type, shift_amount, invert) =>
       (execute_LogicalShiftedRegister (d) (n) (m) (arg3) (setflags) (op) (shift_type)
          (shift_amount) (invert))
        : M (unit)
    | _ =>
       assert_exp' false "Pattern match failure at armV8.sail:2396.0-2414.1" >>= fun _ => exit tt
    end)
    : M (unit).

Definition decodeDataSIMDFPoint1 (machineCode : mword 32) : M (option ast) :=
   (not_implemented ("decodeDataSIMDFPoint1")) >> returnM ((Some ((Unallocated (tt))))).

Definition decodeDataSIMDFPoint2 (machineCode : mword 32) : M (option ast) :=
   (not_implemented ("decodeDataSIMDFPoint2")) >> returnM ((Some ((Unallocated (tt))))).

Definition decodeDataRegister (machineCode : mword 32) : M (option ast) :=
   let v__634 := machineCode in
   (if eq_vec ((subrange_vec_dec (v__634) (28) (24))) ((('b"01010")  : mword 5))
      return
      M (option ast) then
      (decodeLogicalShiftedRegister (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__634) (28) (24))) ((('b"01011")  : mword 5))))
              ((eq_vec ((subrange_vec_dec (v__634) (21) (21))) ((('b"0")  : mword 1))))
      return
      M (option ast) then
      (decodeAddSubtractShiftedRegister (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__634) (28) (24))) ((('b"01011")  : mword 5))))
              ((eq_vec ((subrange_vec_dec (v__634) (21) (21))) ((('b"1")  : mword 1))))
      return
      M (option ast) then
      (decodeAddSubtractExtendedRegister (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__634) (28) (21))) (((Ox"D0")  : mword 8))
      return
      M (option ast) then
      (decodeAddSubtractWithCarry (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__634) (28) (21))) (((Ox"D2")  : mword 8))))
              ((eq_vec ((subrange_vec_dec (v__634) (11) (11))) ((('b"0")  : mword 1))))
      return
      M (option ast) then
      (decodeConditionalCompareRegister (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__634) (28) (21))) (((Ox"D2")  : mword 8))))
              ((eq_vec ((subrange_vec_dec (v__634) (11) (11))) ((('b"1")  : mword 1))))
      return
      M (option ast) then
      (decodeConditionalCompareImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__634) (28) (21))) (((Ox"D4")  : mword 8))
      return
      M (option ast) then
      (decodeConditionalSelect (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__634) (28) (24))) ((('b"11011")  : mword 5))
      return
      M (option ast) then
      (decodeData3Source (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__634) (30) (30))) ((('b"0")  : mword 1))))
              ((eq_vec ((subrange_vec_dec (v__634) (28) (21))) (((Ox"D6")  : mword 8))))
      return
      M (option ast) then
      (decodeData2Source (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__634) (30) (30))) ((('b"1")  : mword 1))))
              ((eq_vec ((subrange_vec_dec (v__634) (28) (21))) (((Ox"D6")  : mword 8))))
      return
      M (option ast) then
      (decodeData1Source (machineCode))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:2430.2-2441.3" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeDataImmediate (machineCode : mword 32) : M (option ast) :=
   let v__764 := machineCode in
   (if eq_vec ((subrange_vec_dec (v__764) (28) (24))) ((('b"10000")  : mword 5))
      return
      M (option ast) then
      (decodePCRelAddressing (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__764) (28) (24))) ((('b"10001")  : mword 5))
      return
      M (option ast) then
      (decodeAddSubtractImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__764) (28) (23))) ((('b"100100")  : mword 6))
      return
      M (option ast) then
      (decodeLogicalImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__764) (28) (23))) ((('b"100101")  : mword 6))
      return
      M (option ast) then
      (decodeMoveWideImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__764) (28) (23))) ((('b"100110")  : mword 6))
      return
      M (option ast) then
      (decodeBitfield (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__764) (28) (23))) ((('b"100111")  : mword 6))
      return
      M (option ast) then
      (decodeExtract (machineCode))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:2446.2-2453.3" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeLoadsStores (machineCode : mword 32) : M (option ast) :=
   let v__806 := machineCode in
   (if eq_vec ((subrange_vec_dec (v__806) (29) (24))) ((('b"001000")  : mword 6))
      return
      M (option ast) then
      (decodeLoadStoreExclusive (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"011")  : mword 3))))
              ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"00")  : mword 2))))
      return
      M (option ast) then
      (decodeLoadRegisterLiteral (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"101")  : mword 3))))
              ((eq_vec ((subrange_vec_dec (v__806) (25) (23))) ((('b"000")  : mword 3))))
      return
      M (option ast) then
      (decodeLoadStoreNoAllocatePairOffset (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"101")  : mword 3))))
              ((eq_vec ((subrange_vec_dec (v__806) (25) (23))) ((('b"001")  : mword 3))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterPairPostIndexed (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"101")  : mword 3))))
              ((eq_vec ((subrange_vec_dec (v__806) (25) (23))) ((('b"010")  : mword 3))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterPairOffset (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"101")  : mword 3))))
              ((eq_vec ((subrange_vec_dec (v__806) (25) (23))) ((('b"011")  : mword 3))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterPairPreIndexed (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"111")  : mword 3))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec ((subrange_vec_dec (v__806) (21) (21))) ((('b"0")  : mword 1))))
                      ((eq_vec ((subrange_vec_dec (v__806) (11) (10))) ((('b"00")  : mword 2))))))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterUnscaledImmediate (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"111")  : mword 3))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec ((subrange_vec_dec (v__806) (21) (21))) ((('b"0")  : mword 1))))
                      ((eq_vec ((subrange_vec_dec (v__806) (11) (10))) ((('b"01")  : mword 2))))))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterImmediatePostIndexed (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"111")  : mword 3))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec ((subrange_vec_dec (v__806) (21) (21))) ((('b"0")  : mword 1))))
                      ((eq_vec ((subrange_vec_dec (v__806) (11) (10))) ((('b"10")  : mword 2))))))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterUnprivileged (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"111")  : mword 3))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec ((subrange_vec_dec (v__806) (21) (21))) ((('b"0")  : mword 1))))
                      ((eq_vec ((subrange_vec_dec (v__806) (11) (10))) ((('b"11")  : mword 2))))))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterImmediatePreIndexed (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"111")  : mword 3))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"00")  : mword 2))))
                  ((andb ((eq_vec ((subrange_vec_dec (v__806) (21) (21))) ((('b"1")  : mword 1))))
                      ((eq_vec ((subrange_vec_dec (v__806) (11) (10))) ((('b"10")  : mword 2))))))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterRegisterOffset (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (29) (27))) ((('b"111")  : mword 3))))
              ((eq_vec ((subrange_vec_dec (v__806) (25) (24))) ((('b"01")  : mword 2))))
      return
      M (option ast) then
      (decodeLoadStoreRegisterUnsignedImmediate (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (31) (31))) ((('b"0")  : mword 1))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (29) (23))) ((('b"0011000")  : mword 7))))
                  ((eq_vec ((subrange_vec_dec (v__806) (21) (16))) ((('b"000000")  : mword 6))))))
      return
      M (option ast) then
      (decodeAdvSIMDLoadStoreMultiStruct (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (31) (31))) ((('b"0")  : mword 1))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (29) (23))) ((('b"0011001")  : mword 7))))
                  ((eq_vec ((subrange_vec_dec (v__806) (21) (21))) ((('b"0")  : mword 1))))))
      return
      M (option ast) then
      (decodeAdvSIMDLoadStoreMultiStructPostIndexed (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (31) (31))) ((('b"0")  : mword 1))))
              ((andb ((eq_vec ((subrange_vec_dec (v__806) (29) (23))) ((('b"0011010")  : mword 7))))
                  ((eq_vec ((subrange_vec_dec (v__806) (20) (16))) ((('b"00000")  : mword 5))))))
      return
      M (option ast) then
      (decodeAdvSIMDLoadStoreSingleStruct (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__806) (31) (31))) ((('b"0")  : mword 1))))
              ((eq_vec ((subrange_vec_dec (v__806) (29) (23))) ((('b"0011011")  : mword 7))))
      return
      M (option ast) then
      (decodeAdvSIMDLoadStoreSingleStructPostIndexed (machineCode))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:2458.2-2475.3" >>= fun _ => exit tt)
    : M (option ast).

Definition decodeSystemImplementationDefined (machineCode : mword 32) : M (option ast) :=
   let v__1110 := machineCode in
   (if andb ((eq_vec ((subrange_vec_dec (v__1110) (20) (19))) ((('b"01")  : mword 2))))
         ((andb ((eq_vec ((subrange_vec_dec (v__1110) (15) (15))) ((('b"1")  : mword 1))))
             ((eq_vec ((subrange_vec_dec (v__1110) (13) (12))) ((('b"11")  : mword 2))))))
      return
      M (option ast) then
      (decodeImplementationDefined (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__1110) (20) (19))) ((('b"11")  : mword 2))))
              ((andb ((eq_vec ((subrange_vec_dec (v__1110) (15) (15))) ((('b"1")  : mword 1))))
                  ((eq_vec ((subrange_vec_dec (v__1110) (13) (12))) ((('b"11")  : mword 2))))))
      return
      M (option ast) then
      (decodeImplementationDefined (machineCode))
       : M (option ast)
    else (decodeSystem (machineCode))  : M (option ast))
    : M (option ast).

Definition decodeBranchesExceptionSystem (machineCode : mword 32) : M (option ast) :=
   let v__1140 := machineCode in
   (if eq_vec ((subrange_vec_dec (v__1140) (30) (26))) ((('b"00101")  : mword 5))
      return
      M (option ast) then
      (decodeUnconditionalBranchImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1140) (30) (25))) ((('b"011010")  : mword 6))
      return
      M (option ast) then
      (decodeCompareBranchImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1140) (30) (25))) ((('b"011011")  : mword 6))
      return
      M (option ast) then
      (decodeTestBranchImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1140) (31) (25))) ((('b"0101010")  : mword 7))
      return
      M (option ast) then
      (decodeConditionalBranchImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1140) (31) (24))) (((Ox"D4")  : mword 8))
      return
      M (option ast) then
      (decodeExceptionGeneration (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1140) (31) (22))) ((('b"1101010100")  : mword 10))
      return
      M (option ast) then
      (decodeSystemImplementationDefined (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1140) (31) (25))) ((('b"1101011")  : mword 7))
      return
      M (option ast) then
      (decodeUnconditionalBranchRegister (machineCode))
       : M (option ast)
    else assert_exp' false "Pattern match failure at armV8.sail:2490.2-2498.3" >>= fun _ => exit tt)
    : M (option ast).

Definition decode (machineCode : mword 32) : M (option ast) :=
   let v__1217 := machineCode in
   (if eq_vec ((subrange_vec_dec (v__1217) (28) (27))) ((('b"00")  : mword 2)) then
      returnM ((Some ((Unallocated (tt)))))
    else if eq_vec ((subrange_vec_dec (v__1217) (28) (26))) ((('b"100")  : mword 3))
      return
      M (option ast) then
      (decodeDataImmediate (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1217) (28) (26))) ((('b"101")  : mword 3))
      return
      M (option ast) then
      (decodeBranchesExceptionSystem (machineCode))
       : M (option ast)
    else if andb ((eq_vec ((subrange_vec_dec (v__1217) (27) (27))) ((('b"1")  : mword 1))))
              ((eq_vec ((subrange_vec_dec (v__1217) (25) (25))) ((('b"0")  : mword 1))))
      return
      M (option ast) then
      (decodeLoadsStores (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1217) (27) (25))) ((('b"101")  : mword 3))
      return
      M (option ast) then
      (decodeDataRegister (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1217) (28) (25))) (((Ox"7")  : mword 4))
      return
      M (option ast) then
      (decodeDataSIMDFPoint1 (machineCode))
       : M (option ast)
    else if eq_vec ((subrange_vec_dec (v__1217) (28) (25))) (((Ox"F")  : mword 4))
      return
      M (option ast) then
      (decodeDataSIMDFPoint2 (machineCode))
       : M (option ast)
    else returnM (None))
    : M (option ast).

Definition supported_instructions (instr : ast) : option ast :=
   match instr with | Unallocated tt => None | _ => Some (instr) end.

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector (64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC w__0 >>
   (undefined_bitvector (8)) >>= fun (w__1 : mword 8) =>
   write_reg TxNestingLevel w__1 >>
   (undefined_TMSTATUS_type (tt)) >>= fun (w__2 : mword 64) =>
   write_reg TMAbortEffect w__2 >>
   (undefined_TMSTATUS_type (tt)) >>= fun (w__3 : mword 64) =>
   write_reg TMStartEffect w__3 >>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   write_reg data_cache_operation_CVAU w__4 >>
   (undefined_bitvector (64)) >>= fun (w__5 : mword 64) =>
   write_reg instruction_cache_operation_IVAU w__5 >>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   write_reg R30 w__6 >>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   write_reg R29 w__7 >>
   (undefined_bitvector (64)) >>= fun (w__8 : mword 64) =>
   write_reg R28 w__8 >>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   write_reg R27 w__9 >>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   write_reg R26 w__10 >>
   (undefined_bitvector (64)) >>= fun (w__11 : mword 64) =>
   write_reg R25 w__11 >>
   (undefined_bitvector (64)) >>= fun (w__12 : mword 64) =>
   write_reg R24 w__12 >>
   (undefined_bitvector (64)) >>= fun (w__13 : mword 64) =>
   write_reg R23 w__13 >>
   (undefined_bitvector (64)) >>= fun (w__14 : mword 64) =>
   write_reg R22 w__14 >>
   (undefined_bitvector (64)) >>= fun (w__15 : mword 64) =>
   write_reg R21 w__15 >>
   (undefined_bitvector (64)) >>= fun (w__16 : mword 64) =>
   write_reg R20 w__16 >>
   (undefined_bitvector (64)) >>= fun (w__17 : mword 64) =>
   write_reg R19 w__17 >>
   (undefined_bitvector (64)) >>= fun (w__18 : mword 64) =>
   write_reg R18 w__18 >>
   (undefined_bitvector (64)) >>= fun (w__19 : mword 64) =>
   write_reg R17 w__19 >>
   (undefined_bitvector (64)) >>= fun (w__20 : mword 64) =>
   write_reg R16 w__20 >>
   (undefined_bitvector (64)) >>= fun (w__21 : mword 64) =>
   write_reg R15 w__21 >>
   (undefined_bitvector (64)) >>= fun (w__22 : mword 64) =>
   write_reg R14 w__22 >>
   (undefined_bitvector (64)) >>= fun (w__23 : mword 64) =>
   write_reg R13 w__23 >>
   (undefined_bitvector (64)) >>= fun (w__24 : mword 64) =>
   write_reg R12 w__24 >>
   (undefined_bitvector (64)) >>= fun (w__25 : mword 64) =>
   write_reg R11 w__25 >>
   (undefined_bitvector (64)) >>= fun (w__26 : mword 64) =>
   write_reg R10 w__26 >>
   (undefined_bitvector (64)) >>= fun (w__27 : mword 64) =>
   write_reg R9 w__27 >>
   (undefined_bitvector (64)) >>= fun (w__28 : mword 64) =>
   write_reg R8 w__28 >>
   (undefined_bitvector (64)) >>= fun (w__29 : mword 64) =>
   write_reg R7 w__29 >>
   (undefined_bitvector (64)) >>= fun (w__30 : mword 64) =>
   write_reg R6 w__30 >>
   (undefined_bitvector (64)) >>= fun (w__31 : mword 64) =>
   write_reg R5 w__31 >>
   (undefined_bitvector (64)) >>= fun (w__32 : mword 64) =>
   write_reg R4 w__32 >>
   (undefined_bitvector (64)) >>= fun (w__33 : mword 64) =>
   write_reg R3 w__33 >>
   (undefined_bitvector (64)) >>= fun (w__34 : mword 64) =>
   write_reg R2 w__34 >>
   (undefined_bitvector (64)) >>= fun (w__35 : mword 64) =>
   write_reg R1 w__35 >>
   (undefined_bitvector (64)) >>= fun (w__36 : mword 64) =>
   write_reg R0 w__36 >>
   (undefined_bitvector (128)) >>= fun (w__37 : mword 128) =>
   write_reg V31 w__37 >>
   (undefined_bitvector (128)) >>= fun (w__38 : mword 128) =>
   write_reg V30 w__38 >>
   (undefined_bitvector (128)) >>= fun (w__39 : mword 128) =>
   write_reg V29 w__39 >>
   (undefined_bitvector (128)) >>= fun (w__40 : mword 128) =>
   write_reg V28 w__40 >>
   (undefined_bitvector (128)) >>= fun (w__41 : mword 128) =>
   write_reg V27 w__41 >>
   (undefined_bitvector (128)) >>= fun (w__42 : mword 128) =>
   write_reg V26 w__42 >>
   (undefined_bitvector (128)) >>= fun (w__43 : mword 128) =>
   write_reg V25 w__43 >>
   (undefined_bitvector (128)) >>= fun (w__44 : mword 128) =>
   write_reg V24 w__44 >>
   (undefined_bitvector (128)) >>= fun (w__45 : mword 128) =>
   write_reg V23 w__45 >>
   (undefined_bitvector (128)) >>= fun (w__46 : mword 128) =>
   write_reg V22 w__46 >>
   (undefined_bitvector (128)) >>= fun (w__47 : mword 128) =>
   write_reg V21 w__47 >>
   (undefined_bitvector (128)) >>= fun (w__48 : mword 128) =>
   write_reg V20 w__48 >>
   (undefined_bitvector (128)) >>= fun (w__49 : mword 128) =>
   write_reg V19 w__49 >>
   (undefined_bitvector (128)) >>= fun (w__50 : mword 128) =>
   write_reg V18 w__50 >>
   (undefined_bitvector (128)) >>= fun (w__51 : mword 128) =>
   write_reg V17 w__51 >>
   (undefined_bitvector (128)) >>= fun (w__52 : mword 128) =>
   write_reg V16 w__52 >>
   (undefined_bitvector (128)) >>= fun (w__53 : mword 128) =>
   write_reg V15 w__53 >>
   (undefined_bitvector (128)) >>= fun (w__54 : mword 128) =>
   write_reg V14 w__54 >>
   (undefined_bitvector (128)) >>= fun (w__55 : mword 128) =>
   write_reg V13 w__55 >>
   (undefined_bitvector (128)) >>= fun (w__56 : mword 128) =>
   write_reg V12 w__56 >>
   (undefined_bitvector (128)) >>= fun (w__57 : mword 128) =>
   write_reg V11 w__57 >>
   (undefined_bitvector (128)) >>= fun (w__58 : mword 128) =>
   write_reg V10 w__58 >>
   (undefined_bitvector (128)) >>= fun (w__59 : mword 128) =>
   write_reg V9 w__59 >>
   (undefined_bitvector (128)) >>= fun (w__60 : mword 128) =>
   write_reg V8 w__60 >>
   (undefined_bitvector (128)) >>= fun (w__61 : mword 128) =>
   write_reg V7 w__61 >>
   (undefined_bitvector (128)) >>= fun (w__62 : mword 128) =>
   write_reg V6 w__62 >>
   (undefined_bitvector (128)) >>= fun (w__63 : mword 128) =>
   write_reg V5 w__63 >>
   (undefined_bitvector (128)) >>= fun (w__64 : mword 128) =>
   write_reg V4 w__64 >>
   (undefined_bitvector (128)) >>= fun (w__65 : mword 128) =>
   write_reg V3 w__65 >>
   (undefined_bitvector (128)) >>= fun (w__66 : mword 128) =>
   write_reg V2 w__66 >>
   (undefined_bitvector (128)) >>= fun (w__67 : mword 128) =>
   write_reg V1 w__67 >>
   (undefined_bitvector (128)) >>= fun (w__68 : mword 128) =>
   write_reg V0 w__68 >>
   (undefined_HCR_type (tt)) >>= fun (w__69 : mword 64) =>
   write_reg HCR_EL2 w__69 >>
   (undefined_ID_AA64MMFR0_type (tt)) >>= fun (w__70 : mword 64) =>
   write_reg ID_AA64MMFR0_EL1 w__70 >>
   (undefined_bitvector (64)) >>= fun (w__71 : mword 64) =>
   write_reg RVBAR_EL1 w__71 >>
   (undefined_bitvector (64)) >>= fun (w__72 : mword 64) =>
   write_reg RVBAR_EL2 w__72 >>
   (undefined_bitvector (64)) >>= fun (w__73 : mword 64) =>
   write_reg RVBAR_EL3 w__73 >>
   (undefined_SCRType (tt)) >>= fun (w__74 : mword 32) =>
   write_reg SCR_EL3 w__74 >>
   (undefined_SCTLR_EL1_type (tt)) >>= fun (w__75 : mword 32) =>
   write_reg SCTLR_EL1 w__75 >>
   (undefined_SCTLR_type (tt)) >>= fun (w__76 : mword 32) =>
   write_reg SCTLR_EL2 w__76 >>
   (undefined_SCTLR_type (tt)) >>= fun (w__77 : mword 32) =>
   write_reg SCTLR_EL3 w__77 >>
   (undefined_TCR_EL1_type (tt)) >>= fun (w__78 : mword 64) =>
   write_reg TCR_EL1 w__78 >>
   (undefined_TCR_type (tt)) >>= fun (w__79 : mword 32) =>
   write_reg TCR_EL2 w__79 >>
   (undefined_TCR_type (tt)) >>= fun (w__80 : mword 32) =>
   write_reg TCR_EL3 w__80 >>
   (undefined_bitvector (64)) >>= fun (w__81 : mword 64) =>
   write_reg TPIDR_EL0 w__81 >>
   (undefined_bitvector (64)) >>= fun (w__82 : mword 64) =>
   write_reg TPIDR_EL1 w__82 >>
   (undefined_bitvector (64)) >>= fun (w__83 : mword 64) =>
   write_reg TPIDR_EL2 w__83 >>
   (undefined_bitvector (64)) >>= fun (w__84 : mword 64) =>
   write_reg TPIDR_EL3 w__84 >>
   (undefined_DBGPRCR_type (tt)) >>= fun (w__85 : mword 32) =>
   write_reg DBGPRCR_EL1 w__85 >>
   (undefined_OSDLR_type (tt)) >>= fun (w__86 : mword 32) =>
   write_reg OSDLR_EL1 w__86 >>
   (undefined_EDSCR_type (tt)) >>= fun (w__87 : mword 32) =>
   write_reg EDSCR w__87 >>
   (undefined_TXIDR_EL0_type (tt)) >>= fun (w__88 : mword 64) =>
   write_reg TXIDR_EL0 w__88 >>
   (undefined_CurrentEL_type (tt)) >>= fun (w__89 : mword 32) =>
   write_reg CurrentEL w__89 >>
   (undefined_DAIF_type (tt)) >>= fun (w__90 : mword 32) =>
   write_reg DAIF w__90 >>
   (undefined_NZCV_type (tt)) >>= fun (w__91 : mword 32) =>
   write_reg NZCV w__91 >>
   (undefined_bitvector (64)) >>= fun (w__92 : mword 64) =>
   write_reg SP_EL0 w__92 >>
   (undefined_bitvector (64)) >>= fun (w__93 : mword 64) =>
   write_reg SP_EL1 w__93 >>
   (undefined_bitvector (64)) >>= fun (w__94 : mword 64) =>
   write_reg SP_EL2 w__94 >>
   (undefined_bitvector (64)) >>= fun (w__95 : mword 64) =>
   write_reg SP_EL3 w__95 >>
   (undefined_SPSel_type (tt)) >>= fun (w__96 : mword 32) =>
   write_reg SPSel w__96 >>
   (undefined_SPSR_type (tt)) >>= fun (w__97 : mword 32) =>
   write_reg SPSR_EL1 w__97 >>
   (undefined_SPSR_type (tt)) >>= fun (w__98 : mword 32) =>
   write_reg SPSR_EL2 w__98 >>
   (undefined_SPSR_type (tt)) >>= fun (w__99 : mword 32) =>
   write_reg SPSR_EL3 w__99 >>
   (undefined_bitvector (64)) >>= fun (w__100 : mword 64) =>
   write_reg ELR_EL1 w__100 >>
   (undefined_bitvector (64)) >>= fun (w__101 : mword 64) =>
   write_reg ELR_EL2 w__101 >>
   (undefined_bitvector (64)) >>= fun (w__102 : mword 64) =>
   write_reg ELR_EL3 w__102 >>
   (undefined_SCRType (tt)) >>= fun (w__103 : mword 32) =>
   write_reg SCR w__103 >>
   (undefined_DBGOSDLR_type (tt)) >>= fun (w__104 : mword 32) =>
   write_reg DBGOSDLR w__104 >>
   (undefined_DBGPRCR_type (tt)) >>= fun (w__105 : mword 32) =>
   write_reg DBGPRCR w__105 >>
   (undefined_bitvector (1)) >>= fun (w__106 : mword 1) =>
   write_reg PSTATE_nRW w__106 >>
   (undefined_bitvector (1)) >>= fun (w__107 : mword 1) =>
   write_reg PSTATE_E w__107 >>
   (undefined_bitvector (5)) >>= fun (w__108 : mword 5) => write_reg PSTATE_M w__108  : M (unit).

Definition sail_model_init (_ : unit) : M (unit) := (initialize_registers (tt))  : M (unit).



