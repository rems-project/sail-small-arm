(*Generated by Sail from armV8.*)


From stdpp Require Import base countable.
Require Eqdep.
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Inductive regfp :=
| RFull : string -> regfp
| RSlice : (string * Z * Z) -> regfp
| RSliceBit : (string * Z) -> regfp
| RField : (string * string) -> regfp.
Arguments regfp : clear implicits.

Definition sail_regfp_encode (x : regfp) := match x with
  | RFull x' => encode (0, encode x')
  | RSlice x' => encode (1, encode x')
  | RSliceBit x' => encode (2, encode x')
  | RField x' => encode (3, encode x') end.
Definition sail_regfp_decode x : option regfp := match decode x with
  | Some (0, x') => RFull <$> decode x'
  | Some (1, x') => RSlice <$> decode x'
  | Some (2, x') => RSliceBit <$> decode x'
  | Some (3, x') => RField <$> decode x'
  | _ => None end.
Lemma sail_regfp_decode_encode : forall (x : regfp), sail_regfp_decode (sail_regfp_encode x)
   = Some x.
Proof.
  unfold sail_regfp_decode, sail_regfp_encode;
  intros [x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_regfp : EqDecision regfp := decode_encode_eq_dec sail_regfp_encode
  sail_regfp_decode sail_regfp_decode_encode .

#[export]
Instance Countable_regfp : Countable regfp := {|
  encode := sail_regfp_encode;
  decode := sail_regfp_decode;
  decode_encode := sail_regfp_decode_encode
|}.
#[export]
Instance dummy_regfp : Inhabited (regfp) := { inhabitant := RFull inhabitant }.

Definition regfps : Type := list regfp.

Inductive niafp :=
| NIAFP_successor : unit -> niafp
| NIAFP_concrete_address : bits 64 -> niafp
| NIAFP_indirect_address : unit -> niafp.
Arguments niafp : clear implicits.

Definition sail_niafp_encode (x : niafp) := match x with
  | NIAFP_successor x' => encode (0, encode x')
  | NIAFP_concrete_address x' => encode (1, encode x')
  | NIAFP_indirect_address x' => encode (2, encode x') end.
Definition sail_niafp_decode x : option niafp := match decode x with
  | Some (0, x') => NIAFP_successor <$> decode x'
  | Some (1, x') => NIAFP_concrete_address <$> decode x'
  | Some (2, x') => NIAFP_indirect_address <$> decode x'
  | _ => None end.
Lemma sail_niafp_decode_encode : forall (x : niafp), sail_niafp_decode (sail_niafp_encode x)
   = Some x.
Proof.
  unfold sail_niafp_decode, sail_niafp_encode;
  intros [x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_niafp : EqDecision niafp := decode_encode_eq_dec sail_niafp_encode
  sail_niafp_decode sail_niafp_decode_encode .

#[export]
Instance Countable_niafp : Countable niafp := {|
  encode := sail_niafp_encode;
  decode := sail_niafp_decode;
  decode_encode := sail_niafp_decode_encode
|}.
#[export]
Instance dummy_niafp : Inhabited (niafp) := { inhabitant := NIAFP_successor inhabitant }.

Definition niafps : Type := list niafp.

Definition min (M' : Z) (N : Z) : Type := Z.

Definition boolean : Type := bool.

Definition integer : Type := Z.

Definition uinteger : Type := Z.

Definition reg_size : Type := bits 5.

Definition reg_index : Type := Z.

Definition SIMD_index : Type := Z.

Definition TMSTATUS_type : Type := mword 64.

Record IMPLEMENTATION_DEFINED_type := {
  IMPLEMENTATION_DEFINED_type_HaveCRCExt : boolean;
  IMPLEMENTATION_DEFINED_type_HaveAArch32EL : boolean;
  IMPLEMENTATION_DEFINED_type_HaveAnyAArch32 : boolean;
  IMPLEMENTATION_DEFINED_type_HaveEL2 : boolean;
  IMPLEMENTATION_DEFINED_type_HaveEL3 : boolean;
  IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32 : boolean;
  IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3 : boolean;
}.
Arguments IMPLEMENTATION_DEFINED_type : clear implicits.
#[export]
Instance Decidable_eq_IMPLEMENTATION_DEFINED_type : EqDecision IMPLEMENTATION_DEFINED_type.
   intros [x0 x1 x2 x3 x4 x5 x6].
   intros [y0 y1 y2 y3 y4 y5 y6].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_IMPLEMENTATION_DEFINED_type : Countable IMPLEMENTATION_DEFINED_type.
refine {|
  encode x := encode (IMPLEMENTATION_DEFINED_type_HaveCRCExt x, IMPLEMENTATION_DEFINED_type_HaveAArch32EL x, IMPLEMENTATION_DEFINED_type_HaveAnyAArch32 x, IMPLEMENTATION_DEFINED_type_HaveEL2 x, IMPLEMENTATION_DEFINED_type_HaveEL3 x, IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32 x, IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3 x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6) ← decode x;
              mret (Build_IMPLEMENTATION_DEFINED_type x0 x1 x2 x3 x4 x5 x6)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_IMPLEMENTATION_DEFINED_type : Settable _ := settable! Build_IMPLEMENTATION_DEFINED_type <IMPLEMENTATION_DEFINED_type_HaveCRCExt; IMPLEMENTATION_DEFINED_type_HaveAArch32EL; IMPLEMENTATION_DEFINED_type_HaveAnyAArch32; IMPLEMENTATION_DEFINED_type_HaveEL2; IMPLEMENTATION_DEFINED_type_HaveEL3; IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32; IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3>.
#[export]
Instance dummy_IMPLEMENTATION_DEFINED_type : Inhabited (IMPLEMENTATION_DEFINED_type) := {
  inhabitant := {|
    IMPLEMENTATION_DEFINED_type_HaveCRCExt := inhabitant;
    IMPLEMENTATION_DEFINED_type_HaveAArch32EL := inhabitant;
    IMPLEMENTATION_DEFINED_type_HaveAnyAArch32 := inhabitant;
    IMPLEMENTATION_DEFINED_type_HaveEL2 := inhabitant;
    IMPLEMENTATION_DEFINED_type_HaveEL3 := inhabitant;
    IMPLEMENTATION_DEFINED_type_HighestELUsingAArch32 := inhabitant;
    IMPLEMENTATION_DEFINED_type_IsSecureBelowEL3 := inhabitant
|} }.


Definition HCR_type : Type := mword 64.

Definition ID_AA64MMFR0_type : Type := mword 64.

Definition SCRType : Type := mword 32.

Definition SCTLR_EL1_type : Type := mword 32.

Definition SCTLR_type : Type := mword 32.

Definition TCR_EL1_type : Type := mword 64.

Definition TCR_type : Type := mword 32.

Definition DBGPRCR_type : Type := mword 32.

Definition OSDLR_type : Type := mword 32.

Definition EDSCR_type : Type := mword 32.

Definition TXIDR_EL0_type : Type := mword 64.

Definition CurrentEL_type : Type := mword 32.

Definition DAIF_type : Type := mword 32.

Definition NZCV_type : Type := mword 32.

Definition SPSel_type : Type := mword 32.

Definition SPSR_type : Type := mword 32.

Definition DBGOSDLR_type : Type := mword 32.

Inductive AccType :=
  | AccType_NORMAL
  | AccType_VEC
  | AccType_STREAM
  | AccType_VECSTREAM
  | AccType_ATOMIC
  | AccType_ORDERED
  | AccType_UNPRIV
  | AccType_IFETCH
  | AccType_PTW
  | AccType_DC
  | AccType_IC
  | AccType_AT.
Definition num_of_AccType (arg_ : AccType) : Z :=
   match arg_ with
   | AccType_NORMAL => 0
   | AccType_VEC => 1
   | AccType_STREAM => 2
   | AccType_VECSTREAM => 3
   | AccType_ATOMIC => 4
   | AccType_ORDERED => 5
   | AccType_UNPRIV => 6
   | AccType_IFETCH => 7
   | AccType_PTW => 8
   | AccType_DC => 9
   | AccType_IC => 10
   | AccType_AT => 11
   end.

Definition AccType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 11)*) : AccType :=
   let l__109 := arg_ in
   if Z.eqb (l__109) (0) then AccType_NORMAL
   else if Z.eqb (l__109) (1) then AccType_VEC
   else if Z.eqb (l__109) (2) then AccType_STREAM
   else if Z.eqb (l__109) (3) then AccType_VECSTREAM
   else if Z.eqb (l__109) (4) then AccType_ATOMIC
   else if Z.eqb (l__109) (5) then AccType_ORDERED
   else if Z.eqb (l__109) (6) then AccType_UNPRIV
   else if Z.eqb (l__109) (7) then AccType_IFETCH
   else if Z.eqb (l__109) (8) then AccType_PTW
   else if Z.eqb (l__109) (9) then AccType_DC
   else if Z.eqb (l__109) (10) then AccType_IC
   else AccType_AT.

Lemma AccType_num_of_roundtrip (x : AccType) : AccType_of_num (num_of_AccType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_AccType_injective (x y : AccType) : num_of_AccType x = num_of_AccType y -> x = y.
  intro.
  rewrite <- (AccType_num_of_roundtrip x).
  rewrite <- (AccType_num_of_roundtrip y).
  congruence.
Qed.
Definition AccType_eq_dec (x y : AccType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_AccType x) (num_of_AccType y) with
  | left e => left (num_of_AccType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition AccType_beq (x y : AccType) : bool :=
  Z.eqb (num_of_AccType x) (num_of_AccType y).
Lemma AccType_beq_iff x y : AccType_beq x y = true <-> x = y.
  unfold AccType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_AccType_injective | congruence].
Qed.
Lemma AccType_beq_refl x : AccType_beq x x = true.
apply AccType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_AccType : EqDecision AccType := AccType_eq_dec.
#[export]
Instance Countable_AccType : Countable AccType.
refine {|
  encode x := encode (num_of_AccType x);
  decode x := z ← decode x; mret (AccType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite AccType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_AccType : Inhabited AccType := { inhabitant := AccType_NORMAL }.


Inductive MBReqDomain :=
  | MBReqDomain_Nonshareable
  | MBReqDomain_InnerShareable
  | MBReqDomain_OuterShareable
  | MBReqDomain_FullSystem.
Definition num_of_MBReqDomain (arg_ : MBReqDomain) : Z :=
   match arg_ with
   | MBReqDomain_Nonshareable => 0
   | MBReqDomain_InnerShareable => 1
   | MBReqDomain_OuterShareable => 2
   | MBReqDomain_FullSystem => 3
   end.

Definition MBReqDomain_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : MBReqDomain :=
   let l__106 := arg_ in
   if Z.eqb (l__106) (0) then MBReqDomain_Nonshareable
   else if Z.eqb (l__106) (1) then MBReqDomain_InnerShareable
   else if Z.eqb (l__106) (2) then MBReqDomain_OuterShareable
   else MBReqDomain_FullSystem.

Lemma MBReqDomain_num_of_roundtrip (x : MBReqDomain) : MBReqDomain_of_num (num_of_MBReqDomain x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MBReqDomain_injective (x y : MBReqDomain) : num_of_MBReqDomain x = num_of_MBReqDomain y -> x = y.
  intro.
  rewrite <- (MBReqDomain_num_of_roundtrip x).
  rewrite <- (MBReqDomain_num_of_roundtrip y).
  congruence.
Qed.
Definition MBReqDomain_eq_dec (x y : MBReqDomain) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MBReqDomain x) (num_of_MBReqDomain y) with
  | left e => left (num_of_MBReqDomain_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MBReqDomain_beq (x y : MBReqDomain) : bool :=
  Z.eqb (num_of_MBReqDomain x) (num_of_MBReqDomain y).
Lemma MBReqDomain_beq_iff x y : MBReqDomain_beq x y = true <-> x = y.
  unfold MBReqDomain_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MBReqDomain_injective | congruence].
Qed.
Lemma MBReqDomain_beq_refl x : MBReqDomain_beq x x = true.
apply MBReqDomain_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MBReqDomain : EqDecision MBReqDomain := MBReqDomain_eq_dec.
#[export]
Instance Countable_MBReqDomain : Countable MBReqDomain.
refine {|
  encode x := encode (num_of_MBReqDomain x);
  decode x := z ← decode x; mret (MBReqDomain_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MBReqDomain_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MBReqDomain : Inhabited MBReqDomain := { inhabitant := MBReqDomain_Nonshareable }.


Inductive MBReqTypes := MBReqTypes_Reads | MBReqTypes_Writes | MBReqTypes_All.
Definition num_of_MBReqTypes (arg_ : MBReqTypes) : Z :=
   match arg_ with | MBReqTypes_Reads => 0 | MBReqTypes_Writes => 1 | MBReqTypes_All => 2 end.

Definition MBReqTypes_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MBReqTypes :=
   let l__104 := arg_ in
   if Z.eqb (l__104) (0) then MBReqTypes_Reads
   else if Z.eqb (l__104) (1) then MBReqTypes_Writes
   else MBReqTypes_All.

Lemma MBReqTypes_num_of_roundtrip (x : MBReqTypes) : MBReqTypes_of_num (num_of_MBReqTypes x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MBReqTypes_injective (x y : MBReqTypes) : num_of_MBReqTypes x = num_of_MBReqTypes y -> x = y.
  intro.
  rewrite <- (MBReqTypes_num_of_roundtrip x).
  rewrite <- (MBReqTypes_num_of_roundtrip y).
  congruence.
Qed.
Definition MBReqTypes_eq_dec (x y : MBReqTypes) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MBReqTypes x) (num_of_MBReqTypes y) with
  | left e => left (num_of_MBReqTypes_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MBReqTypes_beq (x y : MBReqTypes) : bool :=
  Z.eqb (num_of_MBReqTypes x) (num_of_MBReqTypes y).
Lemma MBReqTypes_beq_iff x y : MBReqTypes_beq x y = true <-> x = y.
  unfold MBReqTypes_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MBReqTypes_injective | congruence].
Qed.
Lemma MBReqTypes_beq_refl x : MBReqTypes_beq x x = true.
apply MBReqTypes_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MBReqTypes : EqDecision MBReqTypes := MBReqTypes_eq_dec.
#[export]
Instance Countable_MBReqTypes : Countable MBReqTypes.
refine {|
  encode x := encode (num_of_MBReqTypes x);
  decode x := z ← decode x; mret (MBReqTypes_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MBReqTypes_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MBReqTypes : Inhabited MBReqTypes := { inhabitant := MBReqTypes_Reads }.


Inductive BranchType :=
  | BranchType_CALL
  | BranchType_ERET
  | BranchType_DBGEXIT
  | BranchType_RET
  | BranchType_JMP
  | BranchType_EXCEPTION
  | BranchType_UNKNOWN.
Definition num_of_BranchType (arg_ : BranchType) : Z :=
   match arg_ with
   | BranchType_CALL => 0
   | BranchType_ERET => 1
   | BranchType_DBGEXIT => 2
   | BranchType_RET => 3
   | BranchType_JMP => 4
   | BranchType_EXCEPTION => 5
   | BranchType_UNKNOWN => 6
   end.

Definition BranchType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 6)*) : BranchType :=
   let l__98 := arg_ in
   if Z.eqb (l__98) (0) then BranchType_CALL
   else if Z.eqb (l__98) (1) then BranchType_ERET
   else if Z.eqb (l__98) (2) then BranchType_DBGEXIT
   else if Z.eqb (l__98) (3) then BranchType_RET
   else if Z.eqb (l__98) (4) then BranchType_JMP
   else if Z.eqb (l__98) (5) then BranchType_EXCEPTION
   else BranchType_UNKNOWN.

Lemma BranchType_num_of_roundtrip (x : BranchType) : BranchType_of_num (num_of_BranchType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_BranchType_injective (x y : BranchType) : num_of_BranchType x = num_of_BranchType y -> x = y.
  intro.
  rewrite <- (BranchType_num_of_roundtrip x).
  rewrite <- (BranchType_num_of_roundtrip y).
  congruence.
Qed.
Definition BranchType_eq_dec (x y : BranchType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_BranchType x) (num_of_BranchType y) with
  | left e => left (num_of_BranchType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition BranchType_beq (x y : BranchType) : bool :=
  Z.eqb (num_of_BranchType x) (num_of_BranchType y).
Lemma BranchType_beq_iff x y : BranchType_beq x y = true <-> x = y.
  unfold BranchType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_BranchType_injective | congruence].
Qed.
Lemma BranchType_beq_refl x : BranchType_beq x x = true.
apply BranchType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_BranchType : EqDecision BranchType := BranchType_eq_dec.
#[export]
Instance Countable_BranchType : Countable BranchType.
refine {|
  encode x := encode (num_of_BranchType x);
  decode x := z ← decode x; mret (BranchType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite BranchType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_BranchType : Inhabited BranchType := { inhabitant := BranchType_CALL }.


Inductive MoveWideOp := MoveWideOp_N | MoveWideOp_Z | MoveWideOp_K.
Definition num_of_MoveWideOp (arg_ : MoveWideOp) : Z :=
   match arg_ with | MoveWideOp_N => 0 | MoveWideOp_Z => 1 | MoveWideOp_K => 2 end.

Definition MoveWideOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MoveWideOp :=
   let l__96 := arg_ in
   if Z.eqb (l__96) (0) then MoveWideOp_N
   else if Z.eqb (l__96) (1) then MoveWideOp_Z
   else MoveWideOp_K.

Lemma MoveWideOp_num_of_roundtrip (x : MoveWideOp) : MoveWideOp_of_num (num_of_MoveWideOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MoveWideOp_injective (x y : MoveWideOp) : num_of_MoveWideOp x = num_of_MoveWideOp y -> x = y.
  intro.
  rewrite <- (MoveWideOp_num_of_roundtrip x).
  rewrite <- (MoveWideOp_num_of_roundtrip y).
  congruence.
Qed.
Definition MoveWideOp_eq_dec (x y : MoveWideOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MoveWideOp x) (num_of_MoveWideOp y) with
  | left e => left (num_of_MoveWideOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MoveWideOp_beq (x y : MoveWideOp) : bool :=
  Z.eqb (num_of_MoveWideOp x) (num_of_MoveWideOp y).
Lemma MoveWideOp_beq_iff x y : MoveWideOp_beq x y = true <-> x = y.
  unfold MoveWideOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MoveWideOp_injective | congruence].
Qed.
Lemma MoveWideOp_beq_refl x : MoveWideOp_beq x x = true.
apply MoveWideOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MoveWideOp : EqDecision MoveWideOp := MoveWideOp_eq_dec.
#[export]
Instance Countable_MoveWideOp : Countable MoveWideOp.
refine {|
  encode x := encode (num_of_MoveWideOp x);
  decode x := z ← decode x; mret (MoveWideOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MoveWideOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MoveWideOp : Inhabited MoveWideOp := { inhabitant := MoveWideOp_N }.


Inductive DeviceType := DeviceType_GRE | DeviceType_nGRE | DeviceType_nGnRE | DeviceType_nGnRnE.
Definition num_of_DeviceType (arg_ : DeviceType) : Z :=
   match arg_ with
   | DeviceType_GRE => 0
   | DeviceType_nGRE => 1
   | DeviceType_nGnRE => 2
   | DeviceType_nGnRnE => 3
   end.

Definition DeviceType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : DeviceType :=
   let l__93 := arg_ in
   if Z.eqb (l__93) (0) then DeviceType_GRE
   else if Z.eqb (l__93) (1) then DeviceType_nGRE
   else if Z.eqb (l__93) (2) then DeviceType_nGnRE
   else DeviceType_nGnRnE.

Lemma DeviceType_num_of_roundtrip (x : DeviceType) : DeviceType_of_num (num_of_DeviceType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_DeviceType_injective (x y : DeviceType) : num_of_DeviceType x = num_of_DeviceType y -> x = y.
  intro.
  rewrite <- (DeviceType_num_of_roundtrip x).
  rewrite <- (DeviceType_num_of_roundtrip y).
  congruence.
Qed.
Definition DeviceType_eq_dec (x y : DeviceType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_DeviceType x) (num_of_DeviceType y) with
  | left e => left (num_of_DeviceType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition DeviceType_beq (x y : DeviceType) : bool :=
  Z.eqb (num_of_DeviceType x) (num_of_DeviceType y).
Lemma DeviceType_beq_iff x y : DeviceType_beq x y = true <-> x = y.
  unfold DeviceType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_DeviceType_injective | congruence].
Qed.
Lemma DeviceType_beq_refl x : DeviceType_beq x x = true.
apply DeviceType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_DeviceType : EqDecision DeviceType := DeviceType_eq_dec.
#[export]
Instance Countable_DeviceType : Countable DeviceType.
refine {|
  encode x := encode (num_of_DeviceType x);
  decode x := z ← decode x; mret (DeviceType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite DeviceType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_DeviceType : Inhabited DeviceType := { inhabitant := DeviceType_GRE }.


Inductive Fault :=
  | Fault_None
  | Fault_AccessFlag
  | Fault_Alignment
  | Fault_Background
  | Fault_Domain
  | Fault_Permission
  | Fault_Translation
  | Fault_AddressSize
  | Fault_SyncExternal
  | Fault_SyncExternalOnWalk
  | Fault_SyncParity
  | Fault_SyncParityOnWalk
  | Fault_AsyncParity
  | Fault_AsyncExternal
  | Fault_Debug
  | Fault_TLBConflict
  | Fault_Lockdown
  | Fault_Exclusive
  | Fault_ICacheMaint.
Definition num_of_Fault (arg_ : Fault) : Z :=
   match arg_ with
   | Fault_None => 0
   | Fault_AccessFlag => 1
   | Fault_Alignment => 2
   | Fault_Background => 3
   | Fault_Domain => 4
   | Fault_Permission => 5
   | Fault_Translation => 6
   | Fault_AddressSize => 7
   | Fault_SyncExternal => 8
   | Fault_SyncExternalOnWalk => 9
   | Fault_SyncParity => 10
   | Fault_SyncParityOnWalk => 11
   | Fault_AsyncParity => 12
   | Fault_AsyncExternal => 13
   | Fault_Debug => 14
   | Fault_TLBConflict => 15
   | Fault_Lockdown => 16
   | Fault_Exclusive => 17
   | Fault_ICacheMaint => 18
   end.

Definition Fault_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 18)*) : Fault :=
   let l__75 := arg_ in
   if Z.eqb (l__75) (0) then Fault_None
   else if Z.eqb (l__75) (1) then Fault_AccessFlag
   else if Z.eqb (l__75) (2) then Fault_Alignment
   else if Z.eqb (l__75) (3) then Fault_Background
   else if Z.eqb (l__75) (4) then Fault_Domain
   else if Z.eqb (l__75) (5) then Fault_Permission
   else if Z.eqb (l__75) (6) then Fault_Translation
   else if Z.eqb (l__75) (7) then Fault_AddressSize
   else if Z.eqb (l__75) (8) then Fault_SyncExternal
   else if Z.eqb (l__75) (9) then Fault_SyncExternalOnWalk
   else if Z.eqb (l__75) (10) then Fault_SyncParity
   else if Z.eqb (l__75) (11) then Fault_SyncParityOnWalk
   else if Z.eqb (l__75) (12) then Fault_AsyncParity
   else if Z.eqb (l__75) (13) then Fault_AsyncExternal
   else if Z.eqb (l__75) (14) then Fault_Debug
   else if Z.eqb (l__75) (15) then Fault_TLBConflict
   else if Z.eqb (l__75) (16) then Fault_Lockdown
   else if Z.eqb (l__75) (17) then Fault_Exclusive
   else Fault_ICacheMaint.

Lemma Fault_num_of_roundtrip (x : Fault) : Fault_of_num (num_of_Fault x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Fault_injective (x y : Fault) : num_of_Fault x = num_of_Fault y -> x = y.
  intro.
  rewrite <- (Fault_num_of_roundtrip x).
  rewrite <- (Fault_num_of_roundtrip y).
  congruence.
Qed.
Definition Fault_eq_dec (x y : Fault) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Fault x) (num_of_Fault y) with
  | left e => left (num_of_Fault_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Fault_beq (x y : Fault) : bool :=
  Z.eqb (num_of_Fault x) (num_of_Fault y).
Lemma Fault_beq_iff x y : Fault_beq x y = true <-> x = y.
  unfold Fault_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Fault_injective | congruence].
Qed.
Lemma Fault_beq_refl x : Fault_beq x x = true.
apply Fault_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Fault : EqDecision Fault := Fault_eq_dec.
#[export]
Instance Countable_Fault : Countable Fault.
refine {|
  encode x := encode (num_of_Fault x);
  decode x := z ← decode x; mret (Fault_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Fault_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Fault : Inhabited Fault := { inhabitant := Fault_None }.


Record FaultRecord := {
  FaultRecord_faulttype : Fault;
  FaultRecord_acctype : AccType;
  FaultRecord_ipaddress : bits 48;
  FaultRecord_s2fs1walk : boolean;
  FaultRecord_write : boolean;
  FaultRecord_level : uinteger;
  FaultRecord_extflag : bitU;
  FaultRecord_secondstage : boolean;
  FaultRecord_domain : bits 4;
  FaultRecord_debugmoe : bits 4;
}.
Arguments FaultRecord : clear implicits.
#[export]
Instance Decidable_eq_FaultRecord : EqDecision FaultRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_FaultRecord : Countable FaultRecord.
refine {|
  encode x := encode (FaultRecord_faulttype x, FaultRecord_acctype x, FaultRecord_ipaddress x, FaultRecord_s2fs1walk x, FaultRecord_write x, FaultRecord_level x, FaultRecord_extflag x, FaultRecord_secondstage x, FaultRecord_domain x, FaultRecord_debugmoe x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) ← decode x;
              mret (Build_FaultRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_FaultRecord : Settable _ := settable! Build_FaultRecord <FaultRecord_faulttype; FaultRecord_acctype; FaultRecord_ipaddress; FaultRecord_s2fs1walk; FaultRecord_write; FaultRecord_level; FaultRecord_extflag; FaultRecord_secondstage; FaultRecord_domain; FaultRecord_debugmoe>.
#[export]
Instance dummy_FaultRecord : Inhabited (FaultRecord) := {
  inhabitant := {|
    FaultRecord_faulttype := inhabitant;
    FaultRecord_acctype := inhabitant;
    FaultRecord_ipaddress := inhabitant;
    FaultRecord_s2fs1walk := inhabitant;
    FaultRecord_write := inhabitant;
    FaultRecord_level := inhabitant;
    FaultRecord_extflag := inhabitant;
    FaultRecord_secondstage := inhabitant;
    FaultRecord_domain := inhabitant;
    FaultRecord_debugmoe := inhabitant
|} }.


Record MemAttrHints := {
  MemAttrHints_attrs : bits 2;
  MemAttrHints_hints : bits 2;
  MemAttrHints_transient : boolean;
}.
Arguments MemAttrHints : clear implicits.
#[export]
Instance Decidable_eq_MemAttrHints : EqDecision MemAttrHints.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MemAttrHints : Countable MemAttrHints.
refine {|
  encode x := encode (MemAttrHints_attrs x, MemAttrHints_hints x, MemAttrHints_transient x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_MemAttrHints x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MemAttrHints : Settable _ := settable! Build_MemAttrHints <MemAttrHints_attrs; MemAttrHints_hints; MemAttrHints_transient>.
#[export]
Instance dummy_MemAttrHints : Inhabited (MemAttrHints) := {
  inhabitant := {|
    MemAttrHints_attrs := inhabitant;
    MemAttrHints_hints := inhabitant;
    MemAttrHints_transient := inhabitant
|} }.


Inductive MemType := MemType_Normal | MemType_Device.
Definition num_of_MemType (arg_ : MemType) : Z :=
   match arg_ with | MemType_Normal => 0 | MemType_Device => 1 end.

Definition MemType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : MemType :=
   let l__74 := arg_ in
   if Z.eqb (l__74) (0) then MemType_Normal
   else MemType_Device.

Lemma MemType_num_of_roundtrip (x : MemType) : MemType_of_num (num_of_MemType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemType_injective (x y : MemType) : num_of_MemType x = num_of_MemType y -> x = y.
  intro.
  rewrite <- (MemType_num_of_roundtrip x).
  rewrite <- (MemType_num_of_roundtrip y).
  congruence.
Qed.
Definition MemType_eq_dec (x y : MemType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemType x) (num_of_MemType y) with
  | left e => left (num_of_MemType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemType_beq (x y : MemType) : bool :=
  Z.eqb (num_of_MemType x) (num_of_MemType y).
Lemma MemType_beq_iff x y : MemType_beq x y = true <-> x = y.
  unfold MemType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemType_injective | congruence].
Qed.
Lemma MemType_beq_refl x : MemType_beq x x = true.
apply MemType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemType : EqDecision MemType := MemType_eq_dec.
#[export]
Instance Countable_MemType : Countable MemType.
refine {|
  encode x := encode (num_of_MemType x);
  decode x := z ← decode x; mret (MemType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemType : Inhabited MemType := { inhabitant := MemType_Normal }.


Record MemoryAttributes := {
  MemoryAttributes_MA_type : MemType;
  MemoryAttributes_shareable : boolean;
}.
Arguments MemoryAttributes : clear implicits.
#[export]
Instance Decidable_eq_MemoryAttributes : EqDecision MemoryAttributes.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MemoryAttributes : Countable MemoryAttributes.
refine {|
  encode x := encode (MemoryAttributes_MA_type x, MemoryAttributes_shareable x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_MemoryAttributes x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MemoryAttributes : Settable _ := settable! Build_MemoryAttributes <MemoryAttributes_MA_type; MemoryAttributes_shareable>.
#[export]
Instance dummy_MemoryAttributes : Inhabited (MemoryAttributes) := {
  inhabitant := {| MemoryAttributes_MA_type := inhabitant; MemoryAttributes_shareable := inhabitant
|} }.


Record FullAddress := {
  FullAddress_physicaladdress : bits 64;
  FullAddress_NS : bitU;
}.
Arguments FullAddress : clear implicits.
#[export]
Instance Decidable_eq_FullAddress : EqDecision FullAddress.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_FullAddress : Countable FullAddress.
refine {|
  encode x := encode (FullAddress_physicaladdress x, FullAddress_NS x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_FullAddress x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_FullAddress : Settable _ := settable! Build_FullAddress <FullAddress_physicaladdress; FullAddress_NS>.
#[export]
Instance dummy_FullAddress : Inhabited (FullAddress) := {
  inhabitant := {| FullAddress_physicaladdress := inhabitant; FullAddress_NS := inhabitant
|} }.


Record AddressDescriptor := {
  AddressDescriptor_fault : FaultRecord;
  AddressDescriptor_memattrs : MemoryAttributes;
  AddressDescriptor_paddress : FullAddress;
}.
Arguments AddressDescriptor : clear implicits.
#[export]
Instance Decidable_eq_AddressDescriptor : EqDecision AddressDescriptor.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_AddressDescriptor : Countable AddressDescriptor.
refine {|
  encode x := encode (AddressDescriptor_fault x, AddressDescriptor_memattrs x, AddressDescriptor_paddress x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_AddressDescriptor x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_AddressDescriptor : Settable _ := settable! Build_AddressDescriptor <AddressDescriptor_fault; AddressDescriptor_memattrs; AddressDescriptor_paddress>.
#[export]
Instance dummy_AddressDescriptor : Inhabited (AddressDescriptor) := {
  inhabitant := {|
    AddressDescriptor_fault := inhabitant;
    AddressDescriptor_memattrs := inhabitant;
    AddressDescriptor_paddress := inhabitant
|} }.


Inductive PrefetchHint := Prefetch_READ | Prefetch_WRITE | Prefetch_EXEC.
Definition num_of_PrefetchHint (arg_ : PrefetchHint) : Z :=
   match arg_ with | Prefetch_READ => 0 | Prefetch_WRITE => 1 | Prefetch_EXEC => 2 end.

Definition PrefetchHint_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : PrefetchHint :=
   let l__72 := arg_ in
   if Z.eqb (l__72) (0) then Prefetch_READ
   else if Z.eqb (l__72) (1) then Prefetch_WRITE
   else Prefetch_EXEC.

Lemma PrefetchHint_num_of_roundtrip (x : PrefetchHint) : PrefetchHint_of_num (num_of_PrefetchHint x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_PrefetchHint_injective (x y : PrefetchHint) : num_of_PrefetchHint x = num_of_PrefetchHint y -> x = y.
  intro.
  rewrite <- (PrefetchHint_num_of_roundtrip x).
  rewrite <- (PrefetchHint_num_of_roundtrip y).
  congruence.
Qed.
Definition PrefetchHint_eq_dec (x y : PrefetchHint) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_PrefetchHint x) (num_of_PrefetchHint y) with
  | left e => left (num_of_PrefetchHint_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition PrefetchHint_beq (x y : PrefetchHint) : bool :=
  Z.eqb (num_of_PrefetchHint x) (num_of_PrefetchHint y).
Lemma PrefetchHint_beq_iff x y : PrefetchHint_beq x y = true <-> x = y.
  unfold PrefetchHint_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_PrefetchHint_injective | congruence].
Qed.
Lemma PrefetchHint_beq_refl x : PrefetchHint_beq x x = true.
apply PrefetchHint_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_PrefetchHint : EqDecision PrefetchHint := PrefetchHint_eq_dec.
#[export]
Instance Countable_PrefetchHint : Countable PrefetchHint.
refine {|
  encode x := encode (num_of_PrefetchHint x);
  decode x := z ← decode x; mret (PrefetchHint_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite PrefetchHint_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_PrefetchHint : Inhabited PrefetchHint := { inhabitant := Prefetch_READ }.


Inductive CountOp := CountOp_CLZ | CountOp_CLS | CountOp_CNT.
Definition num_of_CountOp (arg_ : CountOp) : Z :=
   match arg_ with | CountOp_CLZ => 0 | CountOp_CLS => 1 | CountOp_CNT => 2 end.

Definition CountOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : CountOp :=
   let l__70 := arg_ in
   if Z.eqb (l__70) (0) then CountOp_CLZ
   else if Z.eqb (l__70) (1) then CountOp_CLS
   else CountOp_CNT.

Lemma CountOp_num_of_roundtrip (x : CountOp) : CountOp_of_num (num_of_CountOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CountOp_injective (x y : CountOp) : num_of_CountOp x = num_of_CountOp y -> x = y.
  intro.
  rewrite <- (CountOp_num_of_roundtrip x).
  rewrite <- (CountOp_num_of_roundtrip y).
  congruence.
Qed.
Definition CountOp_eq_dec (x y : CountOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CountOp x) (num_of_CountOp y) with
  | left e => left (num_of_CountOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CountOp_beq (x y : CountOp) : bool :=
  Z.eqb (num_of_CountOp x) (num_of_CountOp y).
Lemma CountOp_beq_iff x y : CountOp_beq x y = true <-> x = y.
  unfold CountOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CountOp_injective | congruence].
Qed.
Lemma CountOp_beq_refl x : CountOp_beq x x = true.
apply CountOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CountOp : EqDecision CountOp := CountOp_eq_dec.
#[export]
Instance Countable_CountOp : Countable CountOp.
refine {|
  encode x := encode (num_of_CountOp x);
  decode x := z ← decode x; mret (CountOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CountOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CountOp : Inhabited CountOp := { inhabitant := CountOp_CLZ }.


Inductive ExtendType :=
  | ExtendType_SXTB
  | ExtendType_SXTH
  | ExtendType_SXTW
  | ExtendType_SXTX
  | ExtendType_UXTB
  | ExtendType_UXTH
  | ExtendType_UXTW
  | ExtendType_UXTX.
Definition num_of_ExtendType (arg_ : ExtendType) : Z :=
   match arg_ with
   | ExtendType_SXTB => 0
   | ExtendType_SXTH => 1
   | ExtendType_SXTW => 2
   | ExtendType_SXTX => 3
   | ExtendType_UXTB => 4
   | ExtendType_UXTH => 5
   | ExtendType_UXTW => 6
   | ExtendType_UXTX => 7
   end.

Definition ExtendType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 7)*) : ExtendType :=
   let l__63 := arg_ in
   if Z.eqb (l__63) (0) then ExtendType_SXTB
   else if Z.eqb (l__63) (1) then ExtendType_SXTH
   else if Z.eqb (l__63) (2) then ExtendType_SXTW
   else if Z.eqb (l__63) (3) then ExtendType_SXTX
   else if Z.eqb (l__63) (4) then ExtendType_UXTB
   else if Z.eqb (l__63) (5) then ExtendType_UXTH
   else if Z.eqb (l__63) (6) then ExtendType_UXTW
   else ExtendType_UXTX.

Lemma ExtendType_num_of_roundtrip (x : ExtendType) : ExtendType_of_num (num_of_ExtendType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_ExtendType_injective (x y : ExtendType) : num_of_ExtendType x = num_of_ExtendType y -> x = y.
  intro.
  rewrite <- (ExtendType_num_of_roundtrip x).
  rewrite <- (ExtendType_num_of_roundtrip y).
  congruence.
Qed.
Definition ExtendType_eq_dec (x y : ExtendType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_ExtendType x) (num_of_ExtendType y) with
  | left e => left (num_of_ExtendType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition ExtendType_beq (x y : ExtendType) : bool :=
  Z.eqb (num_of_ExtendType x) (num_of_ExtendType y).
Lemma ExtendType_beq_iff x y : ExtendType_beq x y = true <-> x = y.
  unfold ExtendType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_ExtendType_injective | congruence].
Qed.
Lemma ExtendType_beq_refl x : ExtendType_beq x x = true.
apply ExtendType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_ExtendType : EqDecision ExtendType := ExtendType_eq_dec.
#[export]
Instance Countable_ExtendType : Countable ExtendType.
refine {|
  encode x := encode (num_of_ExtendType x);
  decode x := z ← decode x; mret (ExtendType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite ExtendType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_ExtendType : Inhabited ExtendType := { inhabitant := ExtendType_SXTB }.


Inductive RevOp := RevOp_RBIT | RevOp_REV16 | RevOp_REV32 | RevOp_REV64.
Definition num_of_RevOp (arg_ : RevOp) : Z :=
   match arg_ with | RevOp_RBIT => 0 | RevOp_REV16 => 1 | RevOp_REV32 => 2 | RevOp_REV64 => 3 end.

Definition RevOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : RevOp :=
   let l__60 := arg_ in
   if Z.eqb (l__60) (0) then RevOp_RBIT
   else if Z.eqb (l__60) (1) then RevOp_REV16
   else if Z.eqb (l__60) (2) then RevOp_REV32
   else RevOp_REV64.

Lemma RevOp_num_of_roundtrip (x : RevOp) : RevOp_of_num (num_of_RevOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_RevOp_injective (x y : RevOp) : num_of_RevOp x = num_of_RevOp y -> x = y.
  intro.
  rewrite <- (RevOp_num_of_roundtrip x).
  rewrite <- (RevOp_num_of_roundtrip y).
  congruence.
Qed.
Definition RevOp_eq_dec (x y : RevOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_RevOp x) (num_of_RevOp y) with
  | left e => left (num_of_RevOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition RevOp_beq (x y : RevOp) : bool :=
  Z.eqb (num_of_RevOp x) (num_of_RevOp y).
Lemma RevOp_beq_iff x y : RevOp_beq x y = true <-> x = y.
  unfold RevOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_RevOp_injective | congruence].
Qed.
Lemma RevOp_beq_refl x : RevOp_beq x x = true.
apply RevOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_RevOp : EqDecision RevOp := RevOp_eq_dec.
#[export]
Instance Countable_RevOp : Countable RevOp.
refine {|
  encode x := encode (num_of_RevOp x);
  decode x := z ← decode x; mret (RevOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite RevOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_RevOp : Inhabited RevOp := { inhabitant := RevOp_RBIT }.


Inductive ShiftType := ShiftType_LSL | ShiftType_LSR | ShiftType_ASR | ShiftType_ROR.
Definition num_of_ShiftType (arg_ : ShiftType) : Z :=
   match arg_ with
   | ShiftType_LSL => 0
   | ShiftType_LSR => 1
   | ShiftType_ASR => 2
   | ShiftType_ROR => 3
   end.

Definition ShiftType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : ShiftType :=
   let l__57 := arg_ in
   if Z.eqb (l__57) (0) then ShiftType_LSL
   else if Z.eqb (l__57) (1) then ShiftType_LSR
   else if Z.eqb (l__57) (2) then ShiftType_ASR
   else ShiftType_ROR.

Lemma ShiftType_num_of_roundtrip (x : ShiftType) : ShiftType_of_num (num_of_ShiftType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_ShiftType_injective (x y : ShiftType) : num_of_ShiftType x = num_of_ShiftType y -> x = y.
  intro.
  rewrite <- (ShiftType_num_of_roundtrip x).
  rewrite <- (ShiftType_num_of_roundtrip y).
  congruence.
Qed.
Definition ShiftType_eq_dec (x y : ShiftType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_ShiftType x) (num_of_ShiftType y) with
  | left e => left (num_of_ShiftType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition ShiftType_beq (x y : ShiftType) : bool :=
  Z.eqb (num_of_ShiftType x) (num_of_ShiftType y).
Lemma ShiftType_beq_iff x y : ShiftType_beq x y = true <-> x = y.
  unfold ShiftType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_ShiftType_injective | congruence].
Qed.
Lemma ShiftType_beq_refl x : ShiftType_beq x x = true.
apply ShiftType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_ShiftType : EqDecision ShiftType := ShiftType_eq_dec.
#[export]
Instance Countable_ShiftType : Countable ShiftType.
refine {|
  encode x := encode (num_of_ShiftType x);
  decode x := z ← decode x; mret (ShiftType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite ShiftType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_ShiftType : Inhabited ShiftType := { inhabitant := ShiftType_LSL }.


Inductive LogicalOp := LogicalOp_AND | LogicalOp_EOR | LogicalOp_ORR.
Definition num_of_LogicalOp (arg_ : LogicalOp) : Z :=
   match arg_ with | LogicalOp_AND => 0 | LogicalOp_EOR => 1 | LogicalOp_ORR => 2 end.

Definition LogicalOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : LogicalOp :=
   let l__55 := arg_ in
   if Z.eqb (l__55) (0) then LogicalOp_AND
   else if Z.eqb (l__55) (1) then LogicalOp_EOR
   else LogicalOp_ORR.

Lemma LogicalOp_num_of_roundtrip (x : LogicalOp) : LogicalOp_of_num (num_of_LogicalOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_LogicalOp_injective (x y : LogicalOp) : num_of_LogicalOp x = num_of_LogicalOp y -> x = y.
  intro.
  rewrite <- (LogicalOp_num_of_roundtrip x).
  rewrite <- (LogicalOp_num_of_roundtrip y).
  congruence.
Qed.
Definition LogicalOp_eq_dec (x y : LogicalOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_LogicalOp x) (num_of_LogicalOp y) with
  | left e => left (num_of_LogicalOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition LogicalOp_beq (x y : LogicalOp) : bool :=
  Z.eqb (num_of_LogicalOp x) (num_of_LogicalOp y).
Lemma LogicalOp_beq_iff x y : LogicalOp_beq x y = true <-> x = y.
  unfold LogicalOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_LogicalOp_injective | congruence].
Qed.
Lemma LogicalOp_beq_refl x : LogicalOp_beq x x = true.
apply LogicalOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_LogicalOp : EqDecision LogicalOp := LogicalOp_eq_dec.
#[export]
Instance Countable_LogicalOp : Countable LogicalOp.
refine {|
  encode x := encode (num_of_LogicalOp x);
  decode x := z ← decode x; mret (LogicalOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite LogicalOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_LogicalOp : Inhabited LogicalOp := { inhabitant := LogicalOp_AND }.


Inductive MemOp := MemOp_LOAD | MemOp_STORE | MemOp_PREFETCH.
Definition num_of_MemOp (arg_ : MemOp) : Z :=
   match arg_ with | MemOp_LOAD => 0 | MemOp_STORE => 1 | MemOp_PREFETCH => 2 end.

Definition MemOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MemOp :=
   let l__53 := arg_ in
   if Z.eqb (l__53) (0) then MemOp_LOAD
   else if Z.eqb (l__53) (1) then MemOp_STORE
   else MemOp_PREFETCH.

Lemma MemOp_num_of_roundtrip (x : MemOp) : MemOp_of_num (num_of_MemOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemOp_injective (x y : MemOp) : num_of_MemOp x = num_of_MemOp y -> x = y.
  intro.
  rewrite <- (MemOp_num_of_roundtrip x).
  rewrite <- (MemOp_num_of_roundtrip y).
  congruence.
Qed.
Definition MemOp_eq_dec (x y : MemOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemOp x) (num_of_MemOp y) with
  | left e => left (num_of_MemOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemOp_beq (x y : MemOp) : bool :=
  Z.eqb (num_of_MemOp x) (num_of_MemOp y).
Lemma MemOp_beq_iff x y : MemOp_beq x y = true <-> x = y.
  unfold MemOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemOp_injective | congruence].
Qed.
Lemma MemOp_beq_refl x : MemOp_beq x x = true.
apply MemOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemOp : EqDecision MemOp := MemOp_eq_dec.
#[export]
Instance Countable_MemOp : Countable MemOp.
refine {|
  encode x := encode (num_of_MemOp x);
  decode x := z ← decode x; mret (MemOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemOp : Inhabited MemOp := { inhabitant := MemOp_LOAD }.


Inductive MemBarrierOp := MemBarrierOp_DSB | MemBarrierOp_DMB | MemBarrierOp_ISB.
Definition num_of_MemBarrierOp (arg_ : MemBarrierOp) : Z :=
   match arg_ with | MemBarrierOp_DSB => 0 | MemBarrierOp_DMB => 1 | MemBarrierOp_ISB => 2 end.

Definition MemBarrierOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MemBarrierOp :=
   let l__51 := arg_ in
   if Z.eqb (l__51) (0) then MemBarrierOp_DSB
   else if Z.eqb (l__51) (1) then MemBarrierOp_DMB
   else MemBarrierOp_ISB.

Lemma MemBarrierOp_num_of_roundtrip (x : MemBarrierOp) : MemBarrierOp_of_num (num_of_MemBarrierOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemBarrierOp_injective (x y : MemBarrierOp) : num_of_MemBarrierOp x = num_of_MemBarrierOp y -> x = y.
  intro.
  rewrite <- (MemBarrierOp_num_of_roundtrip x).
  rewrite <- (MemBarrierOp_num_of_roundtrip y).
  congruence.
Qed.
Definition MemBarrierOp_eq_dec (x y : MemBarrierOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemBarrierOp x) (num_of_MemBarrierOp y) with
  | left e => left (num_of_MemBarrierOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemBarrierOp_beq (x y : MemBarrierOp) : bool :=
  Z.eqb (num_of_MemBarrierOp x) (num_of_MemBarrierOp y).
Lemma MemBarrierOp_beq_iff x y : MemBarrierOp_beq x y = true <-> x = y.
  unfold MemBarrierOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemBarrierOp_injective | congruence].
Qed.
Lemma MemBarrierOp_beq_refl x : MemBarrierOp_beq x x = true.
apply MemBarrierOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemBarrierOp : EqDecision MemBarrierOp := MemBarrierOp_eq_dec.
#[export]
Instance Countable_MemBarrierOp : Countable MemBarrierOp.
refine {|
  encode x := encode (num_of_MemBarrierOp x);
  decode x := z ← decode x; mret (MemBarrierOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemBarrierOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemBarrierOp : Inhabited MemBarrierOp := { inhabitant := MemBarrierOp_DSB }.


Inductive SystemHintOp :=
  | SystemHintOp_NOP
  | SystemHintOp_YIELD
  | SystemHintOp_WFE
  | SystemHintOp_WFI
  | SystemHintOp_SEV
  | SystemHintOp_SEVL.
Definition num_of_SystemHintOp (arg_ : SystemHintOp) : Z :=
   match arg_ with
   | SystemHintOp_NOP => 0
   | SystemHintOp_YIELD => 1
   | SystemHintOp_WFE => 2
   | SystemHintOp_WFI => 3
   | SystemHintOp_SEV => 4
   | SystemHintOp_SEVL => 5
   end.

Definition SystemHintOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 5)*) : SystemHintOp :=
   let l__46 := arg_ in
   if Z.eqb (l__46) (0) then SystemHintOp_NOP
   else if Z.eqb (l__46) (1) then SystemHintOp_YIELD
   else if Z.eqb (l__46) (2) then SystemHintOp_WFE
   else if Z.eqb (l__46) (3) then SystemHintOp_WFI
   else if Z.eqb (l__46) (4) then SystemHintOp_SEV
   else SystemHintOp_SEVL.

Lemma SystemHintOp_num_of_roundtrip (x : SystemHintOp) : SystemHintOp_of_num (num_of_SystemHintOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_SystemHintOp_injective (x y : SystemHintOp) : num_of_SystemHintOp x = num_of_SystemHintOp y -> x = y.
  intro.
  rewrite <- (SystemHintOp_num_of_roundtrip x).
  rewrite <- (SystemHintOp_num_of_roundtrip y).
  congruence.
Qed.
Definition SystemHintOp_eq_dec (x y : SystemHintOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_SystemHintOp x) (num_of_SystemHintOp y) with
  | left e => left (num_of_SystemHintOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition SystemHintOp_beq (x y : SystemHintOp) : bool :=
  Z.eqb (num_of_SystemHintOp x) (num_of_SystemHintOp y).
Lemma SystemHintOp_beq_iff x y : SystemHintOp_beq x y = true <-> x = y.
  unfold SystemHintOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_SystemHintOp_injective | congruence].
Qed.
Lemma SystemHintOp_beq_refl x : SystemHintOp_beq x x = true.
apply SystemHintOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_SystemHintOp : EqDecision SystemHintOp := SystemHintOp_eq_dec.
#[export]
Instance Countable_SystemHintOp : Countable SystemHintOp.
refine {|
  encode x := encode (num_of_SystemHintOp x);
  decode x := z ← decode x; mret (SystemHintOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite SystemHintOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_SystemHintOp : Inhabited SystemHintOp := { inhabitant := SystemHintOp_NOP }.


Inductive PSTATEField := PSTATEField_DAIFSet | PSTATEField_DAIFClr | PSTATEField_SP.
Definition num_of_PSTATEField (arg_ : PSTATEField) : Z :=
   match arg_ with | PSTATEField_DAIFSet => 0 | PSTATEField_DAIFClr => 1 | PSTATEField_SP => 2 end.

Definition PSTATEField_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : PSTATEField :=
   let l__44 := arg_ in
   if Z.eqb (l__44) (0) then PSTATEField_DAIFSet
   else if Z.eqb (l__44) (1) then PSTATEField_DAIFClr
   else PSTATEField_SP.

Lemma PSTATEField_num_of_roundtrip (x : PSTATEField) : PSTATEField_of_num (num_of_PSTATEField x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_PSTATEField_injective (x y : PSTATEField) : num_of_PSTATEField x = num_of_PSTATEField y -> x = y.
  intro.
  rewrite <- (PSTATEField_num_of_roundtrip x).
  rewrite <- (PSTATEField_num_of_roundtrip y).
  congruence.
Qed.
Definition PSTATEField_eq_dec (x y : PSTATEField) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_PSTATEField x) (num_of_PSTATEField y) with
  | left e => left (num_of_PSTATEField_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition PSTATEField_beq (x y : PSTATEField) : bool :=
  Z.eqb (num_of_PSTATEField x) (num_of_PSTATEField y).
Lemma PSTATEField_beq_iff x y : PSTATEField_beq x y = true <-> x = y.
  unfold PSTATEField_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_PSTATEField_injective | congruence].
Qed.
Lemma PSTATEField_beq_refl x : PSTATEField_beq x x = true.
apply PSTATEField_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_PSTATEField : EqDecision PSTATEField := PSTATEField_eq_dec.
#[export]
Instance Countable_PSTATEField : Countable PSTATEField.
refine {|
  encode x := encode (num_of_PSTATEField x);
  decode x := z ← decode x; mret (PSTATEField_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite PSTATEField_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_PSTATEField : Inhabited PSTATEField := { inhabitant := PSTATEField_DAIFSet }.


Inductive SystemOp := Sys_AT | Sys_DC | Sys_IC | Sys_TLBI | Sys_SYS.
Definition num_of_SystemOp (arg_ : SystemOp) : Z :=
   match arg_ with | Sys_AT => 0 | Sys_DC => 1 | Sys_IC => 2 | Sys_TLBI => 3 | Sys_SYS => 4 end.

Definition SystemOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 4)*) : SystemOp :=
   let l__40 := arg_ in
   if Z.eqb (l__40) (0) then Sys_AT
   else if Z.eqb (l__40) (1) then Sys_DC
   else if Z.eqb (l__40) (2) then Sys_IC
   else if Z.eqb (l__40) (3) then Sys_TLBI
   else Sys_SYS.

Lemma SystemOp_num_of_roundtrip (x : SystemOp) : SystemOp_of_num (num_of_SystemOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_SystemOp_injective (x y : SystemOp) : num_of_SystemOp x = num_of_SystemOp y -> x = y.
  intro.
  rewrite <- (SystemOp_num_of_roundtrip x).
  rewrite <- (SystemOp_num_of_roundtrip y).
  congruence.
Qed.
Definition SystemOp_eq_dec (x y : SystemOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_SystemOp x) (num_of_SystemOp y) with
  | left e => left (num_of_SystemOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition SystemOp_beq (x y : SystemOp) : bool :=
  Z.eqb (num_of_SystemOp x) (num_of_SystemOp y).
Lemma SystemOp_beq_iff x y : SystemOp_beq x y = true <-> x = y.
  unfold SystemOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_SystemOp_injective | congruence].
Qed.
Lemma SystemOp_beq_refl x : SystemOp_beq x x = true.
apply SystemOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_SystemOp : EqDecision SystemOp := SystemOp_eq_dec.
#[export]
Instance Countable_SystemOp : Countable SystemOp.
refine {|
  encode x := encode (num_of_SystemOp x);
  decode x := z ← decode x; mret (SystemOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite SystemOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_SystemOp : Inhabited SystemOp := { inhabitant := Sys_AT }.


Inductive DCOp := IVAC | ISW | CSW | CISW | ZVA | CVAC | CVAU | CIVAC.
Definition num_of_DCOp (arg_ : DCOp) : Z :=
   match arg_ with
   | IVAC => 0
   | ISW => 1
   | CSW => 2
   | CISW => 3
   | ZVA => 4
   | CVAC => 5
   | CVAU => 6
   | CIVAC => 7
   end.

Definition DCOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 7)*) : DCOp :=
   let l__33 := arg_ in
   if Z.eqb (l__33) (0) then IVAC
   else if Z.eqb (l__33) (1) then ISW
   else if Z.eqb (l__33) (2) then CSW
   else if Z.eqb (l__33) (3) then CISW
   else if Z.eqb (l__33) (4) then ZVA
   else if Z.eqb (l__33) (5) then CVAC
   else if Z.eqb (l__33) (6) then CVAU
   else CIVAC.

Lemma DCOp_num_of_roundtrip (x : DCOp) : DCOp_of_num (num_of_DCOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_DCOp_injective (x y : DCOp) : num_of_DCOp x = num_of_DCOp y -> x = y.
  intro.
  rewrite <- (DCOp_num_of_roundtrip x).
  rewrite <- (DCOp_num_of_roundtrip y).
  congruence.
Qed.
Definition DCOp_eq_dec (x y : DCOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_DCOp x) (num_of_DCOp y) with
  | left e => left (num_of_DCOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition DCOp_beq (x y : DCOp) : bool :=
  Z.eqb (num_of_DCOp x) (num_of_DCOp y).
Lemma DCOp_beq_iff x y : DCOp_beq x y = true <-> x = y.
  unfold DCOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_DCOp_injective | congruence].
Qed.
Lemma DCOp_beq_refl x : DCOp_beq x x = true.
apply DCOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_DCOp : EqDecision DCOp := DCOp_eq_dec.
#[export]
Instance Countable_DCOp : Countable DCOp.
refine {|
  encode x := encode (num_of_DCOp x);
  decode x := z ← decode x; mret (DCOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite DCOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_DCOp : Inhabited DCOp := { inhabitant := IVAC }.


Inductive ICOp := IALLUIS | IALLU | IVAU.
Definition num_of_ICOp (arg_ : ICOp) : Z :=
   match arg_ with | IALLUIS => 0 | IALLU => 1 | IVAU => 2 end.

Definition ICOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : ICOp :=
   let l__31 := arg_ in
   if Z.eqb (l__31) (0) then IALLUIS
   else if Z.eqb (l__31) (1) then IALLU
   else IVAU.

Lemma ICOp_num_of_roundtrip (x : ICOp) : ICOp_of_num (num_of_ICOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_ICOp_injective (x y : ICOp) : num_of_ICOp x = num_of_ICOp y -> x = y.
  intro.
  rewrite <- (ICOp_num_of_roundtrip x).
  rewrite <- (ICOp_num_of_roundtrip y).
  congruence.
Qed.
Definition ICOp_eq_dec (x y : ICOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_ICOp x) (num_of_ICOp y) with
  | left e => left (num_of_ICOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition ICOp_beq (x y : ICOp) : bool :=
  Z.eqb (num_of_ICOp x) (num_of_ICOp y).
Lemma ICOp_beq_iff x y : ICOp_beq x y = true <-> x = y.
  unfold ICOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_ICOp_injective | congruence].
Qed.
Lemma ICOp_beq_refl x : ICOp_beq x x = true.
apply ICOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_ICOp : EqDecision ICOp := ICOp_eq_dec.
#[export]
Instance Countable_ICOp : Countable ICOp.
refine {|
  encode x := encode (num_of_ICOp x);
  decode x := z ← decode x; mret (ICOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite ICOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_ICOp : Inhabited ICOp := { inhabitant := IALLUIS }.


Inductive signalValue := LOw | HIGH.
Definition num_of_signalValue (arg_ : signalValue) : Z :=
   match arg_ with | LOw => 0 | HIGH => 1 end.

Definition signalValue_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : signalValue :=
   let l__30 := arg_ in
   if Z.eqb (l__30) (0) then LOw
   else HIGH.

Lemma signalValue_num_of_roundtrip (x : signalValue) : signalValue_of_num (num_of_signalValue x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_signalValue_injective (x y : signalValue) : num_of_signalValue x = num_of_signalValue y -> x = y.
  intro.
  rewrite <- (signalValue_num_of_roundtrip x).
  rewrite <- (signalValue_num_of_roundtrip y).
  congruence.
Qed.
Definition signalValue_eq_dec (x y : signalValue) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_signalValue x) (num_of_signalValue y) with
  | left e => left (num_of_signalValue_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition signalValue_beq (x y : signalValue) : bool :=
  Z.eqb (num_of_signalValue x) (num_of_signalValue y).
Lemma signalValue_beq_iff x y : signalValue_beq x y = true <-> x = y.
  unfold signalValue_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_signalValue_injective | congruence].
Qed.
Lemma signalValue_beq_refl x : signalValue_beq x x = true.
apply signalValue_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_signalValue : EqDecision signalValue := signalValue_eq_dec.
#[export]
Instance Countable_signalValue : Countable signalValue.
refine {|
  encode x := encode (num_of_signalValue x);
  decode x := z ← decode x; mret (signalValue_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite signalValue_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_signalValue : Inhabited signalValue := { inhabitant := LOw }.


Record read_buffer_type := {
  read_buffer_type_acctype : AccType;
  read_buffer_type_exclusive : bool;
  read_buffer_type_address : bits 64;
  read_buffer_type_size : uinteger;
}.
Arguments read_buffer_type : clear implicits.
#[export]
Instance Decidable_eq_read_buffer_type : EqDecision read_buffer_type.
   intros [x0 x1 x2 x3].
   intros [y0 y1 y2 y3].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_read_buffer_type : Countable read_buffer_type.
refine {|
  encode x := encode (read_buffer_type_acctype x, read_buffer_type_exclusive x, read_buffer_type_address x, read_buffer_type_size x);
  decode x := '(x0, x1, x2, x3) ← decode x;
              mret (Build_read_buffer_type x0 x1 x2 x3)
|}.
abstract (
  intros [x0 x1 x2 x3];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_read_buffer_type : Settable _ := settable! Build_read_buffer_type <read_buffer_type_acctype; read_buffer_type_exclusive; read_buffer_type_address; read_buffer_type_size>.
#[export]
Instance dummy_read_buffer_type : Inhabited (read_buffer_type) := {
  inhabitant := {|
    read_buffer_type_acctype := inhabitant;
    read_buffer_type_exclusive := inhabitant;
    read_buffer_type_address := inhabitant;
    read_buffer_type_size := inhabitant
|} }.


Record write_buffer_type := {
  write_buffer_type_acctype : AccType;
  write_buffer_type_exclusive : bool;
  write_buffer_type_address : bits 64;
  write_buffer_type_value : bits 128;
  write_buffer_type_size : Z;
}.
Arguments write_buffer_type : clear implicits.
#[export]
Instance Decidable_eq_write_buffer_type : EqDecision write_buffer_type.
   intros [x0 x1 x2 x3 x4].
   intros [y0 y1 y2 y3 y4].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_write_buffer_type : Countable write_buffer_type.
refine {|
  encode x := encode (write_buffer_type_acctype x, write_buffer_type_exclusive x, write_buffer_type_address x, write_buffer_type_value x, write_buffer_type_size x);
  decode x := '(x0, x1, x2, x3, x4) ← decode x;
              mret (Build_write_buffer_type x0 x1 x2 x3 x4)
|}.
abstract (
  intros [x0 x1 x2 x3 x4];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_write_buffer_type : Settable _ := settable! Build_write_buffer_type <write_buffer_type_acctype; write_buffer_type_exclusive; write_buffer_type_address; write_buffer_type_value; write_buffer_type_size>.
#[export]
Instance dummy_write_buffer_type : Inhabited (write_buffer_type) := {
  inhabitant := {|
    write_buffer_type_acctype := inhabitant;
    write_buffer_type_exclusive := inhabitant;
    write_buffer_type_address := inhabitant;
    write_buffer_type_value := inhabitant;
    write_buffer_type_size := inhabitant
|} }.


Definition RegisterSize (R' : Z) : bool := member_Z_list R' [32; 64].
#[export] Hint Unfold RegisterSize : sail.

Definition DataSize (D : Z) : bool := member_Z_list D [8; 16; 32; 64].
#[export] Hint Unfold DataSize : sail.

Inductive ast :=
| Unallocated : unit -> ast
| ImplementationDefinedTestBeginEnd : boolean -> ast
| ImplementationDefinedStopFetching : unit -> ast
| ImplementationDefinedThreadStart : unit -> ast
| TMStart : reg_index -> ast
| TMCommit : unit -> ast
| TMAbort : (boolean * bits 5) -> ast
| TMTest : unit -> ast
| CompareAndBranch : (reg_index * Z * boolean * bits 64) -> ast
| BranchConditional : (bits 64 * bits 4) -> ast
| GenerateExceptionEL1 : bits 16 -> ast
| GenerateExceptionEL2 : bits 16 -> ast
| GenerateExceptionEL3 : bits 16 -> ast
| DebugBreakpoint : bits 16 -> ast
| ExternalDebugBreakpoint : unit -> ast
| DebugSwitchToExceptionLevel : bits 2 -> ast
| MoveSystemImmediate : (bits 4 * PSTATEField) -> ast
| Hint : SystemHintOp -> ast
| ClearExclusiveMonitor : uinteger -> ast
| Barrier : (MemBarrierOp * MBReqDomain * MBReqTypes) -> ast
| System : (reg_index * uinteger * uinteger * uinteger * uinteger * uinteger * boolean) -> ast
| DataCache : (reg_index * DCOp) -> ast
| InstructionCache : (reg_index * ICOp) -> ast
| MoveSystemRegister : (reg_index * uinteger * uinteger * uinteger * uinteger * uinteger * boolean) -> ast
| TestBitAndBranch : (reg_index * Z * Z * bitU * bits 64) -> ast
| BranchImmediate : (BranchType * bits 64) -> ast
| BranchRegister : (reg_index * BranchType) -> ast
| ExceptionReturn : unit -> ast
| DebugRestorePState : unit -> ast
| LoadLiteral : (reg_index * MemOp * boolean * Z * bits 64 * Z) -> ast
| LoadStoreAcqExc : (reg_index * reg_index * reg_index * reg_index * AccType * boolean * boolean * MemOp * Z * Z * Z) -> ast
| LoadStorePairNonTemp : (boolean * boolean * reg_index * reg_index * reg_index * AccType * MemOp * uinteger * Z * bits 64) -> ast
| LoadImmediate : (reg_index * reg_index * AccType * MemOp * boolean * boolean * boolean * bits 64 * Z * Z) -> ast
| LoadRegister : (reg_index * reg_index * reg_index * AccType * MemOp * boolean * boolean * boolean * ExtendType * Z * Z * Z) -> ast
| LoadStorePair : (boolean * boolean * reg_index * reg_index * reg_index * AccType * MemOp * boolean * Z * bits 64) -> ast
| AddSubImmediate : {R' & (reg_index * reg_index * Z * boolean * boolean * bits R')}%type -> ast
| BitfieldMove : {R' & (reg_index * reg_index * Z * boolean * boolean * Z * Z * bits R' * bits R')}%type -> ast
| ExtractRegister : (reg_index * reg_index * reg_index * Z * Z) -> ast
| LogicalImmediate : {R' & (reg_index * reg_index * Z * boolean * LogicalOp * bits R')}%type -> ast
| MoveWide : (reg_index * Z * bits 16 * Z * MoveWideOp) -> ast
| Address : (reg_index * boolean * bits 64) -> ast
| AddSubExtendRegister : (reg_index * reg_index * reg_index * Z * boolean * boolean * ExtendType * Z) -> ast
| AddSubShiftedRegister : (reg_index * reg_index * reg_index * Z * boolean * boolean * ShiftType * Z) -> ast
| AddSubCarry : (reg_index * reg_index * reg_index * Z * boolean * boolean) -> ast
| ConditionalCompareImmediate : {R' & (reg_index * Z * boolean * bits 4 * bits 4 * bits R')}%type -> ast
| ConditionalCompareRegister : (reg_index * reg_index * Z * boolean * bits 4 * bits 4) -> ast
| ConditionalSelect : (reg_index * reg_index * reg_index * Z * bits 4 * boolean * boolean) -> ast
| Reverse : (reg_index * reg_index * Z * RevOp) -> ast
| CountLeading : (reg_index * reg_index * Z * CountOp) -> ast
| Division : (reg_index * reg_index * reg_index * Z * boolean) -> ast
| Shift : (reg_index * reg_index * reg_index * Z * ShiftType) -> ast
| CRC : (reg_index * reg_index * reg_index * Z * boolean) -> ast
| MultiplyAddSub : (reg_index * reg_index * reg_index * reg_index * Z * Z * boolean) -> ast
| MultiplyAddSubLong : (reg_index * reg_index * reg_index * reg_index * Z * Z * boolean * boolean) -> ast
| MultiplyHigh : (reg_index * reg_index * reg_index * reg_index * Z * Z * boolean) -> ast
| LogicalShiftedRegister : (reg_index * reg_index * reg_index * Z * boolean * LogicalOp * ShiftType * Z * boolean) -> ast.
Arguments ast : clear implicits.

Definition sail_ast_encode (x : ast) := match x with
  | Unallocated x' => encode (0, encode x')
  | ImplementationDefinedTestBeginEnd x' => encode (1, encode x')
  | ImplementationDefinedStopFetching x' => encode (2, encode x')
  | ImplementationDefinedThreadStart x' => encode (3, encode x')
  | TMStart x' => encode (4, encode x')
  | TMCommit x' => encode (5, encode x')
  | TMAbort x' => encode (6, encode x')
  | TMTest x' => encode (7, encode x')
  | CompareAndBranch x' => encode (8, encode x')
  | BranchConditional x' => encode (9, encode x')
  | GenerateExceptionEL1 x' => encode (10, encode x')
  | GenerateExceptionEL2 x' => encode (11, encode x')
  | GenerateExceptionEL3 x' => encode (12, encode x')
  | DebugBreakpoint x' => encode (13, encode x')
  | ExternalDebugBreakpoint x' => encode (14, encode x')
  | DebugSwitchToExceptionLevel x' => encode (15, encode x')
  | MoveSystemImmediate x' => encode (16, encode x')
  | Hint x' => encode (17, encode x')
  | ClearExclusiveMonitor x' => encode (18, encode x')
  | Barrier x' => encode (19, encode x')
  | System x' => encode (20, encode x')
  | DataCache x' => encode (21, encode x')
  | InstructionCache x' => encode (22, encode x')
  | MoveSystemRegister x' => encode (23, encode x')
  | TestBitAndBranch x' => encode (24, encode x')
  | BranchImmediate x' => encode (25, encode x')
  | BranchRegister x' => encode (26, encode x')
  | ExceptionReturn x' => encode (27, encode x')
  | DebugRestorePState x' => encode (28, encode x')
  | LoadLiteral x' => encode (29, encode x')
  | LoadStoreAcqExc x' => encode (30, encode x')
  | LoadStorePairNonTemp x' => encode (31, encode x')
  | LoadImmediate x' => encode (32, encode x')
  | LoadRegister x' => encode (33, encode x')
  | LoadStorePair x' => encode (34, encode x')
  | AddSubImmediate x' => encode (35, encode x')
  | BitfieldMove x' => encode (36, encode x')
  | ExtractRegister x' => encode (37, encode x')
  | LogicalImmediate x' => encode (38, encode x')
  | MoveWide x' => encode (39, encode x')
  | Address x' => encode (40, encode x')
  | AddSubExtendRegister x' => encode (41, encode x')
  | AddSubShiftedRegister x' => encode (42, encode x')
  | AddSubCarry x' => encode (43, encode x')
  | ConditionalCompareImmediate x' => encode (44, encode x')
  | ConditionalCompareRegister x' => encode (45, encode x')
  | ConditionalSelect x' => encode (46, encode x')
  | Reverse x' => encode (47, encode x')
  | CountLeading x' => encode (48, encode x')
  | Division x' => encode (49, encode x')
  | Shift x' => encode (50, encode x')
  | CRC x' => encode (51, encode x')
  | MultiplyAddSub x' => encode (52, encode x')
  | MultiplyAddSubLong x' => encode (53, encode x')
  | MultiplyHigh x' => encode (54, encode x')
  | LogicalShiftedRegister x' => encode (55, encode x') end.
Definition sail_ast_decode x : option ast := match decode x with
  | Some (0, x') => Unallocated <$> decode x'
  | Some (1, x') => ImplementationDefinedTestBeginEnd <$> decode x'
  | Some (2, x') => ImplementationDefinedStopFetching <$> decode x'
  | Some (3, x') => ImplementationDefinedThreadStart <$> decode x'
  | Some (4, x') => TMStart <$> decode x'
  | Some (5, x') => TMCommit <$> decode x'
  | Some (6, x') => TMAbort <$> decode x'
  | Some (7, x') => TMTest <$> decode x'
  | Some (8, x') => CompareAndBranch <$> decode x'
  | Some (9, x') => BranchConditional <$> decode x'
  | Some (10, x') => GenerateExceptionEL1 <$> decode x'
  | Some (11, x') => GenerateExceptionEL2 <$> decode x'
  | Some (12, x') => GenerateExceptionEL3 <$> decode x'
  | Some (13, x') => DebugBreakpoint <$> decode x'
  | Some (14, x') => ExternalDebugBreakpoint <$> decode x'
  | Some (15, x') => DebugSwitchToExceptionLevel <$> decode x'
  | Some (16, x') => MoveSystemImmediate <$> decode x'
  | Some (17, x') => Hint <$> decode x'
  | Some (18, x') => ClearExclusiveMonitor <$> decode x'
  | Some (19, x') => Barrier <$> decode x'
  | Some (20, x') => System <$> decode x'
  | Some (21, x') => DataCache <$> decode x'
  | Some (22, x') => InstructionCache <$> decode x'
  | Some (23, x') => MoveSystemRegister <$> decode x'
  | Some (24, x') => TestBitAndBranch <$> decode x'
  | Some (25, x') => BranchImmediate <$> decode x'
  | Some (26, x') => BranchRegister <$> decode x'
  | Some (27, x') => ExceptionReturn <$> decode x'
  | Some (28, x') => DebugRestorePState <$> decode x'
  | Some (29, x') => LoadLiteral <$> decode x'
  | Some (30, x') => LoadStoreAcqExc <$> decode x'
  | Some (31, x') => LoadStorePairNonTemp <$> decode x'
  | Some (32, x') => LoadImmediate <$> decode x'
  | Some (33, x') => LoadRegister <$> decode x'
  | Some (34, x') => LoadStorePair <$> decode x'
  | Some (35, x') => AddSubImmediate <$> decode x'
  | Some (36, x') => BitfieldMove <$> decode x'
  | Some (37, x') => ExtractRegister <$> decode x'
  | Some (38, x') => LogicalImmediate <$> decode x'
  | Some (39, x') => MoveWide <$> decode x'
  | Some (40, x') => Address <$> decode x'
  | Some (41, x') => AddSubExtendRegister <$> decode x'
  | Some (42, x') => AddSubShiftedRegister <$> decode x'
  | Some (43, x') => AddSubCarry <$> decode x'
  | Some (44, x') => ConditionalCompareImmediate <$> decode x'
  | Some (45, x') => ConditionalCompareRegister <$> decode x'
  | Some (46, x') => ConditionalSelect <$> decode x'
  | Some (47, x') => Reverse <$> decode x'
  | Some (48, x') => CountLeading <$> decode x'
  | Some (49, x') => Division <$> decode x'
  | Some (50, x') => Shift <$> decode x'
  | Some (51, x') => CRC <$> decode x'
  | Some (52, x') => MultiplyAddSub <$> decode x'
  | Some (53, x') => MultiplyAddSubLong <$> decode x'
  | Some (54, x') => MultiplyHigh <$> decode x'
  | Some (55, x') => LogicalShiftedRegister <$> decode x'
  | _ => None end.
Lemma sail_ast_decode_encode : forall (x : ast), sail_ast_decode (sail_ast_encode x)  = Some x.
Proof.
  unfold sail_ast_decode, sail_ast_encode;
  intros [x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_ast : EqDecision ast := decode_encode_eq_dec sail_ast_encode sail_ast_decode
  sail_ast_decode_encode .

#[export]
Instance Countable_ast : Countable ast := {|
  encode := sail_ast_encode;
  decode := sail_ast_decode;
  decode_encode := sail_ast_decode_encode
|}.
#[export]
Instance dummy_ast : Inhabited (ast) := { inhabitant := Unallocated inhabitant }.



Variant register_bitvector_1 :=
  | PSTATE_nRW
  | PSTATE_E
.

Definition num_of_register_bitvector_1 (r : register_bitvector_1) : Z :=
  match r with
  | PSTATE_nRW => 0
  | PSTATE_E => 1
  end.
Definition register_bitvector_1_of_num (i : Z) : register_bitvector_1 :=
  match i with
  | 0 => PSTATE_nRW
  | 1 => PSTATE_E
  | _ => PSTATE_nRW
  end.
Lemma register_bitvector_1_num_of_roundtrip (x : register_bitvector_1) : register_bitvector_1_of_num (num_of_register_bitvector_1 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_1_injective (x y : register_bitvector_1) : num_of_register_bitvector_1 x = num_of_register_bitvector_1 y -> x = y.
  intro.
  rewrite <- (register_bitvector_1_num_of_roundtrip x).
  rewrite <- (register_bitvector_1_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_1_eq_dec (x y : register_bitvector_1) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_1 x) (num_of_register_bitvector_1 y) with
  | left e => left (num_of_register_bitvector_1_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_1_beq (x y : register_bitvector_1) : bool :=
  Z.eqb (num_of_register_bitvector_1 x) (num_of_register_bitvector_1 y).
Lemma register_bitvector_1_beq_iff x y : register_bitvector_1_beq x y = true <-> x = y.
  unfold register_bitvector_1_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_1_injective | congruence].
Qed.
Lemma register_bitvector_1_beq_refl x : register_bitvector_1_beq x x = true.
apply register_bitvector_1_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_1_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_1_beq_refl : register_beq_refls.
Definition register_bitvector_1_list : list (string * register_bitvector_1) := [
  ("PSTATE_nRW", PSTATE_nRW);
  ("PSTATE_E", PSTATE_E)
].

Instance Decidable_eq_register_bitvector_1 : EqDecision register_bitvector_1 := register_bitvector_1_eq_dec.
Instance Countable_register_bitvector_1 : Countable register_bitvector_1. refine {|
  encode x := encode (num_of_register_bitvector_1 x);
  decode x := register_bitvector_1_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_1_num_of_roundtrip.
  reflexivity.
Defined.

Variant register_bitvector_128 :=
  | V31
  | V30
  | V29
  | V28
  | V27
  | V26
  | V25
  | V24
  | V23
  | V22
  | V21
  | V20
  | V19
  | V18
  | V17
  | V16
  | V15
  | V14
  | V13
  | V12
  | V11
  | V10
  | V9
  | V8
  | V7
  | V6
  | V5
  | V4
  | V3
  | V2
  | V1
  | V0
.

Definition num_of_register_bitvector_128 (r : register_bitvector_128) : Z :=
  match r with
  | V31 => 0
  | V30 => 1
  | V29 => 2
  | V28 => 3
  | V27 => 4
  | V26 => 5
  | V25 => 6
  | V24 => 7
  | V23 => 8
  | V22 => 9
  | V21 => 10
  | V20 => 11
  | V19 => 12
  | V18 => 13
  | V17 => 14
  | V16 => 15
  | V15 => 16
  | V14 => 17
  | V13 => 18
  | V12 => 19
  | V11 => 20
  | V10 => 21
  | V9 => 22
  | V8 => 23
  | V7 => 24
  | V6 => 25
  | V5 => 26
  | V4 => 27
  | V3 => 28
  | V2 => 29
  | V1 => 30
  | V0 => 31
  end.
Definition register_bitvector_128_of_num (i : Z) : register_bitvector_128 :=
  match i with
  | 0 => V31
  | 1 => V30
  | 2 => V29
  | 3 => V28
  | 4 => V27
  | 5 => V26
  | 6 => V25
  | 7 => V24
  | 8 => V23
  | 9 => V22
  | 10 => V21
  | 11 => V20
  | 12 => V19
  | 13 => V18
  | 14 => V17
  | 15 => V16
  | 16 => V15
  | 17 => V14
  | 18 => V13
  | 19 => V12
  | 20 => V11
  | 21 => V10
  | 22 => V9
  | 23 => V8
  | 24 => V7
  | 25 => V6
  | 26 => V5
  | 27 => V4
  | 28 => V3
  | 29 => V2
  | 30 => V1
  | 31 => V0
  | _ => V31
  end.
Lemma register_bitvector_128_num_of_roundtrip (x : register_bitvector_128) : register_bitvector_128_of_num (num_of_register_bitvector_128 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_128_injective (x y : register_bitvector_128) : num_of_register_bitvector_128 x = num_of_register_bitvector_128 y -> x = y.
  intro.
  rewrite <- (register_bitvector_128_num_of_roundtrip x).
  rewrite <- (register_bitvector_128_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_128_eq_dec (x y : register_bitvector_128) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_128 x) (num_of_register_bitvector_128 y) with
  | left e => left (num_of_register_bitvector_128_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_128_beq (x y : register_bitvector_128) : bool :=
  Z.eqb (num_of_register_bitvector_128 x) (num_of_register_bitvector_128 y).
Lemma register_bitvector_128_beq_iff x y : register_bitvector_128_beq x y = true <-> x = y.
  unfold register_bitvector_128_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_128_injective | congruence].
Qed.
Lemma register_bitvector_128_beq_refl x : register_bitvector_128_beq x x = true.
apply register_bitvector_128_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_128_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_128_beq_refl : register_beq_refls.
Definition register_bitvector_128_list : list (string * register_bitvector_128) := [
  ("V31", V31);
  ("V30", V30);
  ("V29", V29);
  ("V28", V28);
  ("V27", V27);
  ("V26", V26);
  ("V25", V25);
  ("V24", V24);
  ("V23", V23);
  ("V22", V22);
  ("V21", V21);
  ("V20", V20);
  ("V19", V19);
  ("V18", V18);
  ("V17", V17);
  ("V16", V16);
  ("V15", V15);
  ("V14", V14);
  ("V13", V13);
  ("V12", V12);
  ("V11", V11);
  ("V10", V10);
  ("V9", V9);
  ("V8", V8);
  ("V7", V7);
  ("V6", V6);
  ("V5", V5);
  ("V4", V4);
  ("V3", V3);
  ("V2", V2);
  ("V1", V1);
  ("V0", V0)
].

Instance Decidable_eq_register_bitvector_128 : EqDecision register_bitvector_128 := register_bitvector_128_eq_dec.
Instance Countable_register_bitvector_128 : Countable register_bitvector_128. refine {|
  encode x := encode (num_of_register_bitvector_128 x);
  decode x := register_bitvector_128_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_128_num_of_roundtrip.
  reflexivity.
Defined.

Variant register_bitvector_32 :=
  | SCR_EL3
  | SCTLR_EL1
  | SCTLR_EL2
  | SCTLR_EL3
  | TCR_EL2
  | TCR_EL3
  | DBGPRCR_EL1
  | OSDLR_EL1
  | EDSCR
  | CurrentEL
  | DAIF
  | NZCV
  | SPSel
  | SPSR_EL1
  | SPSR_EL2
  | SPSR_EL3
  | SCR
  | DBGOSDLR
  | DBGPRCR
.

Definition num_of_register_bitvector_32 (r : register_bitvector_32) : Z :=
  match r with
  | SCR_EL3 => 0
  | SCTLR_EL1 => 1
  | SCTLR_EL2 => 2
  | SCTLR_EL3 => 3
  | TCR_EL2 => 4
  | TCR_EL3 => 5
  | DBGPRCR_EL1 => 6
  | OSDLR_EL1 => 7
  | EDSCR => 8
  | CurrentEL => 9
  | DAIF => 10
  | NZCV => 11
  | SPSel => 12
  | SPSR_EL1 => 13
  | SPSR_EL2 => 14
  | SPSR_EL3 => 15
  | SCR => 16
  | DBGOSDLR => 17
  | DBGPRCR => 18
  end.
Definition register_bitvector_32_of_num (i : Z) : register_bitvector_32 :=
  match i with
  | 0 => SCR_EL3
  | 1 => SCTLR_EL1
  | 2 => SCTLR_EL2
  | 3 => SCTLR_EL3
  | 4 => TCR_EL2
  | 5 => TCR_EL3
  | 6 => DBGPRCR_EL1
  | 7 => OSDLR_EL1
  | 8 => EDSCR
  | 9 => CurrentEL
  | 10 => DAIF
  | 11 => NZCV
  | 12 => SPSel
  | 13 => SPSR_EL1
  | 14 => SPSR_EL2
  | 15 => SPSR_EL3
  | 16 => SCR
  | 17 => DBGOSDLR
  | 18 => DBGPRCR
  | _ => SCR_EL3
  end.
Lemma register_bitvector_32_num_of_roundtrip (x : register_bitvector_32) : register_bitvector_32_of_num (num_of_register_bitvector_32 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_32_injective (x y : register_bitvector_32) : num_of_register_bitvector_32 x = num_of_register_bitvector_32 y -> x = y.
  intro.
  rewrite <- (register_bitvector_32_num_of_roundtrip x).
  rewrite <- (register_bitvector_32_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_32_eq_dec (x y : register_bitvector_32) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_32 x) (num_of_register_bitvector_32 y) with
  | left e => left (num_of_register_bitvector_32_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_32_beq (x y : register_bitvector_32) : bool :=
  Z.eqb (num_of_register_bitvector_32 x) (num_of_register_bitvector_32 y).
Lemma register_bitvector_32_beq_iff x y : register_bitvector_32_beq x y = true <-> x = y.
  unfold register_bitvector_32_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_32_injective | congruence].
Qed.
Lemma register_bitvector_32_beq_refl x : register_bitvector_32_beq x x = true.
apply register_bitvector_32_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_32_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_32_beq_refl : register_beq_refls.
Definition register_bitvector_32_list : list (string * register_bitvector_32) := [
  ("SCR_EL3", SCR_EL3);
  ("SCTLR_EL1", SCTLR_EL1);
  ("SCTLR_EL2", SCTLR_EL2);
  ("SCTLR_EL3", SCTLR_EL3);
  ("TCR_EL2", TCR_EL2);
  ("TCR_EL3", TCR_EL3);
  ("DBGPRCR_EL1", DBGPRCR_EL1);
  ("OSDLR_EL1", OSDLR_EL1);
  ("EDSCR", EDSCR);
  ("CurrentEL", CurrentEL);
  ("DAIF", DAIF);
  ("NZCV", NZCV);
  ("SPSel", SPSel);
  ("SPSR_EL1", SPSR_EL1);
  ("SPSR_EL2", SPSR_EL2);
  ("SPSR_EL3", SPSR_EL3);
  ("SCR", SCR);
  ("DBGOSDLR", DBGOSDLR);
  ("DBGPRCR", DBGPRCR)
].

Instance Decidable_eq_register_bitvector_32 : EqDecision register_bitvector_32 := register_bitvector_32_eq_dec.
Instance Countable_register_bitvector_32 : Countable register_bitvector_32. refine {|
  encode x := encode (num_of_register_bitvector_32 x);
  decode x := register_bitvector_32_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_32_num_of_roundtrip.
  reflexivity.
Defined.

Variant register_bitvector_5 :=
  | PSTATE_M
.

Definition num_of_register_bitvector_5 (r : register_bitvector_5) : Z :=
  match r with
  | PSTATE_M => 0
  end.
Definition register_bitvector_5_of_num (i : Z) : register_bitvector_5 :=
  match i with
  | 0 => PSTATE_M
  | _ => PSTATE_M
  end.
Lemma register_bitvector_5_num_of_roundtrip (x : register_bitvector_5) : register_bitvector_5_of_num (num_of_register_bitvector_5 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_5_injective (x y : register_bitvector_5) : num_of_register_bitvector_5 x = num_of_register_bitvector_5 y -> x = y.
  intro.
  rewrite <- (register_bitvector_5_num_of_roundtrip x).
  rewrite <- (register_bitvector_5_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_5_eq_dec (x y : register_bitvector_5) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_5 x) (num_of_register_bitvector_5 y) with
  | left e => left (num_of_register_bitvector_5_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_5_beq (x y : register_bitvector_5) : bool :=
  Z.eqb (num_of_register_bitvector_5 x) (num_of_register_bitvector_5 y).
Lemma register_bitvector_5_beq_iff x y : register_bitvector_5_beq x y = true <-> x = y.
  unfold register_bitvector_5_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_5_injective | congruence].
Qed.
Lemma register_bitvector_5_beq_refl x : register_bitvector_5_beq x x = true.
apply register_bitvector_5_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_5_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_5_beq_refl : register_beq_refls.
Definition register_bitvector_5_list : list (string * register_bitvector_5) := [
  ("PSTATE_M", PSTATE_M)
].

Instance Decidable_eq_register_bitvector_5 : EqDecision register_bitvector_5 := register_bitvector_5_eq_dec.
Instance Countable_register_bitvector_5 : Countable register_bitvector_5. refine {|
  encode x := encode (num_of_register_bitvector_5 x);
  decode x := register_bitvector_5_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_5_num_of_roundtrip.
  reflexivity.
Defined.

Variant register_bitvector_64 :=
  | _PC
  | TMAbortEffect
  | TMStartEffect
  | data_cache_operation_CVAU
  | instruction_cache_operation_IVAU
  | R30
  | R29
  | R28
  | R27
  | R26
  | R25
  | R24
  | R23
  | R22
  | R21
  | R20
  | R19
  | R18
  | R17
  | R16
  | R15
  | R14
  | R13
  | R12
  | R11
  | R10
  | R9
  | R8
  | R7
  | R6
  | R5
  | R4
  | R3
  | R2
  | R1
  | R0
  | HCR_EL2
  | ID_AA64MMFR0_EL1
  | RVBAR_EL1
  | RVBAR_EL2
  | RVBAR_EL3
  | TCR_EL1
  | TPIDR_EL0
  | TPIDR_EL1
  | TPIDR_EL2
  | TPIDR_EL3
  | TXIDR_EL0
  | SP_EL0
  | SP_EL1
  | SP_EL2
  | SP_EL3
  | ELR_EL1
  | ELR_EL2
  | ELR_EL3
.

Definition num_of_register_bitvector_64 (r : register_bitvector_64) : Z :=
  match r with
  | _PC => 0
  | TMAbortEffect => 1
  | TMStartEffect => 2
  | data_cache_operation_CVAU => 3
  | instruction_cache_operation_IVAU => 4
  | R30 => 5
  | R29 => 6
  | R28 => 7
  | R27 => 8
  | R26 => 9
  | R25 => 10
  | R24 => 11
  | R23 => 12
  | R22 => 13
  | R21 => 14
  | R20 => 15
  | R19 => 16
  | R18 => 17
  | R17 => 18
  | R16 => 19
  | R15 => 20
  | R14 => 21
  | R13 => 22
  | R12 => 23
  | R11 => 24
  | R10 => 25
  | R9 => 26
  | R8 => 27
  | R7 => 28
  | R6 => 29
  | R5 => 30
  | R4 => 31
  | R3 => 32
  | R2 => 33
  | R1 => 34
  | R0 => 35
  | HCR_EL2 => 36
  | ID_AA64MMFR0_EL1 => 37
  | RVBAR_EL1 => 38
  | RVBAR_EL2 => 39
  | RVBAR_EL3 => 40
  | TCR_EL1 => 41
  | TPIDR_EL0 => 42
  | TPIDR_EL1 => 43
  | TPIDR_EL2 => 44
  | TPIDR_EL3 => 45
  | TXIDR_EL0 => 46
  | SP_EL0 => 47
  | SP_EL1 => 48
  | SP_EL2 => 49
  | SP_EL3 => 50
  | ELR_EL1 => 51
  | ELR_EL2 => 52
  | ELR_EL3 => 53
  end.
Definition register_bitvector_64_of_num (i : Z) : register_bitvector_64 :=
  match i with
  | 0 => _PC
  | 1 => TMAbortEffect
  | 2 => TMStartEffect
  | 3 => data_cache_operation_CVAU
  | 4 => instruction_cache_operation_IVAU
  | 5 => R30
  | 6 => R29
  | 7 => R28
  | 8 => R27
  | 9 => R26
  | 10 => R25
  | 11 => R24
  | 12 => R23
  | 13 => R22
  | 14 => R21
  | 15 => R20
  | 16 => R19
  | 17 => R18
  | 18 => R17
  | 19 => R16
  | 20 => R15
  | 21 => R14
  | 22 => R13
  | 23 => R12
  | 24 => R11
  | 25 => R10
  | 26 => R9
  | 27 => R8
  | 28 => R7
  | 29 => R6
  | 30 => R5
  | 31 => R4
  | 32 => R3
  | 33 => R2
  | 34 => R1
  | 35 => R0
  | 36 => HCR_EL2
  | 37 => ID_AA64MMFR0_EL1
  | 38 => RVBAR_EL1
  | 39 => RVBAR_EL2
  | 40 => RVBAR_EL3
  | 41 => TCR_EL1
  | 42 => TPIDR_EL0
  | 43 => TPIDR_EL1
  | 44 => TPIDR_EL2
  | 45 => TPIDR_EL3
  | 46 => TXIDR_EL0
  | 47 => SP_EL0
  | 48 => SP_EL1
  | 49 => SP_EL2
  | 50 => SP_EL3
  | 51 => ELR_EL1
  | 52 => ELR_EL2
  | 53 => ELR_EL3
  | _ => _PC
  end.
Lemma register_bitvector_64_num_of_roundtrip (x : register_bitvector_64) : register_bitvector_64_of_num (num_of_register_bitvector_64 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_64_injective (x y : register_bitvector_64) : num_of_register_bitvector_64 x = num_of_register_bitvector_64 y -> x = y.
  intro.
  rewrite <- (register_bitvector_64_num_of_roundtrip x).
  rewrite <- (register_bitvector_64_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_64_eq_dec (x y : register_bitvector_64) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y) with
  | left e => left (num_of_register_bitvector_64_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_64_beq (x y : register_bitvector_64) : bool :=
  Z.eqb (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y).
Lemma register_bitvector_64_beq_iff x y : register_bitvector_64_beq x y = true <-> x = y.
  unfold register_bitvector_64_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_64_injective | congruence].
Qed.
Lemma register_bitvector_64_beq_refl x : register_bitvector_64_beq x x = true.
apply register_bitvector_64_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_64_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_64_beq_refl : register_beq_refls.
Definition register_bitvector_64_list : list (string * register_bitvector_64) := [
  ("_PC", _PC);
  ("TMAbortEffect", TMAbortEffect);
  ("TMStartEffect", TMStartEffect);
  ("data_cache_operation_CVAU", data_cache_operation_CVAU);
  ("instruction_cache_operation_IVAU", instruction_cache_operation_IVAU);
  ("R30", R30);
  ("R29", R29);
  ("R28", R28);
  ("R27", R27);
  ("R26", R26);
  ("R25", R25);
  ("R24", R24);
  ("R23", R23);
  ("R22", R22);
  ("R21", R21);
  ("R20", R20);
  ("R19", R19);
  ("R18", R18);
  ("R17", R17);
  ("R16", R16);
  ("R15", R15);
  ("R14", R14);
  ("R13", R13);
  ("R12", R12);
  ("R11", R11);
  ("R10", R10);
  ("R9", R9);
  ("R8", R8);
  ("R7", R7);
  ("R6", R6);
  ("R5", R5);
  ("R4", R4);
  ("R3", R3);
  ("R2", R2);
  ("R1", R1);
  ("R0", R0);
  ("HCR_EL2", HCR_EL2);
  ("ID_AA64MMFR0_EL1", ID_AA64MMFR0_EL1);
  ("RVBAR_EL1", RVBAR_EL1);
  ("RVBAR_EL2", RVBAR_EL2);
  ("RVBAR_EL3", RVBAR_EL3);
  ("TCR_EL1", TCR_EL1);
  ("TPIDR_EL0", TPIDR_EL0);
  ("TPIDR_EL1", TPIDR_EL1);
  ("TPIDR_EL2", TPIDR_EL2);
  ("TPIDR_EL3", TPIDR_EL3);
  ("TXIDR_EL0", TXIDR_EL0);
  ("SP_EL0", SP_EL0);
  ("SP_EL1", SP_EL1);
  ("SP_EL2", SP_EL2);
  ("SP_EL3", SP_EL3);
  ("ELR_EL1", ELR_EL1);
  ("ELR_EL2", ELR_EL2);
  ("ELR_EL3", ELR_EL3)
].

Instance Decidable_eq_register_bitvector_64 : EqDecision register_bitvector_64 := register_bitvector_64_eq_dec.
Instance Countable_register_bitvector_64 : Countable register_bitvector_64. refine {|
  encode x := encode (num_of_register_bitvector_64 x);
  decode x := register_bitvector_64_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_64_num_of_roundtrip.
  reflexivity.
Defined.

Variant register_bitvector_8 :=
  | TxNestingLevel
.

Definition num_of_register_bitvector_8 (r : register_bitvector_8) : Z :=
  match r with
  | TxNestingLevel => 0
  end.
Definition register_bitvector_8_of_num (i : Z) : register_bitvector_8 :=
  match i with
  | 0 => TxNestingLevel
  | _ => TxNestingLevel
  end.
Lemma register_bitvector_8_num_of_roundtrip (x : register_bitvector_8) : register_bitvector_8_of_num (num_of_register_bitvector_8 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_8_injective (x y : register_bitvector_8) : num_of_register_bitvector_8 x = num_of_register_bitvector_8 y -> x = y.
  intro.
  rewrite <- (register_bitvector_8_num_of_roundtrip x).
  rewrite <- (register_bitvector_8_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_8_eq_dec (x y : register_bitvector_8) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_8 x) (num_of_register_bitvector_8 y) with
  | left e => left (num_of_register_bitvector_8_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_8_beq (x y : register_bitvector_8) : bool :=
  Z.eqb (num_of_register_bitvector_8 x) (num_of_register_bitvector_8 y).
Lemma register_bitvector_8_beq_iff x y : register_bitvector_8_beq x y = true <-> x = y.
  unfold register_bitvector_8_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_8_injective | congruence].
Qed.
Lemma register_bitvector_8_beq_refl x : register_bitvector_8_beq x x = true.
apply register_bitvector_8_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_8_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_8_beq_refl : register_beq_refls.
Definition register_bitvector_8_list : list (string * register_bitvector_8) := [
  ("TxNestingLevel", TxNestingLevel)
].

Instance Decidable_eq_register_bitvector_8 : EqDecision register_bitvector_8 := register_bitvector_8_eq_dec.
Instance Countable_register_bitvector_8 : Countable register_bitvector_8. refine {|
  encode x := encode (num_of_register_bitvector_8 x);
  decode x := register_bitvector_8_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_8_num_of_roundtrip.
  reflexivity.
Defined.


Variant register : Type -> Type :=
  | R_bitvector_1 :> register_bitvector_1 -> register ((mword 1))
  | R_bitvector_128 :> register_bitvector_128 -> register ((mword 128))
  | R_bitvector_32 :> register_bitvector_32 -> register ((mword 32))
  | R_bitvector_5 :> register_bitvector_5 -> register ((mword 5))
  | R_bitvector_64 :> register_bitvector_64 -> register ((mword 64))
  | R_bitvector_8 :> register_bitvector_8 -> register ((mword 8))
.
Add Keep Equalities register.

Module GRegister.
  Inductive greg := GReg [T : Type] (r : register T).

  (* The injection tactic can do too much, so prove a one-step lemma. *)
  Lemma greg_inj {T} {r r' : register T} : GReg r = GReg r' -> r = r'.
  Proof.
    intro e. injection e as e'.
    apply Eqdep.EqdepTheory.inj_pair2 in e'.
    assumption.
  Qed.

  Definition greg_proj1 (r : greg) : Type := match r with @GReg T _ => T end.
  Definition greg_proj2 (r : greg) : register (greg_proj1 r) := match r with @GReg _ r => r end.

  Definition greg_encode (r : greg) : positive :=
    match r with
    | GReg (R_bitvector_1 r) => encode (0, encode r)
    | GReg (R_bitvector_128 r) => encode (1, encode r)
    | GReg (R_bitvector_32 r) => encode (2, encode r)
    | GReg (R_bitvector_5 r) => encode (3, encode r)
    | GReg (R_bitvector_64 r) => encode (4, encode r)
    | GReg (R_bitvector_8 r) => encode (5, encode r)
    end.
  Definition greg_type_encode (r : greg) : positive :=
    match r with
    | GReg (R_bitvector_1 _r) => 1
    | GReg (R_bitvector_128 _r) => 2
    | GReg (R_bitvector_32 _r) => 3
    | GReg (R_bitvector_5 _r) => 4
    | GReg (R_bitvector_64 _r) => 5
    | GReg (R_bitvector_8 _r) => 6
    end.
  Definition greg_decode (x : positive) : option greg :=
    match decode x with
    | Some (0, y) => r ← decode y; mret (GReg (R_bitvector_1 r))
    | Some (1, y) => r ← decode y; mret (GReg (R_bitvector_128 r))
    | Some (2, y) => r ← decode y; mret (GReg (R_bitvector_32 r))
    | Some (3, y) => r ← decode y; mret (GReg (R_bitvector_5 r))
    | Some (4, y) => r ← decode y; mret (GReg (R_bitvector_64 r))
    | Some (5, y) => r ← decode y; mret (GReg (R_bitvector_8 r))
    | _ => None
    end.
  Lemma greg_decode_encode r : greg_decode (greg_encode r) = Some r.
  Proof.
    destruct r as [T r']; destruct r';
    unfold greg_decode, greg_encode;
    rewrite !decode_encode;
    reflexivity.
  Qed.
  Lemma greg_encode_inj r r' : greg_encode r = greg_encode r' -> r = r'.
  Proof.
    intro H.
    enough (Some r = Some r') by congruence.
    rewrite <- (greg_decode_encode r).
    rewrite <- (greg_decode_encode r').
    congruence.
  Qed.
  #[export] Instance Decidable_eq_greg : EqDecision greg.
  refine (fun r r' => match Pos.eq_dec (greg_encode r) (greg_encode r') with
  | left e => left (greg_encode_inj _ _ e)
  | right ne => right _
  end).
  congruence.
  Defined.
  #[export] Instance Countable_greg : Countable greg := {|
    encode := greg_encode;
    decode := greg_decode;
    decode_encode := greg_decode_encode;
  |}.
End GRegister.

Require Import Eqdep.

Instance Decidable_eq_register {T} : EqDecision (register T).
refine (fun r r' => match GRegister.Decidable_eq_greg (GRegister.GReg r) (GRegister.GReg r') with
| left e => left _
| right ne => right _
end).
* by apply GRegister.greg_inj in e.
* intros e; subst; congruence.
Defined.

Definition register_transport {T T'} {P : Type -> Type} {r : register T} {r' : register T'} : GRegister.GReg r = GRegister.GReg r' -> P T -> P T'.
refine (
  match r, r' with
  | R_bitvector_1 r, R_bitvector_1 r' => fun _ x => x
  | R_bitvector_128 r, R_bitvector_128 r' => fun _ x => x
  | R_bitvector_32 r, R_bitvector_32 r' => fun _ x => x
  | R_bitvector_5 r, R_bitvector_5 r' => fun _ x => x
  | R_bitvector_64 r, R_bitvector_64 r' => fun _ x => x
  | R_bitvector_8 r, R_bitvector_8 r' => fun _ x => x
  | _, _ => fun e _ => _
  end
).
  all:
  enough (H : GRegister.greg_type_encode (GRegister.GReg r0) = GRegister.greg_type_encode (GRegister.GReg r1));
  [ simpl in H; congruence
  | rewrite e; reflexivity].
Defined.

Lemma register_transport_sound {T P} {r r' : register T} (e : GRegister.GReg r = GRegister.GReg r') (p : P T) :
  register_transport e p = p.
Proof.
  pose proof (e' := GRegister.greg_inj e).
  subst r'.
  destruct r; reflexivity.
Qed.

Definition register_beq {T T'} (r : register T) (r' : register T') : bool :=
  match r, r' with
  | R_bitvector_1 r, R_bitvector_1 r' => register_bitvector_1_beq r r'
  | R_bitvector_128 r, R_bitvector_128 r' => register_bitvector_128_beq r r'
  | R_bitvector_32 r, R_bitvector_32 r' => register_bitvector_32_beq r r'
  | R_bitvector_5 r, R_bitvector_5 r' => register_bitvector_5_beq r r'
  | R_bitvector_64 r, R_bitvector_64 r' => register_bitvector_64_beq r r'
  | R_bitvector_8 r, R_bitvector_8 r' => register_bitvector_8_beq r r'
  | _, _ => false
  end.

Lemma register_beq_refl {T} (r : register T) : register_beq r r = true.
destruct r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Definition register_eq_cast {T T'} (P : Type -> Type) (r : register T) (r' : register T') : P T -> option (P T') :=
  match r, r' with
  | R_bitvector_1 r, R_bitvector_1 r' => fun p => if register_bitvector_1_beq r r' then Some p else None
  | R_bitvector_128 r, R_bitvector_128 r' => fun p => if register_bitvector_128_beq r r' then Some p else None
  | R_bitvector_32 r, R_bitvector_32 r' => fun p => if register_bitvector_32_beq r r' then Some p else None
  | R_bitvector_5 r, R_bitvector_5 r' => fun p => if register_bitvector_5_beq r r' then Some p else None
  | R_bitvector_64 r, R_bitvector_64 r' => fun p => if register_bitvector_64_beq r r' then Some p else None
  | R_bitvector_8 r, R_bitvector_8 r' => fun p => if register_bitvector_8_beq r r' then Some p else None
  | _, _ => fun _ => None
  end.

Definition register_list : list (string * GRegister.greg) := List.concat [
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_1 r))) register_bitvector_1_list;
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_128 r))) register_bitvector_128_list;
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_32 r))) register_bitvector_32_list;
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_5 r))) register_bitvector_5_list;
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_64 r))) register_bitvector_64_list;
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_8 r))) register_bitvector_8_list
].

Definition string_of_register {T} (r : register T) : string :=
  match List.find (fun '(_s, GRegister.GReg r') => register_beq r r') register_list with
  | Some (s, _r) => s
  | None => "<impossible>"
  end.

Definition register_of_string (s : string) : option GRegister.greg :=
  match List.find (fun '(s', _r) => String.eqb s s') register_list with
  | Some (_s, r) => Some r
  | None => None
  end.

Lemma string_of_register_roundtrip {T} (r : register T) :
  register_of_string (string_of_register r) = Some (GRegister.GReg r).
case r; intro r'; destruct r'; reflexivity.
Qed.

Lemma register_string_eq {T T'} (r : register T) (r' : register T') :
  register_beq r r' = String.eqb (string_of_register r) (string_of_register r').
destruct (Bool.reflect_dec _ _ (String.eqb_spec (string_of_register r) (string_of_register r'))) as [H|H].
* rewrite H, String.eqb_refl.
  specialize (string_of_register_roundtrip r) as H1.
  specialize (string_of_register_roundtrip r') as H2.
  rewrite H in H1.
  rewrite H2 in H1.
  assert (E : @GRegister.GReg T' r' = @GRegister.GReg T r). { congruence. }
  set (f := fun (r r' : GRegister.greg) => register_beq (GRegister.greg_proj2 r) (GRegister.greg_proj2 r')).
  change (register_beq r r') with (f (GRegister.GReg r) (GRegister.GReg r')).
  rewrite <- E.
  unfold f.
  apply register_beq_refl.
* apply String.eqb_neq in H as H'.
  rewrite H'.
  apply Bool.not_true_is_false.
  contradict H.
  destruct r,r'; simpl in H; try discriminate; autorewrite with register_beq_iffs in H; subst; reflexivity.
Qed.
#[export] Hint Extern 1 (register _) => assumption : typeclass_instances.
#[export] Instance Decidable_eq_register_values {T : Type} `(r : register T) : EqDecision T | 100 :=
match r with
  | R_bitvector_1 _ => _
  | R_bitvector_128 _ => _
  | R_bitvector_32 _ => _
  | R_bitvector_5 _ => _
  | R_bitvector_64 _ => _
  | R_bitvector_8 _ => _
end.
#[export] Instance Inhabited_register_values {T : Type} `(r : register T) : Inhabited T | 100 :=
  match r with
  | R_bitvector_1 _ => _
  | R_bitvector_128 _ => _
  | R_bitvector_32 _ => _
  | R_bitvector_5 _ => _
  | R_bitvector_64 _ => _
  | R_bitvector_8 _ => _
end.
#[export] Instance Countable_register_values {T : Type} `(r : register T) : Countable T | 100.
refine {|
  encode := match r in register T return T -> _ with
  | R_bitvector_1 _ => encode
  | R_bitvector_128 _ => encode
  | R_bitvector_32 _ => encode
  | R_bitvector_5 _ => encode
  | R_bitvector_64 _ => encode
  | R_bitvector_8 _ => encode
  end;
  decode := match r in register T return _ -> option T with
  | R_bitvector_1 _ => decode
  | R_bitvector_128 _ => decode
  | R_bitvector_32 _ => decode
  | R_bitvector_5 _ => decode
  | R_bitvector_64 _ => decode
  | R_bitvector_8 _ => decode
  end;
|}.
abstract (destruct r; apply decode_encode).
Defined.

Definition PSTATE_nRW_ref : register_ref register _ :=
  Build_register_ref register _ "PSTATE_nRW" PSTATE_nRW.
Definition PSTATE_E_ref : register_ref register _ :=
  Build_register_ref register _ "PSTATE_E" PSTATE_E.
Instance dummy_register_bitvector_1 : Inhabited (register_ref register _) := populate PSTATE_nRW_ref.

Definition V31_ref : register_ref register _ :=
  Build_register_ref register _ "V31" V31.
Definition V30_ref : register_ref register _ :=
  Build_register_ref register _ "V30" V30.
Definition V29_ref : register_ref register _ :=
  Build_register_ref register _ "V29" V29.
Definition V28_ref : register_ref register _ :=
  Build_register_ref register _ "V28" V28.
Definition V27_ref : register_ref register _ :=
  Build_register_ref register _ "V27" V27.
Definition V26_ref : register_ref register _ :=
  Build_register_ref register _ "V26" V26.
Definition V25_ref : register_ref register _ :=
  Build_register_ref register _ "V25" V25.
Definition V24_ref : register_ref register _ :=
  Build_register_ref register _ "V24" V24.
Definition V23_ref : register_ref register _ :=
  Build_register_ref register _ "V23" V23.
Definition V22_ref : register_ref register _ :=
  Build_register_ref register _ "V22" V22.
Definition V21_ref : register_ref register _ :=
  Build_register_ref register _ "V21" V21.
Definition V20_ref : register_ref register _ :=
  Build_register_ref register _ "V20" V20.
Definition V19_ref : register_ref register _ :=
  Build_register_ref register _ "V19" V19.
Definition V18_ref : register_ref register _ :=
  Build_register_ref register _ "V18" V18.
Definition V17_ref : register_ref register _ :=
  Build_register_ref register _ "V17" V17.
Definition V16_ref : register_ref register _ :=
  Build_register_ref register _ "V16" V16.
Definition V15_ref : register_ref register _ :=
  Build_register_ref register _ "V15" V15.
Definition V14_ref : register_ref register _ :=
  Build_register_ref register _ "V14" V14.
Definition V13_ref : register_ref register _ :=
  Build_register_ref register _ "V13" V13.
Definition V12_ref : register_ref register _ :=
  Build_register_ref register _ "V12" V12.
Definition V11_ref : register_ref register _ :=
  Build_register_ref register _ "V11" V11.
Definition V10_ref : register_ref register _ :=
  Build_register_ref register _ "V10" V10.
Definition V9_ref : register_ref register _ :=
  Build_register_ref register _ "V9" V9.
Definition V8_ref : register_ref register _ :=
  Build_register_ref register _ "V8" V8.
Definition V7_ref : register_ref register _ :=
  Build_register_ref register _ "V7" V7.
Definition V6_ref : register_ref register _ :=
  Build_register_ref register _ "V6" V6.
Definition V5_ref : register_ref register _ :=
  Build_register_ref register _ "V5" V5.
Definition V4_ref : register_ref register _ :=
  Build_register_ref register _ "V4" V4.
Definition V3_ref : register_ref register _ :=
  Build_register_ref register _ "V3" V3.
Definition V2_ref : register_ref register _ :=
  Build_register_ref register _ "V2" V2.
Definition V1_ref : register_ref register _ :=
  Build_register_ref register _ "V1" V1.
Definition V0_ref : register_ref register _ :=
  Build_register_ref register _ "V0" V0.
Instance dummy_register_bitvector_128 : Inhabited (register_ref register _) := populate V31_ref.

Definition SCR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SCR_EL3" SCR_EL3.
Definition SCTLR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "SCTLR_EL1" SCTLR_EL1.
Definition SCTLR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "SCTLR_EL2" SCTLR_EL2.
Definition SCTLR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SCTLR_EL3" SCTLR_EL3.
Definition TCR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "TCR_EL2" TCR_EL2.
Definition TCR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "TCR_EL3" TCR_EL3.
Definition DBGPRCR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "DBGPRCR_EL1" DBGPRCR_EL1.
Definition OSDLR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "OSDLR_EL1" OSDLR_EL1.
Definition EDSCR_ref : register_ref register _ :=
  Build_register_ref register _ "EDSCR" EDSCR.
Definition CurrentEL_ref : register_ref register _ :=
  Build_register_ref register _ "CurrentEL" CurrentEL.
Definition DAIF_ref : register_ref register _ :=
  Build_register_ref register _ "DAIF" DAIF.
Definition NZCV_ref : register_ref register _ :=
  Build_register_ref register _ "NZCV" NZCV.
Definition SPSel_ref : register_ref register _ :=
  Build_register_ref register _ "SPSel" SPSel.
Definition SPSR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "SPSR_EL1" SPSR_EL1.
Definition SPSR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "SPSR_EL2" SPSR_EL2.
Definition SPSR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SPSR_EL3" SPSR_EL3.
Definition SCR_ref : register_ref register _ :=
  Build_register_ref register _ "SCR" SCR.
Definition DBGOSDLR_ref : register_ref register _ :=
  Build_register_ref register _ "DBGOSDLR" DBGOSDLR.
Definition DBGPRCR_ref : register_ref register _ :=
  Build_register_ref register _ "DBGPRCR" DBGPRCR.
Instance dummy_register_bitvector_32 : Inhabited (register_ref register _) := populate SCR_EL3_ref.

Definition PSTATE_M_ref : register_ref register _ :=
  Build_register_ref register _ "PSTATE_M" PSTATE_M.
Instance dummy_register_bitvector_5 : Inhabited (register_ref register _) := populate PSTATE_M_ref.

Definition _PC_ref : register_ref register _ :=
  Build_register_ref register _ "_PC" _PC.
Definition TMAbortEffect_ref : register_ref register _ :=
  Build_register_ref register _ "TMAbortEffect" TMAbortEffect.
Definition TMStartEffect_ref : register_ref register _ :=
  Build_register_ref register _ "TMStartEffect" TMStartEffect.
Definition data_cache_operation_CVAU_ref : register_ref register _ :=
  Build_register_ref register _ "data_cache_operation_CVAU" data_cache_operation_CVAU.
Definition instruction_cache_operation_IVAU_ref : register_ref register _ :=
  Build_register_ref register _ "instruction_cache_operation_IVAU" instruction_cache_operation_IVAU.
Definition R30_ref : register_ref register _ :=
  Build_register_ref register _ "R30" R30.
Definition R29_ref : register_ref register _ :=
  Build_register_ref register _ "R29" R29.
Definition R28_ref : register_ref register _ :=
  Build_register_ref register _ "R28" R28.
Definition R27_ref : register_ref register _ :=
  Build_register_ref register _ "R27" R27.
Definition R26_ref : register_ref register _ :=
  Build_register_ref register _ "R26" R26.
Definition R25_ref : register_ref register _ :=
  Build_register_ref register _ "R25" R25.
Definition R24_ref : register_ref register _ :=
  Build_register_ref register _ "R24" R24.
Definition R23_ref : register_ref register _ :=
  Build_register_ref register _ "R23" R23.
Definition R22_ref : register_ref register _ :=
  Build_register_ref register _ "R22" R22.
Definition R21_ref : register_ref register _ :=
  Build_register_ref register _ "R21" R21.
Definition R20_ref : register_ref register _ :=
  Build_register_ref register _ "R20" R20.
Definition R19_ref : register_ref register _ :=
  Build_register_ref register _ "R19" R19.
Definition R18_ref : register_ref register _ :=
  Build_register_ref register _ "R18" R18.
Definition R17_ref : register_ref register _ :=
  Build_register_ref register _ "R17" R17.
Definition R16_ref : register_ref register _ :=
  Build_register_ref register _ "R16" R16.
Definition R15_ref : register_ref register _ :=
  Build_register_ref register _ "R15" R15.
Definition R14_ref : register_ref register _ :=
  Build_register_ref register _ "R14" R14.
Definition R13_ref : register_ref register _ :=
  Build_register_ref register _ "R13" R13.
Definition R12_ref : register_ref register _ :=
  Build_register_ref register _ "R12" R12.
Definition R11_ref : register_ref register _ :=
  Build_register_ref register _ "R11" R11.
Definition R10_ref : register_ref register _ :=
  Build_register_ref register _ "R10" R10.
Definition R9_ref : register_ref register _ :=
  Build_register_ref register _ "R9" R9.
Definition R8_ref : register_ref register _ :=
  Build_register_ref register _ "R8" R8.
Definition R7_ref : register_ref register _ :=
  Build_register_ref register _ "R7" R7.
Definition R6_ref : register_ref register _ :=
  Build_register_ref register _ "R6" R6.
Definition R5_ref : register_ref register _ :=
  Build_register_ref register _ "R5" R5.
Definition R4_ref : register_ref register _ :=
  Build_register_ref register _ "R4" R4.
Definition R3_ref : register_ref register _ :=
  Build_register_ref register _ "R3" R3.
Definition R2_ref : register_ref register _ :=
  Build_register_ref register _ "R2" R2.
Definition R1_ref : register_ref register _ :=
  Build_register_ref register _ "R1" R1.
Definition R0_ref : register_ref register _ :=
  Build_register_ref register _ "R0" R0.
Definition HCR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "HCR_EL2" HCR_EL2.
Definition ID_AA64MMFR0_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ID_AA64MMFR0_EL1" ID_AA64MMFR0_EL1.
Definition RVBAR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "RVBAR_EL1" RVBAR_EL1.
Definition RVBAR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "RVBAR_EL2" RVBAR_EL2.
Definition RVBAR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "RVBAR_EL3" RVBAR_EL3.
Definition TCR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "TCR_EL1" TCR_EL1.
Definition TPIDR_EL0_ref : register_ref register _ :=
  Build_register_ref register _ "TPIDR_EL0" TPIDR_EL0.
Definition TPIDR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "TPIDR_EL1" TPIDR_EL1.
Definition TPIDR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "TPIDR_EL2" TPIDR_EL2.
Definition TPIDR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "TPIDR_EL3" TPIDR_EL3.
Definition TXIDR_EL0_ref : register_ref register _ :=
  Build_register_ref register _ "TXIDR_EL0" TXIDR_EL0.
Definition SP_EL0_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL0" SP_EL0.
Definition SP_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL1" SP_EL1.
Definition SP_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL2" SP_EL2.
Definition SP_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL3" SP_EL3.
Definition ELR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ELR_EL1" ELR_EL1.
Definition ELR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "ELR_EL2" ELR_EL2.
Definition ELR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "ELR_EL3" ELR_EL3.
Instance dummy_register_bitvector_64 : Inhabited (register_ref register _) := populate _PC_ref.

Definition TxNestingLevel_ref : register_ref register _ :=
  Build_register_ref register _ "TxNestingLevel" TxNestingLevel.
Instance dummy_register_bitvector_8 : Inhabited (register_ref register _) := populate TxNestingLevel_ref.


(* Definitions to support the lifting to the sequential monad *)
Record regstate := {
  bitvector_1_s : register_bitvector_1 -> mword 1;
  bitvector_128_s : register_bitvector_128 -> mword 128;
  bitvector_32_s : register_bitvector_32 -> mword 32;
  bitvector_5_s : register_bitvector_5 -> mword 5;
  bitvector_64_s : register_bitvector_64 -> mword 64;
  bitvector_8_s : register_bitvector_8 -> mword 8;
}.
#[export] Instance eta_regstate : Settable _ := settable! Build_regstate <bitvector_1_s; bitvector_128_s; bitvector_32_s; bitvector_5_s; bitvector_64_s; bitvector_8_s>.

Definition init_regstate : regstate := Build_regstate
  inhabitant
  inhabitant
  inhabitant
  inhabitant
  inhabitant
  inhabitant
.

Definition register_lookup {T : Type} (reg : register T) (rs : regstate) : T :=
  match reg with
  | R_bitvector_1 r => rs.(bitvector_1_s) r
  | R_bitvector_128 r => rs.(bitvector_128_s) r
  | R_bitvector_32 r => rs.(bitvector_32_s) r
  | R_bitvector_5 r => rs.(bitvector_5_s) r
  | R_bitvector_64 r => rs.(bitvector_64_s) r
  | R_bitvector_8 r => rs.(bitvector_8_s) r
  end.

Definition register_set {T : Type} (reg : register T) : T -> regstate -> regstate :=
  match reg with
  | R_bitvector_1 r => fun v rs => rs <|bitvector_1_s := fun r' => if register_bitvector_1_beq r' r then v else rs.(bitvector_1_s) r'|>
  | R_bitvector_128 r => fun v rs => rs <|bitvector_128_s := fun r' => if register_bitvector_128_beq r' r then v else rs.(bitvector_128_s) r'|>
  | R_bitvector_32 r => fun v rs => rs <|bitvector_32_s := fun r' => if register_bitvector_32_beq r' r then v else rs.(bitvector_32_s) r'|>
  | R_bitvector_5 r => fun v rs => rs <|bitvector_5_s := fun r' => if register_bitvector_5_beq r' r then v else rs.(bitvector_5_s) r'|>
  | R_bitvector_64 r => fun v rs => rs <|bitvector_64_s := fun r' => if register_bitvector_64_beq r' r then v else rs.(bitvector_64_s) r'|>
  | R_bitvector_8 r => fun v rs => rs <|bitvector_8_s := fun r' => if register_bitvector_8_beq r' r then v else rs.(bitvector_8_s) r'|>
  end.

Lemma register_lookup_set {T} (r : register T) regs v: register_lookup r (register_set r v regs) = v.
destruct regs, r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Lemma irrelevant_register_set {T T'} (r : register T) (r' : register T') regs v:
  register_beq r r' = false ->
  register_lookup r (register_set r' v regs) = register_lookup r regs.
destruct regs, r, r'; simpl; intro EQ; rewrite ?EQ; reflexivity.
Qed.

Arguments register_set : simpl never.
Arguments register_lookup : simpl never.

Definition register_accessors : register_accessors regstate register := (@register_lookup, @register_set).


(* Instantiate library definitions with types. *)

Definition read_reg {A E} := @read_reg register A E.
Definition write_reg {A E} := @write_reg register A E.
Definition MR r a := monadR register a r unit.
Definition M a := monad register a unit.
Definition returnM {A:Type} := @returnm register A unit.
Definition returnR {A:Type} (R:Type) := @returnm register A (R + unit).